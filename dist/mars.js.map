{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///webpack/bootstrap 31462c0580daba2e45a2","webpack:///./src/core/model_base_mixin.js","webpack:///./src/kmeans/kmeans_training_mixin.js","webpack:///./src/gmm/gmm_base_mixin.js","webpack:///./src/core/multiclass_mixin.js","webpack:///./src/index.js","webpack:///./src/training_set/index.js","webpack:///./src/training_set/phrase.js","webpack:///./src/train.js","webpack:///./src/common/euclidean.js","webpack:///./src/core/em_training_mixin.js","webpack:///./src/gmm/gmm_training_mixin.js","webpack:///./src/common/gaussian_distribution.js","webpack:///./src/common/matrix.js","webpack:///./src/common/ellipse.js","webpack:///./src/core/multiclass_training_mixin.js","webpack:///./src/predict.js","webpack:///./src/core/prediction_mixin.js","webpack:///./src/common/circular_buffer.js","webpack:///./src/gmm/gmm_prediction_mixin.js","webpack:///./src/core/multiclass_prediction_mixin.js"],"names":["root","factory","exports","module","define","amd","self","this","installedModules","__webpack_require__","moduleId","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","configurable","enumerable","get","n","__esModule","object","property","prototype","hasOwnProperty","p","s","_ref","inputDimension","outputDimension","_objectWithoutProperties","bimodal","dimension","params","keys","includes","map","key","reduce","a","b","clusters","trainingConfiguration","__WEBPACK_IMPORTED_MODULE_0__core_model_base_mixin__","Error","trainingConfig","assign","initialization","relativeDistanceThreshold","minIterations","maxIterations","model","kMeansTrainingPrototype","train","trainingSet","empty","centers","Array","from","fill","initializeClustersRandom","initializeClustersForgy","initClustersWithFirstPhrase","trainingNbIterations","previousCenters","updateCenters","meanClusterDistance","maxRelativeCenterVariation","k","__WEBPACK_IMPORTED_MODULE_1__common_euclidean__","Math","max","phrase","getPhrase","indices","step","floor","length","offset","t","random","pointsPerCluster","ppc","clustIdx","forEach","_","x","getFrame","numFramesPerCluster","frame","minDistance","clusterMembership","distance","gmmBasePrototype","gmmBimodalPrototype","likelihood","observation","gaussians","beta","componentLikelihood","mixtureComponent","mixtureCoeffs","components","regression","inputObservation","results","outputValues","outputCovariance","covarianceMode","tmpOutputValues","d2","parameters","__WEBPACK_IMPORTED_MODULE_0__model_base_mixin__","ModelBase","MulticlassBasePrototype","size","models","label","remove","__webpack_exports__","__WEBPACK_IMPORTED_MODULE_2__predict__","TrainingSet","constructor","columnNames","phrases","phraseIndex","toString","callback","push","undefined","__WEBPACK_IMPORTED_MODULE_0__phrase__","removeClass","filter","_extends","clear","getPhrasesOfClass","ts","labels","ll","concat","mean","sum","totalLength","standardDeviation","stddev","sqrt","minmax","min","Infinity","inputData","outputData","index","dim","slice","pushInput","trim","pushOutput","clearInput","clearOutput","__WEBPACK_IMPORTED_MODULE_1__kmeans_kmeans_training_mixin__","configuration","convergenceCriteria","__WEBPACK_IMPORTED_MODULE_6__core_multiclass_training_mixin__","__WEBPACK_IMPORTED_MODULE_5__core_multiclass_mixin__","MulticlassModelbase","trainGMM","regularization","__WEBPACK_IMPORTED_MODULE_4__gmm_gmm_training_mixin__","__WEBPACK_IMPORTED_MODULE_2__core_em_training_mixin__","__WEBPACK_IMPORTED_MODULE_3__gmm_gmm_base_mixin__","v1","v2","x1","percentChange","trainerPrototype","initTraining","logLikelihood","iterations","previousLogLikelihood","converged","updateTraining","pctChg","abs","Number","isNaN","terminateTraining","iteration","logProb","previousLogProb","absolute","relative","gmmTrainerPrototype","allocate","initParametersToDefault","initMeansWithKMeans","initCovariances","addCovarianceOffset","updateInverseCovariances","__WEBPACK_IMPORTED_MODULE_2__common_gaussian_distribution__","dataStddev","normCoeffs","currentRegularization","std","covariance","regularize","kmeansParams","gmeans","factor","d1","updateInverseCovariance","e","phraseIndices","E","tbase","normConst","log","pix","value","normalizeMixtureCoeffs","proto","baseGaussianPrototype","bimodalGaussianPrototype","data","covarianceDeterminant","covarianceDeterminantInput","dist","create","inverseCovariance","allocateBimodal","inputLikelihood","euclideanDistance","tmp","exp","PI","covMatrix","__WEBPACK_IMPORTED_MODULE_0__matrix__","inv","pinv","determinant","matrix","updateInverseCovarianceBimodal","toEllipse","dimension1","dimension2","gaussianEllipse","__WEBPACK_IMPORTED_MODULE_1__ellipse__","y","trace","eigenVal1","eigenVal2","width","height","angle","atan","fromEllipse","tantheta","tan","inverseCovarianceInput","prediction","f","covMatrixInput","invInput","updateOutputCovariance","covarianceGS","covarianceSG","tmptmptmp","product","covarianceMod","Matrix","matrixPrototype","print","nrows","line","j","ncols","padStart","console","transpose","out","mat","gaussJordanInverse","transp","prod","dst","newMat","swapLines","ii","swapColumns","nc","Ellipse","trainingFunction","classes","labs","likelihoodWindow","__WEBPACK_IMPORTED_MODULE_5__core_multiclass_prediction_mixin__","__WEBPACK_IMPORTED_MODULE_4__core_multiclass_mixin__","GMMPredictor","reset","__WEBPACK_IMPORTED_MODULE_3__gmm_gmm_prediction_mixin__","__WEBPACK_IMPORTED_MODULE_1__core_prediction_mixin__","__WEBPACK_IMPORTED_MODULE_2__gmm_gmm_base_mixin__","instantLikelihood","predictionBasePrototype","likelihoodBuffer","__WEBPACK_IMPORTED_MODULE_1__common_circular_buffer__","capacity","lw","predict","updateResults","bufSize","buffer","circularBufferPrototype","full","idx","values","singleGmmPredictionPrototype","singleGmmBimodalPredictionPrototype","multiClassRegressionEstimator","MulticlassPredictionBasePrototype","MulticlassPredictionBimodalPrototype","instantLikelihoods","smoothedLikelihoods","smoothedLogLikelihoods","smoothedNormalizedLikelihoods","likeliest","resetBimodal","sort","normInstant","normSmoothed","maxLogLikelihood","lab","[object Object]","instantNormalizedLikelihoods","updateRegressionResults"],"mappings":"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","file":"mars.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"mars\"] = factory();\n\telse\n\t\troot[\"mars\"] = factory();\n})(typeof self !== 'undefined' ? self : this, function() {\nreturn \n\n\n// WEBPACK FOOTER //\n// webpack/universalModuleDefinition"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 4);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 31462c0580daba2e45a2","export default function ModelBase({\n  inputDimension,\n  outputDimension,\n  ...parameters\n}) {\n  const p = parameters;\n  delete p.bimodal;\n  delete p.inputDimension;\n  delete p.outputDimension;\n  delete p.dimension;\n  return {\n    params: {\n      ...p,\n      get bimodal() {\n        return outputDimension > 0;\n      },\n      get inputDimension() {\n        return inputDimension;\n      },\n      get outputDimension() {\n        return outputDimension;\n      },\n      get dimension() {\n        return inputDimension + outputDimension;\n      },\n    },\n  };\n}\n\nexport function isBaseModel(o) {\n  if (!Object.keys(o).includes('params')) return false;\n  const keys = ['bimodal', 'inputDimension', 'outputDimension', 'dimension'];\n  return keys.map(key => Object.keys(o.params).includes(key))\n    .reduce((a, b) => a && b, true);\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/core/model_base_mixin.js","import { isBaseModel } from '../core/model_base_mixin';\nimport euclidean from '../common/euclidean';\n\nconst kMeansTrainingPrototype = {\n  train(trainingSet) {\n    if (!trainingSet || trainingSet.empty()) {\n      throw new Error('The training set is empty');\n    }\n\n    this.params.centers = Array.from(\n      Array(this.params.clusters),\n      () => new Array(this.params.dimension).fill(0),\n    );\n\n    // TODO: improve initialization =>\n    // https://www.slideshare.net/djempol/kmeans-initialization-15041920\n    //\n    if (this.trainingConfig.initialization === 'random') {\n      this.initializeClustersRandom(trainingSet);\n    } else if (this.trainingConfig.initialization === 'forgy') {\n      this.initializeClustersForgy(trainingSet);\n    } else if (this.trainingConfig.initialization === 'data') {\n      this.initClustersWithFirstPhrase(trainingSet);\n    } else {\n      throw new Error('Unknown K-Means initialization, must be `random`, `forgy` or `data`');\n    }\n\n    for (\n      let trainingNbIterations = 0;\n      trainingNbIterations < this.trainingConfig.maxIterations;\n      trainingNbIterations += 1\n    ) {\n      const previousCenters = this.params.centers;\n\n      this.updateCenters(previousCenters, trainingSet);\n\n      let meanClusterDistance = 0;\n      let maxRelativeCenterVariation = 0;\n      for (let k = 0; k < this.params.clusters; k += 1) {\n        for (let l = 0; l < this.params.clusters; l += 1) {\n          if (k !== l) {\n            meanClusterDistance += euclidean(\n              this.params.centers[k],\n              this.params.centers[l],\n            );\n          }\n        }\n        maxRelativeCenterVariation = Math.max(\n          euclidean(\n            previousCenters[k],\n            this.params.centers[k],\n          ),\n          maxRelativeCenterVariation,\n        );\n      }\n      meanClusterDistance /= this.params.clusters * (this.params.clusters - 1);\n      maxRelativeCenterVariation /= this.params.clusters;\n      maxRelativeCenterVariation /= meanClusterDistance;\n      if (maxRelativeCenterVariation < this.trainingConfig.relativeDistanceThreshold) break;\n    }\n    return this.params;\n  },\n\n  initClustersWithFirstPhrase(trainingSet) {\n    const phrase = trainingSet.getPhrase(trainingSet.indices()[0]);\n    const step = Math.floor(phrase.length / this.params.clusters);\n\n    let offset = 0;\n    for (let c = 0; c < this.params.clusters; c += 1) {\n      this.params.centers[c] = new Array(this.params.dimension).fill(0);\n      for (let t = 0; t < step; t += 1) {\n        for (let d = 0; d < this.params.dimension; d += 1) {\n          this.params.centers[c][d] += phrase.get(offset + t, d) / step;\n        }\n      }\n      offset += step;\n    }\n  },\n\n  initializeClustersRandom(trainingSet) {\n    const phrase = trainingSet.getPhrase(trainingSet.indices()[0]);\n    const indices = Array.from(\n      Array(phrase.length),\n      () => Math.floor(Math.random() * this.params.clusters),\n    );\n    const pointsPerCluster = indices.reduce(\n      (ppc, i) => {\n        const p = ppc;\n        p[i] += 1;\n        return p;\n      },\n      Array(this.params.clusters).fill(0),\n    );\n    for (let i = 0; i < indices.length; i += 1) {\n      const clustIdx = indices[i];\n      for (let d = 0; d < this.params.dimension; d += 1) {\n        this.params.centers[clustIdx][d] += phrase.get(i, d);\n      }\n    }\n    this.params.centers.forEach((_, c) => {\n      this.params.centers[c] = this.params.centers[c]\n        .map(x => x / pointsPerCluster[c]);\n    });\n  },\n\n  initializeClustersForgy(trainingSet) {\n    const phrase = trainingSet.getPhrase(trainingSet.indices()[0]);\n    const indices = Array.from(\n      Array(this.params.clusters),\n      () => Math.floor(Math.random() * phrase.length),\n    );\n    this.params.centers = indices.map(i => phrase.getFrame(i));\n  },\n\n  updateCenters(previousCenters, trainingSet) {\n    this.params.centers = Array.from(Array(this.params.clusters), () =>\n      new Array(this.params.dimension).fill(0));\n    const numFramesPerCluster = Array(this.params.clusters).fill(0);\n    trainingSet.forEach((phrase) => {\n      for (let t = 0; t < phrase.length; t += 1) {\n        const frame = phrase.getFrame(t);\n        let minDistance = euclidean(frame, previousCenters[0]);\n        let clusterMembership = 0;\n        for (let k = 1; k < this.params.clusters; k += 1) {\n          const distance = euclidean(\n            frame,\n            previousCenters[k],\n            this.params.dimension,\n          );\n          if (distance < minDistance) {\n            clusterMembership = k;\n            minDistance = distance;\n          }\n        }\n        numFramesPerCluster[clusterMembership] += 1;\n        for (let d = 0; d < this.params.dimension; d += 1) {\n          this.params.centers[clusterMembership][d] += phrase.get(t, d);\n        }\n      }\n    });\n    for (let k = 0; k < this.params.clusters; k += 1) {\n      if (numFramesPerCluster[k] > 0) {\n        for (let d = 0; d < this.params.dimension; d += 1) {\n          this.params.centers[k][d] /= numFramesPerCluster[k];\n        }\n      }\n    }\n  },\n};\n\nexport default function withKMeansTraining(\n  o,\n  clusters,\n  trainingConfiguration = {},\n) {\n  if (!isBaseModel(o)) {\n    throw new Error('The base object must include a standard set of parameters (`params` key), @see `ModelBase`.');\n  }\n  const trainingConfig = Object.assign({\n    initialization: 'random',\n    relativeDistanceThreshold: 1e-3,\n    minIterations: 5,\n    maxIterations: 100,\n  }, trainingConfiguration);\n  const model = Object.assign(o, kMeansTrainingPrototype, {\n    trainingConfig,\n  });\n  model.params.clusters = clusters;\n  return model;\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/kmeans/kmeans_training_mixin.js","import { isBaseModel } from '../core/model_base_mixin';\n\nconst gmmBasePrototype = {\n  likelihood(observation) {\n    let likelihood = 0;\n    for (let c = 0; c < this.params.gaussians; c += 1) {\n      this.beta[c] = this.componentLikelihood(observation, c);\n      likelihood += this.beta[c];\n    }\n    for (let c = 0; c < this.params.gaussians; c += 1) {\n      this.beta[c] /= likelihood;\n    }\n\n    return likelihood;\n  },\n\n  componentLikelihood(observation, mixtureComponent) {\n    if (mixtureComponent >= this.params.gaussians) {\n      throw new Error('The index of the Gaussian Mixture Component is out of bounds');\n    }\n    return this.params.mixtureCoeffs[mixtureComponent] *\n        this.params.components[mixtureComponent].likelihood(observation);\n  },\n};\n\nconst gmmBimodalPrototype = {\n  regression(inputObservation) {\n    this.results.outputValues = Array(this.outputDimension).fill(0);\n    this.results.outputCovariance = Array(this.covarianceMode === 'full' ? this.outputDimension ** 2 : this.outputDimension).fill(0);\n    const tmpOutputValues = Array(this.outputDimension).fill(0);\n\n    for (let c = 0; c < this.params.gaussians; c += 1) {\n      this.params.components[c].regression(inputObservation, tmpOutputValues);\n      for (let d = 0; d < this.outputDimension; d += 1) {\n        this.results.outputValues[d] += this.beta[c] * tmpOutputValues[d];\n        if (this.covarianceMode === 'full') {\n          for (let d2 = 0; d2 < this.outputDimension; d2 += 1) {\n            this.results.outputCovariance[(d * this.outputDimension) + d2] +=\n              (this.beta[c] ** 2) *\n              this.params.components[c].outputCovariance[(d * this.outputDimension) + d2];\n          }\n        } else {\n          this.results.outputCovariance[d] +=\n            (this.beta[c] ** 2) * this.params.components[c].outputCovariance[d];\n        }\n      }\n    }\n    return this.results.outputValues;\n  },\n};\n\nexport default function withGMMBase(o) {\n  if (!isBaseModel(o)) {\n    throw new Error('The base object must include a standard set of parameters (`params` key), @see `ModelBase`.');\n  }\n  return Object.assign(\n    o,\n    gmmBasePrototype,\n    o.params.bimodal ? gmmBimodalPrototype : {},\n  );\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/gmm/gmm_base_mixin.js","import ModelBase from './model_base_mixin';\n\nconst MulticlassBasePrototype = {\n  size() {\n    return this.models.size;\n  },\n\n  includes(label) {\n    return Object.keys(this.models).includes(label);\n  },\n\n  remove(label) {\n    if (this.includes(label)) {\n      delete this.models[label];\n    }\n  },\n};\n\nexport default function MulticlassModelbase({\n  inputDimension,\n  outputDimension,\n  ...parameters\n}) {\n  return Object.assign(\n    ModelBase({ inputDimension, outputDimension, ...parameters }),\n    MulticlassBasePrototype,\n  );\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/core/multiclass_mixin.js","/* esdoc-ignore */\n/**\n * Wrap everything in a Stream Object for a fluent API\n */\nexport { default as TrainingSet } from './training_set';\nexport * from './train';\nexport * from './predict';\n\n\n\n// WEBPACK FOOTER //\n// ./src/index.js","import Phrase from './phrase';\n\nexport default class TrainingSet {\n  constructor({\n    inputDimension = 1,\n    outputDimension = 0,\n    columnNames = null,\n  } = {}) {\n    this.bimodal = outputDimension > 0;\n    this.inputDimension = inputDimension;\n    this.outputDimension = outputDimension;\n    this.dimension = inputDimension + outputDimension;\n    this.columnNames = columnNames || Array(this.dimension).fill('');\n    this.phrases = {};\n  }\n\n  size() {\n    return Object.keys(this.phrases).length;\n  }\n\n  empty() {\n    return this.length === 0;\n  }\n\n  getPhrase(phraseIndex) {\n    if (Object.keys(this.phrases).includes(phraseIndex.toString())) {\n      return this.phrases[phraseIndex.toString()];\n    }\n    return null;\n  }\n\n  forEach(callback) {\n    Object.keys(this.phrases).forEach((phraseIndex) => {\n      callback(this.phrases[phraseIndex], phraseIndex, this.phrases);\n    });\n  }\n\n  push(phraseIndex, label = undefined, phrase = undefined) {\n    this.phrases[phraseIndex] = (phrase !== undefined) ? phrase : new Phrase({\n      inputDimension: this.inputDimension,\n      outputDimension: this.outputDimension,\n      columnNames: this.columnNames,\n      label: (label !== undefined) ? label : phraseIndex.toString(),\n    });\n  }\n\n  remove(phraseIndex) {\n    delete this.phrases[phraseIndex];\n  }\n\n  removeClass(label) {\n    this.phrases = Object.keys(this.phrases)\n      .filter(i => this.phrases[i].label !== label)\n      .map(i => ({ i: this.phrases[i] }))\n      .reduce((x, p) => ({ ...x, ...p }), {});\n  }\n\n  clear() {\n    this.phrases = {};\n  }\n\n  getPhrasesOfClass(label) {\n    const ts = new TrainingSet(this);\n    ts.phrases = Object.keys(this.phrases)\n      .filter(i => this.phrases[i].label === label)\n      .map(i => ({ i: this.phrases[i] }))\n      .reduce((x, p) => ({ ...x, ...p }), {});\n    return ts;\n  }\n\n  labels() {\n    return Object.keys(this.phrases)\n      .map(i => this.phrases[i].label)\n      .reduce((ll, x) => (ll.includes(x) ? ll : ll.concat([x])), []);\n  }\n\n  indices() {\n    return Object.keys(this.phrases);\n  }\n\n  mean() {\n    const sum = Array(this.dimension).fill(0);\n    let totalLength = 0;\n    Object.keys(this.phrases).forEach((i) => {\n      for (let d = 0; d < this.dimension; d += 1) {\n        for (let t = 0; t < this.phrases[i].length; t += 1) {\n          sum[d] += this.phrases[i].get(t, d);\n        }\n      }\n      totalLength += this.phrases[i].length;\n    });\n\n    return sum.map(x => x / totalLength);\n  }\n\n  standardDeviation() {\n    const stddev = Array(this.dimension).fill(0);\n    const mean = this.mean();\n    let totalLength = 0;\n    Object.keys(this.phrases).forEach((i) => {\n      for (let d = 0; d < this.dimension; d += 1) {\n        for (let t = 0; t < this.phrases[i].length; t += 1) {\n          stddev[d] += (this.phrases[i].get(t, d) - mean[d]) ** 2;\n        }\n      }\n      totalLength += this.phrases[i].length;\n    });\n\n    return stddev.map(x => Math.sqrt(x / totalLength));\n  }\n\n  minmax() {\n    const minmax = Array.from(\n      Array(this.dimension),\n      () => ({ min: +Infinity, max: -Infinity }),\n    );\n    Object.keys(this.phrases).forEach((i) => {\n      for (let d = 0; d < this.dimension; d += 1) {\n        for (let t = 0; t < this.phrases[i].length; t += 1) {\n          minmax[d].min += Math.min(minmax[d].min, this.phrases[i].get(t, d));\n          minmax[d].max += Math.max(minmax[d].max, this.phrases[i].get(t, d));\n        }\n      }\n    });\n    return minmax;\n  }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/training_set/index.js","export default class Phrase {\n  constructor({\n    inputDimension = 1,\n    outputDimension = 0,\n    columnNames = null,\n    label = '',\n  } = {}) {\n    this.bimodal = outputDimension > 0;\n    this.inputDimension = inputDimension;\n    this.outputDimension = outputDimension;\n    this.dimension = inputDimension + outputDimension;\n    this.length = 0;\n    this.label = label;\n    this.inputData = [];\n    this.outputData = [];\n    this.columnNames = columnNames || Array(this.dimension).fill('');\n  }\n\n  get(index, dim) {\n    if (typeof index !== 'number' || Math.floor(index) !== index) {\n      throw new Error('The index must be an integer');\n    }\n    if (dim >= this.dimension) {\n      throw new Error('Phrase: dimension out of bounds');\n    }\n    if (this.bimodal) {\n      if (dim < this.inputDimension) {\n        if (index >= this.inputData.length) {\n          throw new Error('Phrase: index out of bounds');\n        }\n        return this.inputData[index][dim];\n      }\n      if (index >= this.outputData.length) {\n        throw new Error('Phrase: index out of bounds');\n      }\n      return this.outputData[index][dim - this.inputDimension];\n    }\n    if (index >= this.length) {\n      throw new Error('Phrase: index out of bounds');\n    }\n    if (!this.inputData[index]) {\n      throw new Error('WTF?');\n    }\n    return this.inputData[index][dim];\n  }\n\n  getFrame(index) {\n    if (index >= this.length) {\n      throw new Error('Phrase: index out of bounds');\n    }\n    if (this.bimodal) {\n      return this.inputData[index].concat(this.outputData[index]);\n    }\n    return this.inputData[index];\n  }\n\n  push(observation) {\n    // console.log('push:', observation);\n    if (observation.length !== this.dimension) {\n      throw new Error('Observation has wrong dimension');\n    }\n\n    if (this.bimodal) {\n      this.inputData.push(observation.slice(0, this.inputDimension));\n      this.outputData.push(observation.slice(this.inputDimension, this.dimension));\n    } else {\n      this.inputData.push(observation);\n    }\n\n    this.length += 1;\n  }\n\n  pushInput(observation) {\n    if (!this.bimodal) {\n      throw new Error('this phrase is unimodal, use `push`');\n    }\n    if (observation.size() !== this.inputDimension) {\n      throw new Error('Observation has wrong dimension');\n    }\n\n    this.inputData.push(observation);\n    this.trim();\n  }\n\n  pushOutput(observation) {\n    if (!this.bimodal) {\n      throw new Error('this phrase is unimodal, use `push`');\n    }\n    if (observation.size() !== this.outputDimension) {\n      throw new Error('Observation has wrong dimension');\n    }\n\n    this.outputData.push(observation);\n    this.trim();\n  }\n\n  clear() {\n    this.length = 0;\n    this.inputData = [];\n    this.outputData = [];\n  }\n\n  clearInput() {\n    this.inputData = [];\n    this.trim();\n  }\n\n  clearOutput() {\n    this.outputData = [];\n    this.trim();\n  }\n\n  mean() {\n    const mean = Array(this.dimension).fill(0);\n    for (let d = 0; d < this.dimension; d += 1) {\n      for (let t = 0; t < this.length; t += 1) {\n        mean[d] += this.get(t, d);\n      }\n      mean[d] /= this.length;\n    }\n    return mean;\n  }\n\n  standardDeviation() {\n    const stddev = Array(this.dimension).fill(0);\n    const mean = this.mean();\n    for (let d = 0; d < this.dimension; d += 1) {\n      for (let t = 0; t < this.length; t += 1) {\n        stddev[d] += (this.get(t, d) - mean[d]) * (this.get(t, d) - mean[d]);\n      }\n      stddev[d] /= this.length;\n      stddev[d] = Math.sqrt(stddev[d]);\n    }\n    return stddev;\n  }\n\n  minmax() {\n    const minmax = Array.from(\n      Array(this.dimension),\n      () => ({ min: +Infinity, max: -Infinity }),\n    );\n    for (let d = 0; d < this.dimension; d += 1) {\n      for (let t = 0; t < this.length; t += 1) {\n        minmax[d].min = Math.min(this.get(t, d), minmax[d].min);\n        minmax[d].max = Math.max(this.get(t, d), minmax[d].max);\n      }\n    }\n    return minmax;\n  }\n\n  trim() {\n    if (this.bimodal) {\n      this.length = Math.min(this.inputData.length, this.outputData.length);\n    }\n  }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/training_set/phrase.js","import ModelBase from './core/model_base_mixin';\nimport withKMeansTraining from './kmeans/kmeans_training_mixin';\nimport withEMTraining from './core/em_training_mixin';\nimport withGMMBase from './gmm/gmm_base_mixin';\nimport withGMMTraining from './gmm/gmm_training_mixin';\nimport MulticlassModelbase from './core/multiclass_mixin';\nimport withMulticlassTraining from './core/multiclass_training_mixin';\n\nexport function trainKmeans(\n  trainingSet,\n  clusters,\n  trainingConfig = undefined,\n) {\n  const { inputDimension, outputDimension } = trainingSet;\n  const model = withKMeansTraining(\n    ModelBase({\n      inputDimension,\n      outputDimension,\n    }),\n    clusters,\n    trainingConfig,\n  );\n  return model.train(trainingSet);\n}\n\nexport function trainGMM(\n  trainingSet,\n  configuration,\n  convergenceCriteria = undefined,\n) {\n  const { inputDimension, outputDimension } = trainingSet;\n  const { gaussians, regularization, covarianceMode } = configuration;\n  const model = withGMMTraining(\n    withEMTraining(\n      withGMMBase(ModelBase({\n        inputDimension,\n        outputDimension,\n        ...configuration,\n      })),\n      convergenceCriteria,\n    ),\n    gaussians,\n    regularization,\n    covarianceMode,\n  );\n  return model.train(trainingSet);\n}\n\nexport function trainMulticlassGMM(\n  trainingSet,\n  configuration,\n  convergenceCriteria = undefined,\n) {\n  const { inputDimension, outputDimension } = trainingSet;\n  const model = withMulticlassTraining(\n    MulticlassModelbase({ inputDimension, outputDimension, ...configuration }),\n    ts => trainGMM(ts, configuration, convergenceCriteria),\n  );\n  return model.train(trainingSet);\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/train.js","export default function euclidean(v1, v2) {\n  return Math.sqrt(v1\n    .map((x1, i) => (x1 - v2[i]) ** 2)\n    .reduce((a, x) => (a + x), 0));\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/common/euclidean.js","const trainerPrototype = {\n  train(trainingSet) {\n    if (!trainingSet || trainingSet.empty()) {\n      throw new Error('The training set is empty');\n    }\n\n    this.initTraining(trainingSet);\n\n    let logLikelihood = -Infinity;\n    let iterations = 0;\n    let previousLogLikelihood = logLikelihood;\n\n    while (!this.converged(iterations, logLikelihood, previousLogLikelihood)) {\n      previousLogLikelihood = logLikelihood;\n      logLikelihood = this.updateTraining(trainingSet);\n\n      const pctChg =\n        100 * Math.abs((logLikelihood - previousLogLikelihood) / previousLogLikelihood);\n      if (Number.isNaN(pctChg) && iterations > 1) {\n        throw new Error('An error occured during training');\n      }\n\n      iterations += 1;\n    }\n\n    this.terminateTraining();\n    return this.params;\n  },\n\n  converged(iteration, logProb, previousLogProb) {\n    if (iteration >= this.convergenceCriteria.maxIterations) return true;\n    if (this.convergenceCriteria.maxIterations >= this.convergenceCriteria.minIterations) {\n      return iteration >= this.convergenceCriteria.maxIterations;\n    }\n    if (iteration < this.convergenceCriteria.minIterations) return false;\n    const percentChange = 100 * Math.abs((logProb - previousLogProb) / logProb);\n    return percentChange <= this.convergenceCriteria.percentChange;\n  },\n};\n\nexport default function withEMTraining(\n  o,\n  convergenceCriteria = {\n    percentChange: 1e-3,\n    minIterations: 5,\n    maxIterations: 100,\n  },\n) {\n  return Object.assign(o, trainerPrototype, { convergenceCriteria });\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/core/em_training_mixin.js","import ModelBase from '../core/model_base_mixin';\nimport withKMeansTraining from '../kmeans/kmeans_training_mixin';\nimport GaussianDistribution from '../common/gaussian_distribution';\n\nconst gmmTrainerPrototype = {\n  initTraining(trainingSet) {\n    this.allocate();\n    this.initParametersToDefault(trainingSet.standardDeviation());\n    this.initMeansWithKMeans(trainingSet);\n    this.initCovariances(trainingSet);\n    this.addCovarianceOffset();\n    this.updateInverseCovariances();\n  },\n\n  allocate() {\n    this.params.components = Array.from(\n      Array(this.params.gaussians),\n      () => new GaussianDistribution(\n        this.params.inputDimension,\n        this.params.outputDimension,\n        this.params.covarianceMode,\n      ),\n    );\n    this.params.mixtureCoeffs = Array(this.params.gaussians).fill(0);\n    this.beta = Array(this.params.gaussians).fill(0);\n  },\n\n  initParametersToDefault(dataStddev) {\n    let normCoeffs = 0;\n    this.currentRegularization = dataStddev.map(std => Math.max(\n      this.params.regularization.absolute,\n      this.params.regularization.relative * std,\n    ));\n    for (let c = 0; c < this.params.gaussians; c += 1) {\n      if (this.params.covarianceMode === 'full') {\n        this.params.components[c].covariance = Array(this.params.dimension ** 2)\n          .fill(this.params.regularization.absolute / 2);\n      } else {\n        this.params.components[c].covariance = Array(this.params.dimension).fill(0);\n      }\n      this.params.components[c].regularize(this.currentRegularization);\n      this.params.mixtureCoeffs[c] = 1 / this.params.gaussians;\n      normCoeffs += this.params.mixtureCoeffs[c];\n    }\n    for (let c = 0; c < this.params.gaussians; c += 1) {\n      this.params.mixtureCoeffs[c] /= normCoeffs;\n    }\n  },\n\n  initMeansWithKMeans(trainingSet) {\n    if (!trainingSet || trainingSet.empty()) return;\n    const kmeans = withKMeansTraining(\n      ModelBase({\n        inputDimension: this.params.inputDimension,\n        outputDimension: this.params.outputDimension,\n      }),\n      this.params.gaussians,\n      { initialization: 'random' },\n    );\n    const kmeansParams = kmeans.train(trainingSet);\n    for (let c = 0; c < this.params.gaussians; c += 1) {\n      this.params.components[c].mean = kmeansParams.centers[c];\n    }\n  },\n\n  initCovariances(trainingSet) {\n    // TODO: simplify with covariance symmetricity\n    // TODO: If Kmeans, covariances from cluster members\n    if (!trainingSet || trainingSet.empty()) return;\n\n    for (let n = 0; n < this.params.gaussians; n += 1) {\n      this.params.components[n].covariance = Array((this.params.covarianceMode === 'full') ? this.params.dimension ** 2 : this.params.dimension).fill(0);\n    }\n\n    const gmeans = Array(this.params.gaussians * this.params.dimension).fill(0);\n    const factor = Array(this.params.gaussians).fill(0);\n    trainingSet.forEach((phrase) => {\n      const step = Math.floor(phrase.length / this.params.gaussians);\n      let offset = 0;\n      for (let n = 0; n < this.params.gaussians; n += 1) {\n        for (let t = 0; t < step; t += 1) {\n          for (let d1 = 0; d1 < this.params.dimension; d1 += 1) {\n            gmeans[(n * this.params.dimension) + d1] += phrase.get(offset + t, d1);\n            if (this.params.covarianceMode === 'full') {\n              for (let d2 = 0; d2 < this.params.dimension; d2 += 1) {\n                this.params.components[n]\n                  .covariance[(d1 * this.params.dimension) + d2] +=\n                  phrase.get(offset + t, d1) * phrase.get(offset + t, d2);\n              }\n            } else {\n              this.params.components[n].covariance[d1] +=\n                phrase.get(offset + t, d1) ** 2;\n            }\n          }\n        }\n        offset += step;\n        factor[n] += step;\n      }\n    });\n\n    for (let n = 0; n < this.params.gaussians; n += 1) {\n      for (let d1 = 0; d1 < this.params.dimension; d1 += 1) {\n        gmeans[(n * this.params.dimension) + d1] /= factor[n];\n        if (this.params.covarianceMode === 'full') {\n          for (let d2 = 0; d2 < this.params.dimension; d2 += 1) {\n            this.params.components[n].covariance[(d1 * this.params.dimension) + d2] /= factor[n];\n          }\n        } else {\n          this.params.components[n].covariance[d1] /= factor[n];\n        }\n      }\n    }\n\n    for (let n = 0; n < this.params.gaussians; n += 1) {\n      for (let d1 = 0; d1 < this.params.dimension; d1 += 1) {\n        if (this.params.covarianceMode === 'full') {\n          for (let d2 = 0; d2 < this.params.dimension; d2 += 1) {\n            this.params.components[n].covariance[(d1 * this.params.dimension) + d2] -=\n              gmeans[(n * this.params.dimension) + d1] *\n              gmeans[(n * this.params.dimension) + d2];\n          }\n        } else {\n          this.params.components[n].covariance[d1] -=\n            gmeans[(n * this.params.dimension) + d1] ** 2;\n        }\n      }\n    }\n  },\n\n  addCovarianceOffset() {\n    this.params.components.forEach((c) => {\n      c.regularize(this.currentRegularization);\n    });\n  },\n\n  updateInverseCovariances() {\n    this.params.components.forEach((c) => {\n      c.updateInverseCovariance();\n    });\n    try {\n      this.params.components.forEach((c) => {\n        c.updateInverseCovariance();\n      });\n    } catch (e) {\n      throw new Error('Matrix inversion error: varianceoffset must be too small');\n    }\n  },\n\n  updateTraining(trainingSet) {\n    let logProb = 0;\n    let totalLength = 0;\n    trainingSet.forEach((phrase) => {\n      totalLength += phrase.length;\n    });\n    const phraseIndices = Object.keys(trainingSet.phrases);\n\n    const p = Array.from(\n      Array(this.params.gaussians),\n      () => new Array(totalLength).fill(0),\n    );\n    const E = Array(this.params.gaussians).fill(0);\n    let tbase = 0;\n\n    trainingSet.forEach((phrase) => {\n      for (let t = 0; t < phrase.length; t += 1) {\n        let normConst = 0;\n        for (let c = 0; c < this.params.gaussians; c += 1) {\n          p[c][tbase + t] = this.componentLikelihood(phrase.getFrame(t), c);\n\n          if (p[c][tbase + t] === 0 ||\n            Number.isNaN(p[c][tbase + t]) ||\n            p[c][tbase + t] === +Infinity) {\n            p[c][tbase + t] = 1e-100;\n          }\n          normConst += p[c][tbase + t];\n        }\n        for (let c = 0; c < this.params.gaussians; c += 1) {\n          p[c][tbase + t] /= normConst;\n          E[c] += p[c][tbase + t];\n        }\n        logProb += Math.log(normConst);\n      }\n      tbase += phrase.length;\n    });\n\n    // Estimate Mixture coefficients\n    for (let c = 0; c < this.params.gaussians; c += 1) {\n      this.params.mixtureCoeffs[c] = E[c] / totalLength;\n    }\n\n    // Estimate means\n    for (let c = 0; c < this.params.gaussians; c += 1) {\n      for (let d = 0; d < this.params.dimension; d += 1) {\n        this.params.components[c].mean[d] = 0;\n        tbase = 0;\n        for (let pix = 0; pix < phraseIndices.length; pix += 1) {\n          const phrase = trainingSet.phrases[phraseIndices[pix]];\n          for (let t = 0; t < phrase.length; t += 1) {\n            this.params.components[c].mean[d] +=\n              p[c][tbase + t] * phrase.get(t, d);\n          }\n          tbase += phrase.length;\n        }\n        this.params.components[c].mean[d] /= E[c];\n      }\n    }\n\n    // estimate covariances\n    if (this.params.covarianceMode === 'full') {\n      for (let c = 0; c < this.params.gaussians; c += 1) {\n        for (let d1 = 0; d1 < this.params.dimension; d1 += 1) {\n          for (let d2 = d1; d2 < this.params.dimension; d2 += 1) {\n            this.params.components[c].covariance[(d1 * this.params.dimension) + d2] = 0;\n            tbase = 0;\n            for (let pix = 0; pix < phraseIndices.length; pix += 1) {\n              const phrase = trainingSet.phrases[phraseIndices[pix]];\n              for (let t = 0; t < phrase.length; t += 1) {\n                this.params.components[c].covariance[(d1 * this.params.dimension) + d2] +=\n                  p[c][tbase + t] *\n                  (phrase.get(t, d1) - this.params.components[c].mean[d1]) *\n                  (phrase.get(t, d2) - this.params.components[c].mean[d2]);\n              }\n              tbase += phrase.length;\n            }\n            this.params.components[c].covariance[(d1 * this.params.dimension) + d2] /= E[c];\n            if (d1 !== d2) {\n              this.params.components[c].covariance[(d2 * this.params.dimension) + d1] =\n                this.params.components[c].covariance[(d1 * this.params.dimension) + d2];\n            }\n          }\n        }\n      }\n    } else {\n      for (let c = 0; c < this.params.gaussians; c += 1) {\n        for (let d1 = 0; d1 < this.params.dimension; d1 += 1) {\n          this.params.components[c].covariance[d1] = 0;\n          tbase = 0;\n          for (let pix = 0; pix < phraseIndices.length; pix += 1) {\n            const phrase = trainingSet.phrases[phraseIndices[pix]];\n            for (let t = 0; t < phrase.length; t += 1) {\n              const value = (phrase.get(t, d1) - this.params.components[c].mean[d1]);\n              this.params.components[c].covariance[d1] +=\n                    p[c][tbase + t] * value * value;\n            }\n            tbase += phrase.length;\n          }\n          this.params.components[c].covariance[d1] /= E[c];\n        }\n      }\n    }\n\n    this.addCovarianceOffset();\n    this.updateInverseCovariances();\n\n    return logProb;\n  },\n\n  normalizeMixtureCoeffs() {\n    let normConst = 0;\n    for (let c = 0; c < this.params.gaussians; c += 1) {\n      normConst += this.params.mixtureCoeffs[c];\n    }\n    if (normConst > 0) {\n      for (let c = 0; c < this.params.gaussians; c += 1) {\n        this.params.mixtureCoeffs[c] /= normConst;\n      }\n    } else {\n      for (let c = 0; c < this.params.gaussians; c += 1) {\n        this.params.mixtureCoeffs[c] = 1 / this.params.gaussians;\n      }\n    }\n  },\n\n  terminateTraining() {},\n};\n\nexport default function withGMMTraining(\n  o,\n  gaussians = 1,\n  regularization = { absolute: 1e-3, relative: 1e-2 },\n  covarianceMode = 'full',\n) {\n  if (!Object.keys(o).includes('params')) {\n    throw new Error('The base object must include a standard set of parameters (`params` key), @see `ModelBase`.');\n  }\n  return Object.assign(\n    o,\n    gmmTrainerPrototype,\n    {\n      params: {\n        ...o.params,\n        gaussians,\n        regularization,\n        covarianceMode,\n      },\n    },\n  );\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/gmm/gmm_training_mixin.js","import Matrix from './matrix';\nimport { Ellipse } from './ellipse';\n\nconst baseGaussianPrototype = {\n  allocate() {\n    this.mean = new Array(this.dimension).fill(0);\n    if (this.covarianceMode === 'full') {\n      this.covariance = new Array(this.dimension ** 2).fill(0);\n      this.inverseCovariance = new Array(this.dimension ** 2).fill(0);\n    } else {\n      this.covariance = new Array(this.dimension).fill(0);\n      this.inverseCovariance = new Array(this.dimension).fill(0);\n    }\n    if (this.bimodal) {\n      this.allocateBimodal();\n    }\n  },\n\n  /**\n   * Get Likelihood of a data vector\n   * @param {Array} observation data observation\n   * @return {Number} likelihood\n   */\n  likelihood(observation) {\n    if (this.covarianceDeterminant === 0) {\n      throw new Error('Covariance Matrix is not invertible');\n    }\n    if (this.bimodal && observation.length === this.inputDimension) {\n      return this.inputLikelihood(observation);\n    }\n    if (observation.length !== this.dimension) {\n      throw new Error(`GaussianDistribution: observation has wrong dimension. Expected \\`${this.dimension}\\`, got \\`${observation.length}\\``);\n    }\n\n    let euclideanDistance = 0;\n    if (this.covarianceMode === 'full') {\n      for (let l = 0; l < this.dimension; l += 1) {\n        let tmp = 0;\n        for (let k = 0; k < this.dimension; k += 1) {\n          tmp += this.inverseCovariance[(l * this.dimension) + k] *\n            (observation[k] - this.mean[k]);\n        }\n        euclideanDistance += (observation[l] - this.mean[l]) * tmp;\n      }\n    } else {\n      for (let l = 0; l < this.dimension; l += 1) {\n        euclideanDistance += this.inverseCovariance[l] *\n          (observation[l] - this.mean[l]) *\n          (observation[l] - this.mean[l]);\n      }\n    }\n\n    let p = Math.exp(-0.5 * euclideanDistance) /\n      Math.sqrt(this.covarianceDeterminant * ((2 * Math.PI) ** this.dimension));\n\n    if (p < 1e-180 || Number.isNaN(p) || Math.abs(p) === +Infinity) {\n      p = 1e-180;\n    }\n\n    return p;\n  },\n\n  regularize(regularization) {\n    if (this.covarianceMode === 'full') {\n      for (let d = 0; d < this.dimension; d += 1) {\n        this.covariance[(d * this.dimension) + d] += regularization[d];\n      }\n    } else {\n      for (let d = 0; d < this.dimension; d += 1) {\n        this.covariance[d] += regularization[d];\n      }\n    }\n  },\n\n  updateInverseCovariance() {\n    if (this.covarianceMode === 'full') {\n      const covMatrix = Matrix(this.dimension, this.dimension);\n\n      covMatrix.data = this.covariance.slice();\n      const inv = covMatrix.pinv();\n      this.covarianceDeterminant = inv.determinant;\n      this.inverseCovariance = inv.matrix.data;\n    } else { // DIAGONAL COVARIANCE\n      this.covarianceDeterminant = 1;\n      for (let d = 0; d < this.dimension; d += 1) {\n        if (this.covariance[d] <= 0) {\n          throw new Error('Non-invertible matrix');\n        }\n        this.inverseCovariance[d] = 1 / this.covariance[d];\n        this.covarianceDeterminant *= this.covariance[d];\n      }\n    }\n    if (this.bimodal) {\n      this.updateInverseCovarianceBimodal();\n    }\n  },\n\n  toEllipse(dimension1, dimension2) {\n    if (dimension1 >= this.dimension || dimension2 >= this.dimension) {\n      throw new Error('dimensions out of range');\n    }\n\n    const gaussianEllipse = Ellipse();\n    gaussianEllipse.x = this.mean[dimension1];\n    gaussianEllipse.y = this.mean[dimension2];\n\n    // Represent 2D covariance with square matrix\n    // |a b|\n    // |b c|\n    let a;\n    let b;\n    let c;\n    if (this.covarianceMode === 'full') {\n      a = this.covariance[(dimension1 * this.dimension) + dimension1];\n      b = this.covariance[(dimension1 * this.dimension) + dimension2];\n      c = this.covariance[(dimension2 * this.dimension) + dimension2];\n    } else {\n      a = this.covariance[dimension1];\n      b = 0;\n      c = this.covariance[dimension2];\n    }\n\n    // Compute Eigen Values to get width, height and angle\n    const trace = a + c;\n    const determinant = (a * c) - (b * b);\n    const eigenVal1 = 0.5 * (trace + Math.sqrt((trace ** 2) - (4 * determinant)));\n    const eigenVal2 = 0.5 * (trace - Math.sqrt((trace ** 2) - (4 * determinant)));\n    gaussianEllipse.width = Math.sqrt(5.991 * eigenVal1);\n    gaussianEllipse.height = Math.sqrt(5.991 * eigenVal2);\n    gaussianEllipse.angle = Math.atan(b / (eigenVal1 - c));\n    if (Number.isNaN(gaussianEllipse.angle)) {\n      gaussianEllipse.angle = Math.PI / 2;\n    }\n\n    return gaussianEllipse;\n  },\n\n  fromEllipse(gaussianEllipse, dimension1, dimension2) {\n    if (dimension1 >= this.dimension || dimension2 >= this.dimension) {\n      throw new Error('dimensions out of range');\n    }\n\n    this.mean[dimension1] = gaussianEllipse.x;\n    this.mean[dimension2] = gaussianEllipse.y;\n\n    const eigenVal1 = (gaussianEllipse.width * gaussianEllipse.width) / 5.991;\n    const eigenVal2 = (gaussianEllipse.height * gaussianEllipse.height) / 5.991;\n    const tantheta = Math.tan(gaussianEllipse.angle);\n    const b = ((eigenVal1 - eigenVal2) * tantheta) / ((tantheta ** 2) + 1);\n    const c = eigenVal1 - (b / tantheta);\n    const a = eigenVal2 + (b / tantheta);\n\n    if (this.covarianceMode === 'full') {\n      this.covariance[(dimension1 * this.dimension) + dimension1] = a;\n      this.covariance[(dimension1 * this.dimension) + dimension2] = b;\n      this.covariance[(dimension2 * this.dimension) + dimension1] = b;\n      this.covariance[(dimension2 * this.dimension) + dimension2] = c;\n    } else {\n      this.covariance[dimension1] = a;\n      this.covariance[dimension2] = c;\n    }\n    this.updateInverseCovariance();\n  },\n};\n\nconst bimodalGaussianPrototype = {\n  allocateBimodal() {\n    if (this.covarianceMode === 'full') {\n      this.inverseCovarianceInput = new Array(this.inputDimension ** 2).fill(0);\n    } else {\n      this.inverseCovarianceInput = new Array(this.inputDimension).fill(0);\n    }\n  },\n\n  inputLikelihood(inputObservation) {\n    if (this.covarianceDeterminantInput === 0) {\n      throw new Error('Covariance Matrix of input modality is not invertible');\n    }\n\n    let euclideanDistance = 0;\n    if (this.covarianceMode === 'full') {\n      for (let l = 0; l < this.inputDimension; l += 1) {\n        let tmp = 0;\n        for (let k = 0; k < this.inputDimension; k += 1) {\n          tmp += this.inverseCovarianceInput[(l * this.inputDimension) + k] *\n            (inputObservation[k] - this.mean[k]);\n        }\n        euclideanDistance += (inputObservation[l] - this.mean[l]) * tmp;\n      }\n    } else {\n      for (let l = 0; l < this.inputDimension; l += 1) {\n        euclideanDistance += this.inverseCovariance[l] *\n          (inputObservation[l] - this.mean[l]) *\n          (inputObservation[l] - this.mean[l]);\n      }\n    }\n\n    let p = Math.exp(-0.5 * euclideanDistance) /\n               Math.sqrt(this.covarianceDeterminantInput *\n                    ((2 * Math.PI) ** this.inputDimension));\n\n    if (p < 1e-180 || Number.isNaN(p) || Math.abs(p) === +Infinity) p = 1e-180;\n\n    return p;\n  },\n\n  regression(inputObservation) {\n    const outputDimension = this.dimension - this.inputDimension;\n    const prediction = Array(outputDimension).fill(0);\n\n    if (this.covarianceMode === 'full') {\n      for (let d = 0; d < outputDimension; d += 1) {\n        prediction[d] = this.mean[this.inputDimension + d];\n        for (let e = 0; e < this.inputDimension; e += 1) {\n          let tmp = 0;\n          for (let f = 0; f < this.inputDimension; f += 1) {\n            tmp += this.inverseCovarianceInput[(e * this.inputDimension) + f] *\n              (inputObservation[f] - this.mean[f]);\n          }\n          prediction[d] += tmp *\n            this.covariance[((d + this.inputDimension) * this.dimension) + e];\n        }\n      }\n    } else {\n      for (let d = 0; d < outputDimension; d += 1) {\n        prediction[d] = this.mean[this.inputDimension + d];\n      }\n    }\n    return prediction;\n  },\n\n  updateInverseCovarianceBimodal() {\n    if (this.covarianceMode === 'full') {\n      const covMatrixInput = Matrix(this.inputDimension, this.inputDimension);\n      for (let d1 = 0; d1 < this.inputDimension; d1 += 1) {\n        for (let d2 = 0; d2 < this.inputDimension; d2 += 1) {\n          covMatrixInput.data[(d1 * this.inputDimension) + d2] =\n            this.covariance[(d1 * this.dimension) + d2];\n        }\n      }\n      const invInput = covMatrixInput.pinv();\n      this.covarianceDeterminantInput = invInput.determinant;\n      this.inverseCovarianceInput = invInput.matrix.data;\n    } else { // DIAGONAL COVARIANCE\n      this.covarianceDeterminantInput = 1;\n      for (let d = 0; d < this.inputDimension; d += 1) {\n        if (this.covariance[d] <= 0) {\n          throw new Error('Non-invertible matrix');\n        }\n        this.inverseCovarianceInput[d] = 1 / this.covariance[d];\n        this.covarianceDeterminantInput *= this.covariance[d];\n      }\n    }\n    this.updateOutputCovariance();\n  },\n\n  updateOutputCovariance() {\n    if (this.covarianceMode === 'diagonal') {\n      this.outputCovariance = this.covariance.slice(0, this.inputDimension);\n      return;\n    }\n\n    // CASE: FULL COVARIANCE\n    const covMatrixInput = Matrix(this.inputDimension, this.inputDimension);\n    for (let d1 = 0; d1 < this.inputDimension; d1 += 1) {\n      for (let d2 = 0; d2 < this.inputDimension; d2 += 1) {\n        covMatrixInput.data[(d1 * this.inputDimension) + d2] =\n          this.covariance[(d1 * this.dimension) + d2];\n      }\n    }\n    const inv = covMatrixInput.pinv();\n    const covarianceGS = Matrix(this.inputDimension, this.outputDimension);\n    for (let d1 = 0; d1 < this.inputDimension; d1 += 1) {\n      for (let d2 = 0; d2 < this.outputDimension; d2 += 1) {\n        covarianceGS.data[(d1 * this.outputDimension) + d2] =\n          this.covariance[(d1 * this.dimension) + this.inputDimension + d2];\n      }\n    }\n    const covarianceSG = Matrix(this.outputDimension, this.inputDimension);\n    for (let d1 = 0; d1 < this.outputDimension; d1 += 1) {\n      for (let d2 = 0; d2 < this.inputDimension; d2 += 1) {\n        covarianceSG.data[(d1 * this.inputDimension) + d2] =\n          this.covariance[((this.inputDimension + d1) * this.dimension) + d2];\n      }\n    }\n    const tmptmptmp = inv.matrix.product(covarianceGS);\n    const covarianceMod = covarianceSG.product(tmptmptmp);\n    this.outputCovariance = Array(this.outputDimension ** 2).fill(0);\n    for (let d1 = 0; d1 < this.outputDimension; d1 += 1) {\n      for (let d2 = 0; d2 < this.outputDimension; d2 += 1) {\n        this.outputCovariance[(d1 * this.outputDimension) + d2] =\n          this.covariance[((this.inputDimension + d1) * this.dimension) +\n            this.inputDimension + d2] -\n            covarianceMod.data[(d1 * this.outputDimension) + d2];\n      }\n    }\n  },\n};\n\n/**\n * Multivariate Gaussian Distribution factory function.\n * Full covariance, optionally multimodal with support for regression.\n *\n * @param {Boolean} [bimodal=false] specify if the distribution is bimodal\n * for use in regression\n * @param {Number}  [dimension=1] dimension of the distribution\n * @param {Number}  [inputDimension=0] dimension of the input modality in\n * bimodal mode.\n * @param {String}  [covarianceMode='full'] covariance mode (full vs\n * diagonal)\n */\nexport default function GaussianDistribution(\n  inputDimension = 1,\n  outputDimension = 0,\n  covarianceMode = 'full',\n) {\n  const bimodal = outputDimension > 0;\n  const dimension = inputDimension + outputDimension;\n  const proto = bimodal ?\n    Object.assign({}, baseGaussianPrototype, bimodalGaussianPrototype) :\n    baseGaussianPrototype;\n  const data = Object.assign(\n    {\n      bimodal,\n      dimension,\n      inputDimension,\n      outputDimension,\n      covarianceMode,\n      covarianceDeterminant: 0,\n    },\n    bimodal ? { covarianceDeterminantInput: 0 } : {},\n  );\n  const dist = Object.assign(\n    Object.create(proto),\n    data,\n  );\n  dist.allocate();\n  return dist;\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/common/gaussian_distribution.js","/* eslint-disable no-use-before-define */\nconst kEpsilonPseudoInverse = 1.0e-9;\n\nconst matrixPrototype = {\n  /**\n   * Compute the Sum of the matrix\n   * @return {Number} Sum of all elements in the matrix\n   */\n  sum() {\n    return this.data.reduce((a, b) => a + b, 0);\n  },\n\n  /**\n   * Pretty-Print the matrix\n   */\n  print() {\n    for (let i = 0; i < this.nrows; i += 1) {\n      let line = '';\n      for (let j = 0; j < this.ncols; j += 1) {\n        line += `${this.data[(i * this.ncols) + j]} `.padStart(10);\n      }\n      console.log(line); // eslint-disable-line no-console\n    }\n  },\n\n  /**\n   * Compute the transpose matrix\n   * @return {Matrix}\n   */\n  transpose() {\n    const out = Matrix(this.ncols, this.nrows);\n    for (let i = 0; i < this.ncols; i += 1) {\n      for (let j = 0; j < this.nrows; j += 1) {\n        out.data[(i * this.nrows) + j] = this.data[(j * this.ncols) + i];\n      }\n    }\n    return out;\n  },\n\n  /**\n   * Compute the product of matrices\n   * @param  {Matrix} mat Second matrix\n   * @return {Matrix}     Product of the current matrix by `mat`\n   */\n  product(mat) {\n    if (this.ncols !== mat.nrows) {\n      throw new Error('Wrong dimensions for matrix product');\n    }\n    const out = Matrix(this.nrows, mat.ncols);\n    for (let i = 0; i < this.nrows; i += 1) {\n      for (let j = 0; j < mat.ncols; j += 1) {\n        out.data[(i * mat.ncols) + j] = 0;\n        for (let k = 0; k < this.ncols; k += 1) {\n          out.data[(i * mat.ncols) + j] +=\n            this.data[(i * this.ncols) + k] * mat.data[(k * mat.ncols) + j];\n        }\n      }\n    }\n    return out;\n  },\n\n  /**\n   * Compute the Pseudo-Inverse of a Matrix\n   * @param  {Number} determinant Determinant (computed with the inversion)\n   * @return {Matrix}             Pseudo-inverse of the matrix\n   */\n  pinv() {\n    if (this.nrows === this.ncols) {\n      return this.gaussJordanInverse();\n    }\n\n    const transp = this.transpose();\n    if (this.nrows >= this.ncols) {\n      const prod = transp.product(this);\n      const { determinant, matrix: dst } = prod.gaussJordanInverse();\n      return { determinant, matrix: dst.product(transp) };\n    }\n    const prod = this.product(transp);\n    const { determinant, matrix: dst } = prod.gaussJordanInverse();\n    return { determinant, matrix: transp.product(dst) };\n  },\n\n  /**\n   * Compute the Gauss-Jordan Inverse of a Square Matrix\n   * !!! Determinant (computed with the inversion\n   */\n  gaussJordanInverse() {\n    if (this.nrows !== this.ncols) {\n      throw new Error('Gauss-Jordan inversion: Cannot invert Non-square matrix');\n    }\n    let determinant = 1;\n    const mat = Matrix(this.nrows, this.ncols * 2);\n    const newMat = Matrix(this.nrows, this.ncols * 2);\n    const n = this.nrows;\n\n    // Create matrix\n    for (let i = 0; i < n; i += 1) {\n      for (let j = 0; j < n; j += 1) {\n        mat.data[(i * 2 * n) + j] = this.data[(i * n) + j];\n      }\n      mat.data[(i * 2 * n) + n + i] = 1;\n    }\n\n    for (let k = 0; k < n; k += 1) {\n      let i = k;\n      while (Math.abs(mat.data[(i * 2 * n) + k]) < kEpsilonPseudoInverse) {\n        i += 1;\n        if (i === n) {\n          throw new Error('Non-invertible matrix');\n        }\n      }\n      determinant *= mat.data[(i * 2 * n) + k];\n\n      // if found > Exchange lines\n      if (i !== k) {\n        mat.swapLines(i, k);\n      }\n\n      newMat.data = mat.data.slice();\n\n      for (let j = 0; j < 2 * n; j += 1) {\n        newMat.data[(k * 2 * n) + j] /= mat.data[(k * 2 * n) + k];\n      }\n      for (let ii = 0; ii < n; ii += 1) {\n        if (ii !== k) {\n          for (let j = 0; j < 2 * n; j += 1) {\n            newMat.data[(ii * 2 * n) + j] -=\n                mat.data[(ii * 2 * n) + k] *\n                newMat.data[(k * 2 * n) + j];\n          }\n        }\n      }\n      mat.data = newMat.data.slice();\n    }\n\n    const dst = Matrix(this.nrows, this.ncols);\n    for (let i = 0; i < n; i += 1) {\n      for (let j = 0; j < n; j += 1) {\n        dst.data[(i * n) + j] = mat.data[(i * 2 * n) + n + j];\n      }\n    }\n    return { determinant, matrix: dst };\n  },\n\n  /**\n   * Swap 2 lines of the matrix\n   * @param  {[type]} i index of the first line\n   * @param  {[type]} j index of the second line\n   */\n  swapLines(i, j) {\n    for (let k = 0; k < this.ncols; k += 1) {\n      const tmp = this.data[(i * this.ncols) + k];\n      this.data[(i * this.ncols) + k] = this.data[(j * this.ncols) + k];\n      this.data[(j * this.ncols) + k] = tmp;\n    }\n  },\n\n  /**\n   * Swap 2 columns of the matrix\n   * @param  {[type]} i index of the first column\n   * @param  {[type]} j index of the second column\n   */\n  swapColumns(i, j) {\n    for (let k = 0; k < this.nrows; k += 1) {\n      const tmp = this.data[(k * this.ncols) + i];\n      this.data[(k * this.ncols) + i] = this.data[(k * this.ncols) + j];\n      this.data[(k * this.ncols) + j] = tmp;\n    }\n  },\n};\n\nexport default function Matrix(nrows = 0, ncols = -1) {\n  const nc = ncols < 0 ? nrows : ncols;\n  return Object.assign(\n    Object.create(matrixPrototype), //\n    {\n      nrows,\n      ncols: nc,\n      data: Array(nrows * nc).fill(0),\n    },\n  );\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/common/matrix.js","export function Ellipse() {\n  return {\n    x: 0,\n    y: 0,\n    width: 0,\n    height: 0,\n    angle: 0,\n  };\n}\n\nexport function covariance2ellipse(cxx, cxy, cyy) {\n  const gaussianEllipse = Ellipse();\n  gaussianEllipse.x = 0;\n  gaussianEllipse.y = 0;\n\n  // Compute Eigen Values to get width, height and angle\n  const trace = cxx + cyy;\n  const determinant = (cxx * cyy) - (cxy * cxy);\n  const eigenVal1 = 0.5 * (trace + Math.sqrt((trace ** 2) - (4 * determinant)));\n  const eigenVal2 = 0.5 * (trace - Math.sqrt((trace ** 2) - (4 * determinant)));\n  gaussianEllipse.width = Math.sqrt(5.991 * eigenVal1);\n  gaussianEllipse.height = Math.sqrt(5.991 * eigenVal2);\n  gaussianEllipse.angle = Math.atan(cxy / (eigenVal1 - cyy));\n  if (Number.isNaN(gaussianEllipse.angle)) {\n    gaussianEllipse.angle = Math.PI / 2;\n  }\n\n  return gaussianEllipse;\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/common/ellipse.js","export default function withMulticlassTraining(\n  o,\n  trainingFunction,\n) {\n  return Object.assign(\n    o,\n    {\n      train(trainingSet, labels = undefined) {\n        if (!trainingSet || trainingSet.empty()) {\n          throw new Error('The training set is empty');\n        }\n        if (labels) {\n          labels.forEach((l) => {\n            if (!this.includes(l)) {\n              throw new Error(`Class labeled ${l} does not exist`);\n            }\n          });\n        }\n\n        this.params.classes = {};\n        const labs = labels || trainingSet.labels();\n        labs.forEach((label) => {\n          const ts = trainingSet.getPhrasesOfClass(label);\n          // console.log(ts);\n          this.params.classes[label] = trainingFunction(ts);\n        });\n        return this.params;\n      },\n    },\n  );\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/core/multiclass_training_mixin.js","import ModelBase from './core/model_base_mixin';\nimport withAbtractPrediction from './core/prediction_mixin';\nimport withGMMBase from './gmm/gmm_base_mixin';\nimport withGMMPrediction from './gmm/gmm_prediction_mixin';\nimport MulticlassModelbase from './core/multiclass_mixin';\nimport withMulticlassPrediction from './core/multiclass_prediction_mixin';\n\nexport function GMMPredictor(\n  params,\n  likelihoodWindow = undefined,\n) {\n  const model = withGMMPrediction(withAbtractPrediction(\n    withGMMBase(ModelBase(params)),\n    likelihoodWindow,\n  ));\n  model.allocate();\n  return model;\n}\n\nexport function multiclassGMMPredictor(\n  params,\n  likelihoodWindow = undefined,\n) {\n  const model = withMulticlassPrediction(MulticlassModelbase(params));\n  model.models = {};\n  Object.keys(params.classes).forEach((label) => {\n    model.models[label] = GMMPredictor(params.classes[label], likelihoodWindow);\n  });\n  model.reset();\n  return model;\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/predict.js","import { isBaseModel } from './model_base_mixin';\nimport CircularBuffer from '../common/circular_buffer';\n\nconst predictionBasePrototype = bimodal => ({\n  likelihoodBuffer: new CircularBuffer(1),\n\n  get likelihoodWindow() {\n    return this.likelihoodBuffer.capacity;\n  },\n\n  set likelihoodWindow(lw) {\n    this.likelihoodBuffer = new CircularBuffer(lw);\n  },\n\n  reset() {\n    this.likelihoodBuffer.clear();\n  },\n\n  predict(observation) {\n    const likelihood = this.likelihood(observation);\n    if (bimodal) {\n      this.regression(observation);\n    }\n    this.updateResults(likelihood);\n    return this.results;\n  },\n\n  updateResults(instantLikelihood) {\n    this.results.instantLikelihood = instantLikelihood;\n    this.likelihoodBuffer.push(Math.log(instantLikelihood));\n    this.results.logLikelihood = 0;\n    const bufSize = this.likelihoodBuffer.length;\n    for (let i = 0; i < bufSize; i += 1) {\n      this.results.logLikelihood += this.likelihoodBuffer.get(i);\n    }\n    this.results.logLikelihood /= bufSize;\n  },\n});\n\nexport default function withAbtractPrediction(o, likelihoodWindow = 1) {\n  if (!isBaseModel(o)) {\n    throw new Error('The base object must include a standard set of parameters (`params` key), @see `ModelBase`.');\n  }\n  const results = Object.assign(\n    { instantLikelihood: 0, logLikelihood: 0 },\n    o.params.bimodal ? { outputValues: [], outputCovariance: [] } : {},\n  );\n  return Object.assign(\n    o,\n    predictionBasePrototype(o.params.bimodal),\n    { results, likelihoodBuffer: new CircularBuffer(likelihoodWindow) },\n  );\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/core/prediction_mixin.js","const circularBufferPrototype = {\n  /**\n   * Clear the buffer contents\n   */\n  clear() {\n    /**\n     * Current buffer length\n     * @type {Number}\n     */\n    this.length = 0;\n    /**\n     * Current index\n     * @type {Number}\n     */\n    this.index = 0;\n    /**\n     * Specifies if the buffer is already full\n     * @type {Boolean}\n     */\n    this.full = false;\n    /**\n     * Buffer data\n     * @type {Array}\n     */\n    this.buffer = [];\n  },\n\n  /**\n   * Push a value to the buffer\n   * @param  {any} value data value (any type)\n   */\n  push(value) {\n    if (this.full) {\n      this.buffer[this.index] = value;\n      this.index = (this.index + 1) % this.capacity;\n    } else {\n      this.buffer.push(value);\n      this.length += 1;\n      this.full = (this.length === this.capacity);\n    }\n  },\n\n  /**\n   * Get the value at a given index\n   * @param  {number} idx data index\n   * @return {anything}   value at index\n   */\n  get(idx) {\n    return this.buffer[(idx + this.index) % this.capacity];\n  },\n\n  /**\n   * Fill the buffer with a constant value\n   * @param  {any} value data value (any type)\n   */\n  fill(value) {\n    this.length = this.capacity;\n    this.index = 0;\n    this.full = true;\n    this.buffer = Array(this.capacity).fill(value);\n  },\n\n  /**\n   * Iterate over the buffer's data\n   * @param  {Function} callback Callback function\n   * (@see Array.prototype.forEach).\n   */\n  forEach(callback) {\n    for (let i = 0; i < this.length; i += 1) {\n      callback(this.buffer[(i + this.index) % this.capacity], i);\n    }\n  },\n\n  /**\n   * Get an array of the buffer current values (ordered)\n   * @return {Array} Buffer contents\n   */\n  values() {\n    return this.buffer.slice(this.index)\n      .concat(this.buffer.slice(0, this.index));\n  },\n};\n\n/**\n * Circular Buffer Data Structure (any data type)\n * @param  {number} capacity Buffer capacity\n */\nexport default function CircularBuffer(capacity) {\n  const buffer = Object.assign(\n    Object.create(circularBufferPrototype),\n    {\n      capacity,\n    },\n  );\n  buffer.clear();\n  return buffer;\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/common/circular_buffer.js","import { isBaseModel } from '../core/model_base_mixin';\n\nconst singleGmmPredictionPrototype = {\n  allocate() {\n    this.beta = new Array(this.params.gaussians).fill(0);\n  },\n\n  likelihood(observation) {\n    let likelihood = 0;\n    for (let c = 0; c < this.params.gaussians; c += 1) {\n      this.beta[c] = this.componentLikelihood(observation, c);\n      likelihood += this.beta[c];\n    }\n    for (let c = 0; c < this.params.gaussians; c += 1) {\n      this.beta[c] /= likelihood;\n    }\n\n    return likelihood;\n  },\n\n  componentLikelihood(observation, mixtureComponent) {\n    if (mixtureComponent >= this.params.gaussians) {\n      throw new Error('The index of the Gaussian Mixture Component is out of bounds');\n    }\n    return this.params.mixtureCoeffs[mixtureComponent] *\n        this.params.components[mixtureComponent].likelihood(observation);\n  },\n};\n\nconst singleGmmBimodalPredictionPrototype = {\n  regression(inputObservation) {\n    this.results.outputValues = Array(this.params.outputDimension).fill(0);\n    this.results.outputCovariance = Array(this.covarianceMode === 'full' ? this.params.outputDimension ** 2 : this.params.outputDimension).fill(0);\n    let tmpOutputValues;\n\n    for (let c = 0; c < this.params.gaussians; c += 1) {\n      tmpOutputValues = this.params.components[c].regression(inputObservation);\n      for (let d = 0; d < this.params.outputDimension; d += 1) {\n        this.results.outputValues[d] += this.beta[c] * tmpOutputValues[d];\n        if (this.covarianceMode === 'full') {\n          for (let d2 = 0; d2 < this.params.outputDimension; d2 += 1) {\n            this.results.outputCovariance[(d * this.params.outputDimension) + d2] +=\n              (this.beta[c] ** 2) *\n              this.params.components[c].outputCovariance[(d * this.params.outputDimension) + d2];\n          }\n        } else {\n          this.results.outputCovariance[d] +=\n            (this.beta[c] ** 2) * this.params.components[c].outputCovariance[d];\n        }\n      }\n    }\n  },\n};\n\nexport default function withGMMPrediction(o) {\n  if (!isBaseModel(o)) {\n    throw new Error('The base object must include a standard set of parameters (`params` key), @see `ModelBase`.');\n  }\n  return Object.assign(\n    o,\n    singleGmmPredictionPrototype,\n    o.params.bimodal ? singleGmmBimodalPredictionPrototype : {},\n  );\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/gmm/gmm_prediction_mixin.js","import { isBaseModel } from './model_base_mixin';\n\nconst MulticlassPredictionBasePrototype = {\n  reset() {\n    Object.values(this.models).forEach(m => m.reset());\n    this.results = {\n      labels: [],\n      instantLikelihoods: [],\n      smoothedLikelihoods: [],\n      smoothedLogLikelihoods: [],\n      smoothedNormalizedLikelihoods: [],\n      likeliest: null,\n      classes: {},\n    };\n    if (this.params.bimodal) {\n      this.resetBimodal();\n    }\n  },\n\n  predict(observation) {\n    Object.values(this.models).forEach(m => m.predict(observation));\n    this.updateResults();\n  },\n\n  updateResults() {\n    const labs = Object.keys(this.models).sort();\n    this.results.labels = labs;\n    let normInstant = 0;\n    let normSmoothed = 0;\n    let maxLogLikelihood = -Infinity;\n    this.results.classes = labs\n      .map((lab, i) => {\n        this.results.instantLikelihoods[i] =\n          this.models[lab].results.instantLikelihood;\n        this.results.smoothedLogLikelihoods[i] =\n          this.models[lab].results.logLikelihood;\n        this.results.smoothedLikelihoods[i] =\n          Math.exp(this.results.smoothedLogLikelihoods[i]);\n        normInstant += this.results.instantLikelihoods[i];\n        normSmoothed += this.results.smoothedLikelihoods[i];\n        if (this.results.smoothedLogLikelihoods[i] > maxLogLikelihood) {\n          maxLogLikelihood = this.results.smoothedLogLikelihoods[i];\n          this.results.likeliest = lab;\n        }\n        return { [lab]: this.models[lab].results };\n      })\n      .reduce((o, x) => ({ ...o, ...x }), {});\n    this.results.smoothedNormalizedLikelihoods =\n      this.results.smoothedLikelihoods.map(x => x / normSmoothed);\n    this.results.instantNormalizedLikelihoods =\n      this.results.instantLikelihoods.map(x => x / normInstant);\n    if (this.params.bimodal) {\n      this.updateRegressionResults();\n    }\n  },\n};\n\nconst MulticlassPredictionBimodalPrototype = {\n  resetBimodal() {\n    this.results.outputValues = [];\n    this.results.outputCovariance = [];\n  },\n\n  updateRegressionResults() {\n    if (this.params.multiClassRegressionEstimator === 'likeliest') {\n      this.results.outputValues =\n        this.models[this.results.likeliest].results.outputValues;\n      this.results.outputCovariance =\n        this.models[this.results.likeliest].results.outputCovariance;\n    } else if (this.params.multiClassRegressionEstimator === 'mixture') {\n      this.results.outputValues = Array(this.outputDimension).fill(0);\n      this.results.outputCovariance = Array(this.outputDimension ** (this.configuration.covarianceMode === 'full' ? 2 : 1)).fill(0);\n      this.results.labels.forEach((lab) => {\n        this.results.outputValues.map((x, i) => x + (\n          this.results.smoothedNormalizedLikelihoods[i] *\n          this.models[lab].results.outputValues[i]\n        ));\n        this.results.outputCovariance.map((x, i) => x + (\n          this.results.smoothedNormalizedLikelihoods[i] *\n          this.models[lab].results.outputCovariance[i]\n        ));\n      });\n    } else {\n      throw new Error('Unknown regression estimator, use `likeliest` or `mixture`');\n    }\n  },\n};\n\nexport default function withMulticlassPrediction(o, multiClassRegressionEstimator = 'likeliest') {\n  if (!isBaseModel(o)) {\n    throw new Error('The base object must include a standard set of parameters (`params` key), @see `ModelBase`.');\n  }\n  const m = Object.assign(\n    o,\n    MulticlassPredictionBasePrototype,\n    o.params.bimodal ? MulticlassPredictionBimodalPrototype : {},\n  );\n  m.params.multiClassRegressionEstimator = multiClassRegressionEstimator;\n  return m;\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/core/multiclass_prediction_mixin.js"],"sourceRoot":""}