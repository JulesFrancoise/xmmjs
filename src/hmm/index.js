import ModelBase from '../core/model_base_mixin';
import withEMTraining from '../core/em_training_mixin';
import withHMMBase from './hmm_base_mixin';
import withHMMTraining from './hmm_training_mixin';
import MulticlassModelbase from '../core/multiclass_mixin';
import withMulticlassTraining from '../core/multiclass_training_mixin';
import withAbtractPrediction from '../core/prediction_mixin';
import withHMMPrediction from './hmm_prediction_mixin';
import withMulticlassPrediction from '../core/multiclass_prediction_mixin';

/**
 * @typedef {Object} HMMParameters
 * @property {Boolean} bimodal Specifies if the model is bimodal
 * @property {Number} inputDimension Dimension of the input modality
 * @property {Number} outputDimension Dimension of the output modality
 * @property {Number} dimension Total dimension
 * @property {Number} states Number of hidden states in the Markov model
 * @property {Number} gaussians Number of components in the Gaussian mixture
 * observation distribution of each state
 * @property {String} transitionMode Transition matrix mode ('ergodic' or 'leftright')
 * @property {String} covarianceMode Covariance mode ('full' or 'diagonal')
 * @property {Array<Number>} mixtureCoeffs mixture coefficients ('weight' of
 * each gaussian component)
 * @property {Array<GaussianDistribution>} components Gaussian components
 */

/**
 * Train a single-class HMM Model.
 *
 * @todo HMM details
 *
 * @param  {TrainingSet} trainingSet                training set
 * @param  {Object} configuration                   Training configuration
 * @param  {Object} [convergenceCriteria=undefined] Convergence criteria of the
 * EM algorithm
 * @return {HMMParameters} Parameters of the trained HMM
 */
export function trainHMM(
  trainingSet,
  configuration,
  convergenceCriteria = undefined,
) {
  const { inputDimension, outputDimension } = trainingSet;
  const {
    states,
    gaussians,
    regularization,
    transitionMode,
    covarianceMode,
  } = configuration;
  const model = withHMMTraining(
    withEMTraining(
      withHMMBase(ModelBase({
        inputDimension,
        outputDimension,
        ...configuration,
      })),
      convergenceCriteria,
    ),
    states,
    gaussians,
    regularization,
    transitionMode,
    covarianceMode,
  );
  return model.train(trainingSet);
}

/**
 * Train a multi-class HMM Model.
 *
 * @todo HMM details
 *
 * @param  {TrainingSet} trainingSet                training set
 * @param  {Object} configuration                   Training configuration
 * @param  {Object} [convergenceCriteria=undefined] Convergence criteria of the
 * EM algorithm
 * @return {Object} Parameters of the trained HMM
 */
export function trainMulticlassHMM(
  trainingSet,
  configuration,
  convergenceCriteria = undefined,
) {
  const { inputDimension, outputDimension } = trainingSet;
  const model = withMulticlassTraining(
    MulticlassModelbase({ inputDimension, outputDimension, ...configuration }),
    ts => trainHMM(ts, configuration, convergenceCriteria),
  );
  return model.train(trainingSet);
}

/**
 * Create a HMM Predictor from a full set of parameters (generated by trainHMM).
 * @param       {Object} params                       Model parameters
 * @param       {number} [likelihoodWindow=undefined] Likelihoow window size
 * @function
 */
export function HMMPredictor(
  params,
  likelihoodWindow = undefined,
) {
  const model = withHMMPrediction(withAbtractPrediction(
    withHMMBase(ModelBase(params)),
    likelihoodWindow,
  ));
  model.reset();
  return model;
}

/**
 * Create a Multiclass HMM Predictor from a full set of parameters
 * (generated by trainMulticlassHMM).
 * @param       {Object} params                       Model parameters
 * @param       {number} [likelihoodWindow=undefined] Likelihoow window size
 * @function
 */
export function multiclassHMMPredictor(
  params,
  likelihoodWindow = undefined,
) {
  const model = withMulticlassPrediction(MulticlassModelbase(params));
  model.models = {};
  Object.keys(params.classes).forEach((label) => {
    model.models[label] = HMMPredictor(params.classes[label], likelihoodWindow);
  });
  model.reset();
  return model;
}
