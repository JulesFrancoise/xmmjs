!function(t,s){"object"==typeof exports&&"object"==typeof module?module.exports=s():"function"==typeof define&&define.amd?define([],s):"object"==typeof exports?exports.xmm=s():t.xmm=s()}("undefined"!=typeof self?self:this,function(){return function(t){var s={};function i(a){if(s[a])return s[a].exports;var e=s[a]={i:a,l:!1,exports:{}};return t[a].call(e.exports,e,e.exports,i),e.l=!0,e.exports}return i.m=t,i.c=s,i.d=function(t,s,a){i.o(t,s)||Object.defineProperty(t,s,{configurable:!1,enumerable:!0,get:a})},i.n=function(t){var s=t&&t.__esModule?function(){return t.default}:function(){return t};return i.d(s,"a",s),s},i.o=function(t,s){return Object.prototype.hasOwnProperty.call(t,s)},i.p="",i(i.s=12)}([function(t,s,i){"use strict";s.a=function(t){let{inputDimension:s,outputDimension:i}=t;const e=function(t,s){var i={};for(var a in t)s.indexOf(a)>=0||Object.prototype.hasOwnProperty.call(t,a)&&(i[a]=t[a]);return i}(t,["inputDimension","outputDimension"]);return delete e.bimodal,delete e.inputDimension,delete e.outputDimension,delete e.dimension,{params:a({},e,{get bimodal(){return i>0},get inputDimension(){return s},get outputDimension(){return i},get dimension(){return s+i}})}},s.b=function(t){if(!Object.keys(t).includes("params"))return!1;return["bimodal","inputDimension","outputDimension","dimension"].map(s=>Object.keys(t.params).includes(s)).reduce((t,s)=>t&&s,!0)};var a=Object.assign||function(t){for(var s=1;s<arguments.length;s++){var i=arguments[s];for(var a in i)Object.prototype.hasOwnProperty.call(i,a)&&(t[a]=i[a])}return t}},function(t,s,i){"use strict";s.c=f,s.d=function(t,s,i){const{inputDimension:a,outputDimension:e}=t;return Object(l.a)(Object(h.a)(c({inputDimension:a,outputDimension:e},s)),t=>f(t,s,i)).train(t)},s.a=d,s.b=function(t,s){const i=Object(u.a)(Object(h.a)(t));return i.models={},Object.keys(t.classes).forEach(a=>{i.models[a]=d(t.classes[a],s)}),i.reset(),i};var a=i(4),e=i(0),r=i(5),n=i(6),o=i(17),h=i(7),l=i(8),m=i(9),p=i(19),u=i(11),c=Object.assign||function(t){for(var s=1;s<arguments.length;s++){var i=arguments[s];for(var a in i)Object.prototype.hasOwnProperty.call(i,a)&&(t[a]=i[a])}return t};function f(t,s,i){const{inputDimension:a,outputDimension:h}=t,{gaussians:l,regularization:m,covarianceMode:p}=s;return Object(o.a)(Object(r.a)(Object(n.a)(Object(e.a)(c({inputDimension:a,outputDimension:h},s))),i),l,m,p).train(t)}function d(t,s){const i=Object(p.a)(Object(m.a)(Object(n.a)(Object(e.a)(t)),s));return t.components.forEach((s,e)=>{i.params.components[e]=Object.assign(Object(a.a)(t.inputDimension,t.outputDimension,t.covarianceMode),s)}),i.reset(),i}},function(t,s,i){"use strict";s.a=n;var a=i(13),e=Object.assign||function(t){for(var s=1;s<arguments.length;s++){var i=arguments[s];for(var a in i)Object.prototype.hasOwnProperty.call(i,a)&&(t[a]=i[a])}return t};const r={size(){return Object.keys(this.phrases).length},empty(){return 0===this.length},getPhrase(t){return Object.keys(this.phrases).includes(t.toString())?this.phrases[t.toString()]:null},forEach(t){Object.keys(this.phrases).forEach(s=>{t(this.phrases[s],s,this.phrases)})},push(t,s,i){const e=void 0!==i?i:Object(a.a)({inputDimension:this.inputDimension,outputDimension:this.outputDimension,columnNames:this.columnNames,label:void 0!==s?s:t.toString()});return this.phrases[t]=e,e},remove(t){delete this.phrases[t]},removeClass(t){this.phrases=Object.keys(this.phrases).filter(s=>this.phrases[s].label!==t).map(t=>({i:this.phrases[t]})).reduce((t,s)=>e({},t,s),{})},clear(){this.phrases={}},getPhrasesOfClass(t){const s=n(this);return s.phrases=Object.keys(this.phrases).filter(s=>this.phrases[s].label===t).map(t=>({i:this.phrases[t]})).reduce((t,s)=>e({},t,s),{}),s},labels(){return Object.keys(this.phrases).map(t=>this.phrases[t].label).reduce((t,s)=>t.includes(s)?t:t.concat([s]),[])},indices(){return Object.keys(this.phrases)},mean(){const t=Array(this.dimension).fill(0);let s=0;return Object.keys(this.phrases).forEach(i=>{for(let s=0;s<this.dimension;s+=1)for(let a=0;a<this.phrases[i].length;a+=1)t[s]+=this.phrases[i].get(a,s);s+=this.phrases[i].length}),t.map(t=>t/s)},standardDeviation(){const t=Array(this.dimension).fill(0),s=this.mean();let i=0;return Object.keys(this.phrases).forEach(a=>{for(let i=0;i<this.dimension;i+=1)for(let e=0;e<this.phrases[a].length;e+=1)t[i]+=(this.phrases[a].get(e,i)-s[i])**2;i+=this.phrases[a].length}),t.map(t=>Math.sqrt(t/i))},minmax(){const t=Array.from(Array(this.dimension),()=>({min:1/0,max:-1/0}));return Object.keys(this.phrases).forEach(s=>{for(let i=0;i<this.dimension;i+=1)for(let a=0;a<this.phrases[s].length;a+=1)t[i].min+=Math.min(t[i].min,this.phrases[s].get(a,i)),t[i].max+=Math.max(t[i].max,this.phrases[s].get(a,i))}),t}};function n({inputDimension:t=1,outputDimension:s=0,columnNames:i=null}={}){const a=t+s;return Object.assign(Object.create(r),{bimodal:s>0,inputDimension:t,outputDimension:s,dimension:a,columnNames:i||Array(a).fill(""),phrases:{}})}},function(t,s,i){"use strict";s.a=function(t,s,i={}){if(!Object(a.b)(t))throw new Error("The base object must include a standard set of parameters (`params` key), @see `ModelBase`.");const e=Object.assign({initialization:"random",relativeDistanceThreshold:.001,minIterations:5,maxIterations:100},i),n=Object.assign(t,r,{trainingConfig:e});return n.params.clusters=s,n};var a=i(0),e=i(15);const r={train(t){if(!t||t.empty())throw new Error("The training set is empty");if(this.params.centers=Array.from(Array(this.params.clusters),()=>new Array(this.params.dimension).fill(0)),"random"===this.trainingConfig.initialization)this.initializeClustersRandom(t);else if("forgy"===this.trainingConfig.initialization)this.initializeClustersForgy(t);else{if("data"!==this.trainingConfig.initialization)throw new Error("Unknown K-Means initialization, must be `random`, `forgy` or `data`");this.initClustersWithFirstPhrase(t)}for(let s=0;s<this.trainingConfig.maxIterations;s+=1){const s=this.params.centers;this.updateCenters(s,t);let i=0,a=0;for(let t=0;t<this.params.clusters;t+=1){for(let s=0;s<this.params.clusters;s+=1)t!==s&&(i+=Object(e.a)(this.params.centers[t],this.params.centers[s]));a=Math.max(Object(e.a)(s[t],this.params.centers[t]),a)}if(i/=this.params.clusters*(this.params.clusters-1),a/=this.params.clusters,(a/=i)<this.trainingConfig.relativeDistanceThreshold)break}return this.params},initClustersWithFirstPhrase(t){const s=t.getPhrase(t.indices()[0]),i=Math.floor(s.length/this.params.clusters);let a=0;for(let t=0;t<this.params.clusters;t+=1){this.params.centers[t]=new Array(this.params.dimension).fill(0);for(let e=0;e<i;e+=1)for(let r=0;r<this.params.dimension;r+=1)this.params.centers[t][r]+=s.get(a+e,r)/i;a+=i}},initializeClustersRandom(t){const s=t.getPhrase(t.indices()[0]),i=Array.from(Array(s.length),()=>Math.floor(Math.random()*this.params.clusters)),a=i.reduce((t,s)=>{const i=t;return i[s]+=1,i},Array(this.params.clusters).fill(0));for(let t=0;t<i.length;t+=1){const a=i[t];for(let i=0;i<this.params.dimension;i+=1)this.params.centers[a][i]+=s.get(t,i)}this.params.centers.forEach((t,s)=>{this.params.centers[s]=this.params.centers[s].map(t=>t/a[s])})},initializeClustersForgy(t){const s=t.getPhrase(t.indices()[0]),i=Array.from(Array(this.params.clusters),()=>Math.floor(Math.random()*s.length));this.params.centers=i.map(t=>s.getFrame(t))},updateCenters(t,s){this.params.centers=Array.from(Array(this.params.clusters),()=>new Array(this.params.dimension).fill(0));const i=Array(this.params.clusters).fill(0);s.forEach(s=>{for(let a=0;a<s.length;a+=1){const r=s.getFrame(a);let n=Object(e.a)(r,t[0]),o=0;for(let s=1;s<this.params.clusters;s+=1){const i=Object(e.a)(r,t[s],this.params.dimension);i<n&&(o=s,n=i)}i[o]+=1;for(let t=0;t<this.params.dimension;t+=1)this.params.centers[o][t]+=s.get(a,t)}});for(let t=0;t<this.params.clusters;t+=1)if(i[t]>0)for(let s=0;s<this.params.dimension;s+=1)this.params.centers[t][s]/=i[t]}}},function(t,s,i){"use strict";s.a=function(t=1,s=0,i="full"){const a=s>0,n=t+s,o=a?Object.assign({},e,r):e,h=Object.assign({bimodal:a,dimension:n,inputDimension:t,outputDimension:s,covarianceMode:i,covarianceDeterminant:0},a?{covarianceDeterminantInput:0}:{}),l=Object.assign(Object.create(o),h);return l.allocate(),l};var a=i(16);const e={allocate(){this.mean=new Array(this.dimension).fill(0),"full"===this.covarianceMode?(this.covariance=new Array(this.dimension**2).fill(0),this.inverseCovariance=new Array(this.dimension**2).fill(0)):(this.covariance=new Array(this.dimension).fill(0),this.inverseCovariance=new Array(this.dimension).fill(0)),this.bimodal&&this.allocateBimodal()},likelihood(t){if(0===this.covarianceDeterminant)throw new Error("Covariance Matrix is not invertible");if(this.bimodal&&t.length===this.inputDimension)return this.inputLikelihood(t);if(t.length!==this.dimension)throw new Error(`GaussianDistribution: observation has wrong dimension. Expected \`${this.dimension}\`, got \`${t.length}\``);let s=0;if("full"===this.covarianceMode)for(let i=0;i<this.dimension;i+=1){let a=0;for(let s=0;s<this.dimension;s+=1)a+=this.inverseCovariance[i*this.dimension+s]*(t[s]-this.mean[s]);s+=(t[i]-this.mean[i])*a}else for(let i=0;i<this.dimension;i+=1)s+=this.inverseCovariance[i]*(t[i]-this.mean[i])*(t[i]-this.mean[i]);let i=Math.exp(-.5*s)/Math.sqrt(this.covarianceDeterminant*(2*Math.PI)**this.dimension);return(i<1e-180||Number.isNaN(i)||Math.abs(i)===1/0)&&(i=1e-180),i},regularize(t){if("full"===this.covarianceMode)for(let s=0;s<this.dimension;s+=1)this.covariance[s*this.dimension+s]+=t[s];else for(let s=0;s<this.dimension;s+=1)this.covariance[s]+=t[s]},updateInverseCovariance(){if("full"===this.covarianceMode){const t=Object(a.a)(this.dimension,this.dimension);t.data=this.covariance.slice();const s=t.pinv();this.covarianceDeterminant=s.determinant,this.inverseCovariance=s.matrix.data}else{this.covarianceDeterminant=1;for(let t=0;t<this.dimension;t+=1){if(this.covariance[t]<=0)throw new Error("Non-invertible matrix");this.inverseCovariance[t]=1/this.covariance[t],this.covarianceDeterminant*=this.covariance[t]}}this.bimodal&&this.updateInverseCovarianceBimodal()},toEllipse(t,s){if(t>=this.dimension||s>=this.dimension)throw new Error("dimensions out of range");const i={x:0,y:0,width:0,height:0,angle:0};let a,e,r;i.x=this.mean[t],i.y=this.mean[s],"full"===this.covarianceMode?(a=this.covariance[t*this.dimension+t],e=this.covariance[t*this.dimension+s],r=this.covariance[s*this.dimension+s]):(a=this.covariance[t],e=0,r=this.covariance[s]);const n=a+r,o=a*r-e*e,h=.5*(n+Math.sqrt(n**2-4*o)),l=.5*(n-Math.sqrt(n**2-4*o));return i.width=Math.sqrt(5.991*h),i.height=Math.sqrt(5.991*l),i.angle=Math.atan(e/(h-r)),Number.isNaN(i.angle)&&(i.angle=Math.PI/2),i},fromEllipse(t,s,i){if(s>=this.dimension||i>=this.dimension)throw new Error("dimensions out of range");this.mean[s]=t.x,this.mean[i]=t.y;const a=t.width*t.width/5.991,e=t.height*t.height/5.991,r=Math.tan(t.angle),n=(a-e)*r/(r**2+1),o=a-n/r,h=e+n/r;"full"===this.covarianceMode?(this.covariance[s*this.dimension+s]=h,this.covariance[s*this.dimension+i]=n,this.covariance[i*this.dimension+s]=n,this.covariance[i*this.dimension+i]=o):(this.covariance[s]=h,this.covariance[i]=o),this.updateInverseCovariance()}},r={allocateBimodal(){"full"===this.covarianceMode?this.inverseCovarianceInput=new Array(this.inputDimension**2).fill(0):this.inverseCovarianceInput=new Array(this.inputDimension).fill(0)},inputLikelihood(t){if(0===this.covarianceDeterminantInput)throw new Error("Covariance Matrix of input modality is not invertible");let s=0;if("full"===this.covarianceMode)for(let i=0;i<this.inputDimension;i+=1){let a=0;for(let s=0;s<this.inputDimension;s+=1)a+=this.inverseCovarianceInput[i*this.inputDimension+s]*(t[s]-this.mean[s]);s+=(t[i]-this.mean[i])*a}else for(let i=0;i<this.inputDimension;i+=1)s+=this.inverseCovariance[i]*(t[i]-this.mean[i])*(t[i]-this.mean[i]);let i=Math.exp(-.5*s)/Math.sqrt(this.covarianceDeterminantInput*(2*Math.PI)**this.inputDimension);return(i<1e-180||Number.isNaN(i)||Math.abs(i)===1/0)&&(i=1e-180),i},regression(t){const s=this.dimension-this.inputDimension,i=Array(s).fill(0);if("full"===this.covarianceMode)for(let a=0;a<s;a+=1){i[a]=this.mean[this.inputDimension+a];for(let s=0;s<this.inputDimension;s+=1){let e=0;for(let i=0;i<this.inputDimension;i+=1)e+=this.inverseCovarianceInput[s*this.inputDimension+i]*(t[i]-this.mean[i]);i[a]+=e*this.covariance[(a+this.inputDimension)*this.dimension+s]}}else for(let t=0;t<s;t+=1)i[t]=this.mean[this.inputDimension+t];return i},updateInverseCovarianceBimodal(){if("full"===this.covarianceMode){const t=Object(a.a)(this.inputDimension,this.inputDimension);for(let s=0;s<this.inputDimension;s+=1)for(let i=0;i<this.inputDimension;i+=1)t.data[s*this.inputDimension+i]=this.covariance[s*this.dimension+i];const s=t.pinv();this.covarianceDeterminantInput=s.determinant,this.inverseCovarianceInput=s.matrix.data}else{this.covarianceDeterminantInput=1;for(let t=0;t<this.inputDimension;t+=1){if(this.covariance[t]<=0)throw new Error("Non-invertible matrix");this.inverseCovarianceInput[t]=1/this.covariance[t],this.covarianceDeterminantInput*=this.covariance[t]}}this.updateOutputCovariance()},updateOutputCovariance(){if("diagonal"===this.covarianceMode)return void(this.outputCovariance=this.covariance.slice(0,this.inputDimension));const t=Object(a.a)(this.inputDimension,this.inputDimension);for(let s=0;s<this.inputDimension;s+=1)for(let i=0;i<this.inputDimension;i+=1)t.data[s*this.inputDimension+i]=this.covariance[s*this.dimension+i];const s=t.pinv(),i=Object(a.a)(this.inputDimension,this.outputDimension);for(let t=0;t<this.inputDimension;t+=1)for(let s=0;s<this.outputDimension;s+=1)i.data[t*this.outputDimension+s]=this.covariance[t*this.dimension+this.inputDimension+s];const e=Object(a.a)(this.outputDimension,this.inputDimension);for(let t=0;t<this.outputDimension;t+=1)for(let s=0;s<this.inputDimension;s+=1)e.data[t*this.inputDimension+s]=this.covariance[(this.inputDimension+t)*this.dimension+s];const r=s.matrix.product(i),n=e.product(r);this.outputCovariance=Array(this.outputDimension**2).fill(0);for(let t=0;t<this.outputDimension;t+=1)for(let s=0;s<this.outputDimension;s+=1)this.outputCovariance[t*this.outputDimension+s]=this.covariance[(this.inputDimension+t)*this.dimension+this.inputDimension+s]-n.data[t*this.outputDimension+s]}}},function(t,s,i){"use strict";s.a=function(t,s={percentChange:.001,minIterations:5,maxIterations:100}){return Object.assign(t,a,{convergenceCriteria:s})};const a={train(t){if(!t||t.empty())throw new Error("The training set is empty");this.initTraining(t);let s=-1/0,i=0,a=s;for(;!this.converged(i,s,a);){a=s,s=this.updateTraining(t);const e=100*Math.abs((s-a)/a);if(Number.isNaN(e)&&i>1)throw new Error("An error occured during training");i+=1}return this.terminateTraining(),this.params},converged(t,s,i){if(t>=this.convergenceCriteria.maxIterations)return!0;if(this.convergenceCriteria.maxIterations>=this.convergenceCriteria.minIterations)return t>=this.convergenceCriteria.maxIterations;if(t<this.convergenceCriteria.minIterations)return!1;return 100*Math.abs((s-i)/s)<=this.convergenceCriteria.percentChange}}},function(t,s,i){"use strict";s.a=function(t){if(!Object(a.b)(t))throw new Error("The base object must include a standard set of parameters (`params` key), @see `ModelBase`.");return Object.assign(t,r,t.params.bimodal?n:{})};var a=i(0),e=i(4);const r={allocate(){this.params.components=Array.from(Array(this.params.gaussians),()=>new e.a(this.params.inputDimension,this.params.outputDimension,this.params.covarianceMode)),this.params.mixtureCoeffs=Array(this.params.gaussians).fill(0),this.beta=new Array(this.params.gaussians).fill(0)},likelihood(t){let s=0;for(let i=0;i<this.params.gaussians;i+=1)this.beta[i]=this.componentLikelihood(t,i),s+=this.beta[i];for(let t=0;t<this.params.gaussians;t+=1)this.beta[t]/=s;return s},componentLikelihood(t,s){if(s>=this.params.gaussians)throw new Error("The index of the Gaussian Mixture Component is out of bounds");return this.params.mixtureCoeffs[s]*this.params.components[s].likelihood(t)},updateInverseCovariances(){this.params.components.forEach(t=>{t.updateInverseCovariance()});try{this.params.components.forEach(t=>{t.updateInverseCovariance()})}catch(t){throw new Error("Matrix inversion error: varianceoffset must be too small")}},normalizeMixtureCoeffs(){let t=0;for(let s=0;s<this.params.gaussians;s+=1)t+=this.params.mixtureCoeffs[s];if(t>0)for(let s=0;s<this.params.gaussians;s+=1)this.params.mixtureCoeffs[s]/=t;else for(let t=0;t<this.params.gaussians;t+=1)this.params.mixtureCoeffs[t]=1/this.params.gaussians},regularize(){this.params.components.forEach(t=>{t.regularize(this.currentRegularization)})}},n={regression(t){let s;this.results.outputValues=Array(this.params.outputDimension).fill(0),this.results.outputCovariance=Array("full"===this.params.covarianceMode?this.params.outputDimension**2:this.params.outputDimension).fill(0);for(let i=0;i<this.params.gaussians;i+=1){s=this.params.components[i].regression(t);for(let t=0;t<this.params.outputDimension;t+=1)if(this.results.outputValues[t]+=this.beta[i]*s[t],"full"===this.params.covarianceMode)for(let s=0;s<this.params.outputDimension;s+=1)this.results.outputCovariance[t*this.params.outputDimension+s]+=this.beta[i]**2*this.params.components[i].outputCovariance[t*this.params.outputDimension+s];else this.results.outputCovariance[t]+=this.beta[i]**2*this.params.components[i].outputCovariance[t]}return this.results.outputValues}}},function(t,s,i){"use strict";s.a=function(t){let{inputDimension:s,outputDimension:i}=t,n=function(t,s){var i={};for(var a in t)s.indexOf(a)>=0||Object.prototype.hasOwnProperty.call(t,a)&&(i[a]=t[a]);return i}(t,["inputDimension","outputDimension"]);return Object.assign(Object(a.a)(e({inputDimension:s,outputDimension:i},n)),r)};var a=i(0),e=Object.assign||function(t){for(var s=1;s<arguments.length;s++){var i=arguments[s];for(var a in i)Object.prototype.hasOwnProperty.call(i,a)&&(t[a]=i[a])}return t};const r={size(){return Object.keys(this.models).length},includes(t){return Object.keys(this.models).includes(t)},remove(t){this.includes(t)&&delete this.models[t]}}},function(t,s,i){"use strict";s.a=function(t,s){return Object.assign(t,{train(t,i){if(!t||t.empty())throw new Error("The training set is empty");i&&i.forEach(t=>{if(!this.includes(t))throw new Error(`Class labeled ${t} does not exist`)}),this.params.classes={};const a=i||t.labels();return a.forEach(i=>{const a=t.getPhrasesOfClass(i);this.params.classes[i]=s(a)}),this.params}})}},function(t,s,i){"use strict";s.a=function(t,s=1){if(!Object(a.b)(t))throw new Error("The base object must include a standard set of parameters (`params` key), @see `ModelBase`.");const i=Object.assign({instantLikelihood:0,logLikelihood:0},t.params.bimodal?{outputValues:[],outputCovariance:[]}:{});return Object.assign(t,r(t.params.bimodal),{results:i,likelihoodBuffer:Object(e.a)(s)})};var a=i(0),e=i(18);const r=t=>({likelihoodBuffer:Object(e.a)(1),setLikelihoodWindow(t){this.likelihoodWindow=t,this.likelihoodBuffer=Object(e.a)(t)},reset(){return this.likelihoodBuffer.clear(),this},predict(s){const i=this.likelihood(s);return t&&this.regression(s),this.updateResults(i),this.results},updateResults(t){this.results.instantLikelihood=t,this.likelihoodBuffer.push(Math.log(t)),this.results.logLikelihood=0;const s=this.likelihoodBuffer.length;for(let t=0;t<s;t+=1)this.results.logLikelihood+=this.likelihoodBuffer.get(t);this.results.logLikelihood/=s}})},function(t,s,i){"use strict";s.a=function(t,s,i){const a=Object.assign({},i);return Object.keys(s).forEach(e=>{const r=s[e];if(r.required&&!Object.keys(i).includes(e))throw new Error(`Stream parameter '${e}' is required for model '${t}'.`);!function(t,s,i,a){if(i){if(i.constructor===Array&&!i.includes(a))throw new Error(`Attribute '${s}' (value: '${a}') is not allowed for model '${t}' (options: [${i}]).`);if(i.constructor===Object){if(Object.keys(i).includes("min")&&a<i.min)throw new Error(`Attribute '${s}' (value: ${a}) is inferior to the minimum required value of ${i.min} for model '${t}'.`);if(Object.keys(i).includes("max")&&a>i.max)throw new Error(`Attribute '${s}' (value: ${a}) is superior to the maximum required value of ${i.min} for model '${t}'.`)}else if("function"==typeof i&&!i(a))throw new Error(`Attribute '${s}' (value: ${a}) is incompatible with model '${t}'.`)}}(t,e,r.check,i[e]),a[e]=r.transform?r.transform(i[e]):i[e]}),a}},function(t,s,i){"use strict";s.a=function(t,s="likeliest"){if(!Object(a.b)(t))throw new Error("The base object must include a standard set of parameters (`params` key), @see `ModelBase`.");const i=Object.assign(t,r,t.params.bimodal?n:{});return i.params.multiClassRegressionEstimator=s,i};var a=i(0),e=Object.assign||function(t){for(var s=1;s<arguments.length;s++){var i=arguments[s];for(var a in i)Object.prototype.hasOwnProperty.call(i,a)&&(t[a]=i[a])}return t};const r={getLikelihoodWindow(){return this.likelihoodWindow},setLikelihoodWindow(t){this.likelihoodWindow=t,Object.keys(this.models).forEach(s=>{this.models[s].setLikelihoodWindow(t)})},reset(){Object.values(this.models).forEach(t=>t.reset()),this.results={labels:[],instantLikelihoods:[],smoothedLikelihoods:[],smoothedLogLikelihoods:[],smoothedNormalizedLikelihoods:[],likeliest:null,classes:{}},this.params.bimodal&&this.resetBimodal()},predict(t){Object.values(this.models).forEach(s=>s.predict(t)),this.updateResults()},updateResults(){const t=Object.keys(this.models).sort();this.results.labels=t;let s=0,i=0,a=-1/0;this.results.classes=t.map((t,e)=>(this.results.instantLikelihoods[e]=this.models[t].results.instantLikelihood,this.results.smoothedLogLikelihoods[e]=this.models[t].results.logLikelihood,this.results.smoothedLikelihoods[e]=Math.exp(this.results.smoothedLogLikelihoods[e]),s+=this.results.instantLikelihoods[e],i+=this.results.smoothedLikelihoods[e],this.results.smoothedLogLikelihoods[e]>a&&(a=this.results.smoothedLogLikelihoods[e],this.results.likeliest=t),{[t]:this.models[t].results})).reduce((t,s)=>e({},t,s),{}),this.results.smoothedNormalizedLikelihoods=this.results.smoothedLikelihoods.map(t=>t/i),this.results.instantNormalizedLikelihoods=this.results.instantLikelihoods.map(t=>t/s),this.params.bimodal&&this.updateRegressionResults()}},n={resetBimodal(){this.results.outputValues=[],this.results.outputCovariance=[]},updateRegressionResults(){if("likeliest"===this.params.multiClassRegressionEstimator)this.results.outputValues=this.models[this.results.likeliest].results.outputValues,this.results.outputCovariance=this.models[this.results.likeliest].results.outputCovariance;else{if("mixture"!==this.params.multiClassRegressionEstimator)throw new Error("Unknown regression estimator, use `likeliest` or `mixture`");this.results.outputValues=Array(this.outputDimension).fill(0),this.results.outputCovariance=Array(this.outputDimension**("full"===this.configuration.covarianceMode?2:1)).fill(0),this.results.labels.forEach(t=>{this.results.outputValues.map((s,i)=>s+this.results.smoothedNormalizedLikelihoods[i]*this.models[t].results.outputValues[i]),this.results.outputCovariance.map((s,i)=>s+this.results.smoothedNormalizedLikelihoods[i]*this.models[t].results.outputCovariance[i])})}}}},function(t,s,i){"use strict";Object.defineProperty(s,"__esModule",{value:!0});var a=i(2);i.d(s,"TrainingSet",function(){return a.a});var e=i(14);i.d(s,"trainKmeans",function(){return e.a});var r=i(1);i.d(s,"trainGMM",function(){return r.c}),i.d(s,"trainMulticlassGMM",function(){return r.d}),i.d(s,"GMMPredictor",function(){return r.a}),i.d(s,"MulticlassGMMPredictor",function(){return r.b});var n=i(20);i.d(s,"trainHMM",function(){return n.d}),i.d(s,"trainMulticlassHMM",function(){return n.e}),i.d(s,"HMMPredictor",function(){return n.a}),i.d(s,"MulticlassHMMPredictor",function(){return n.c}),i.d(s,"HierarchicalHMMPredictor",function(){return n.b})},function(t,s,i){"use strict";s.a=function({inputDimension:t=1,outputDimension:s=0,columnNames:i=null,label:e=""}={}){const r=t+s;return Object.assign(Object.create(a),{bimodal:s>0,inputDimension:t,outputDimension:s,dimension:r,length:0,label:e,inputData:[],outputData:[],columnNames:i||Array(r).fill("")})};const a={get(t,s){if("number"!=typeof t||Math.floor(t)!==t)throw new Error("The index must be an integer");if(s>=this.dimension)throw new Error("Phrase: dimension out of bounds");if(this.bimodal){if(s<this.inputDimension){if(t>=this.inputData.length)throw new Error("Phrase: index out of bounds");return this.inputData[t][s]}if(t>=this.outputData.length)throw new Error("Phrase: index out of bounds");return this.outputData[t][s-this.inputDimension]}if(t>=this.length)throw new Error("Phrase: index out of bounds");if(!this.inputData[t])throw new Error("WTF?");return this.inputData[t][s]},getFrame(t){if(t>=this.length)throw new Error("Phrase: index out of bounds");return this.bimodal?this.inputData[t].concat(this.outputData[t]):this.inputData[t]},push(t){if(t.length!==this.dimension)throw new Error("Observation has wrong dimension");this.bimodal?(this.inputData.push(t.slice(0,this.inputDimension)),this.outputData.push(t.slice(this.inputDimension,this.dimension))):this.inputData.push(t),this.length+=1},pushInput(t){if(!this.bimodal)throw new Error("this phrase is unimodal, use `push`");if(t.size()!==this.inputDimension)throw new Error("Observation has wrong dimension");this.inputData.push(t),this.trim()},pushOutput(t){if(!this.bimodal)throw new Error("this phrase is unimodal, use `push`");if(t.size()!==this.outputDimension)throw new Error("Observation has wrong dimension");this.outputData.push(t),this.trim()},clear(){this.length=0,this.inputData=[],this.outputData=[]},clearInput(){this.inputData=[],this.trim()},clearOutput(){this.outputData=[],this.trim()},mean(){const t=Array(this.dimension).fill(0);for(let s=0;s<this.dimension;s+=1){for(let i=0;i<this.length;i+=1)t[s]+=this.get(i,s);t[s]/=this.length}return t},standardDeviation(){const t=Array(this.dimension).fill(0),s=this.mean();for(let i=0;i<this.dimension;i+=1){for(let a=0;a<this.length;a+=1)t[i]+=(this.get(a,i)-s[i])*(this.get(a,i)-s[i]);t[i]/=this.length,t[i]=Math.sqrt(t[i])}return t},minmax(){const t=Array.from(Array(this.dimension),()=>({min:1/0,max:-1/0}));for(let s=0;s<this.dimension;s+=1)for(let i=0;i<this.length;i+=1)t[s].min=Math.min(this.get(i,s),t[s].min),t[s].max=Math.max(this.get(i,s),t[s].max);return t},trim(){this.bimodal&&(this.length=Math.min(this.inputData.length,this.outputData.length))}}},function(t,s,i){"use strict";s.a=function(t,s,i){const{inputDimension:r,outputDimension:n}=t;return Object(e.a)(Object(a.a)({inputDimension:r,outputDimension:n}),s,i).train(t)};var a=i(0),e=i(3)},function(t,s,i){"use strict";s.a=function(t,s){return Math.sqrt(t.map((t,i)=>(t-s[i])**2).reduce((t,s)=>t+s,0))}},function(t,s,i){"use strict";s.a=e;const a={sum(){return this.data.reduce((t,s)=>t+s,0)},transpose(){const t=e(this.ncols,this.nrows);for(let s=0;s<this.ncols;s+=1)for(let i=0;i<this.nrows;i+=1)t.data[s*this.nrows+i]=this.data[i*this.ncols+s];return t},product(t){if(this.ncols!==t.nrows)throw new Error("Wrong dimensions for matrix product");const s=e(this.nrows,t.ncols);for(let i=0;i<this.nrows;i+=1)for(let a=0;a<t.ncols;a+=1){s.data[i*t.ncols+a]=0;for(let e=0;e<this.ncols;e+=1)s.data[i*t.ncols+a]+=this.data[i*this.ncols+e]*t.data[e*t.ncols+a]}return s},pinv(){if(this.nrows===this.ncols)return this.gaussJordanInverse();const t=this.transpose();if(this.nrows>=this.ncols){const s=t.product(this),{determinant:i,matrix:a}=s.gaussJordanInverse();return{determinant:i,matrix:a.product(t)}}const s=this.product(t),{determinant:i,matrix:a}=s.gaussJordanInverse();return{determinant:i,matrix:t.product(a)}},gaussJordanInverse(){if(this.nrows!==this.ncols)throw new Error("Gauss-Jordan inversion: Cannot invert Non-square matrix");let t=1;const s=e(this.nrows,2*this.ncols),i=e(this.nrows,2*this.ncols),a=this.nrows;for(let t=0;t<a;t+=1){for(let i=0;i<a;i+=1)s.data[2*t*a+i]=this.data[t*a+i];s.data[2*t*a+a+t]=1}for(let e=0;e<a;e+=1){let r=e;for(;Math.abs(s.data[2*r*a+e])<1e-9;)if((r+=1)===a)throw new Error("Non-invertible matrix");t*=s.data[2*r*a+e],r!==e&&s.swapLines(r,e),i.data=s.data.slice();for(let t=0;t<2*a;t+=1)i.data[2*e*a+t]/=s.data[2*e*a+e];for(let t=0;t<a;t+=1)if(t!==e)for(let r=0;r<2*a;r+=1)i.data[2*t*a+r]-=s.data[2*t*a+e]*i.data[2*e*a+r];s.data=i.data.slice()}const r=e(this.nrows,this.ncols);for(let t=0;t<a;t+=1)for(let i=0;i<a;i+=1)r.data[t*a+i]=s.data[2*t*a+a+i];return{determinant:t,matrix:r}},swapLines(t,s){for(let i=0;i<this.ncols;i+=1){const a=this.data[t*this.ncols+i];this.data[t*this.ncols+i]=this.data[s*this.ncols+i],this.data[s*this.ncols+i]=a}},swapColumns(t,s){for(let i=0;i<this.nrows;i+=1){const a=this.data[i*this.ncols+t];this.data[i*this.ncols+t]=this.data[i*this.ncols+s],this.data[i*this.ncols+s]=a}}};function e(t=0,s=-1){const i=s<0?t:s;return Object.assign(Object.create(a),{nrows:t,ncols:i,data:Array(t*i).fill(0)})}},function(t,s,i){"use strict";s.a=function(t,s=1,i={absolute:.001,relative:.01},a="full"){if(!Object.keys(t).includes("params"))throw new Error("The base object must include a standard set of parameters (`params` key), @see `ModelBase`.");return Object.assign(t,n,{params:r({},t.params,{gaussians:s,regularization:i,covarianceMode:a})})};var a=i(0),e=i(3),r=Object.assign||function(t){for(var s=1;s<arguments.length;s++){var i=arguments[s];for(var a in i)Object.prototype.hasOwnProperty.call(i,a)&&(t[a]=i[a])}return t};const n={initTraining(t){this.allocate(),this.initParametersToDefault(t.standardDeviation()),this.initMeansWithKMeans(t),this.initCovariances(t),this.regularize(),this.updateInverseCovariances()},initParametersToDefault(t){let s=0;this.currentRegularization=t.map(t=>Math.max(this.params.regularization.absolute,this.params.regularization.relative*t));for(let t=0;t<this.params.gaussians;t+=1)"full"===this.params.covarianceMode?this.params.components[t].covariance=Array(this.params.dimension**2).fill(this.params.regularization.absolute/2):this.params.components[t].covariance=Array(this.params.dimension).fill(0),this.params.components[t].regularize(this.currentRegularization),this.params.mixtureCoeffs[t]=1/this.params.gaussians,s+=this.params.mixtureCoeffs[t];for(let t=0;t<this.params.gaussians;t+=1)this.params.mixtureCoeffs[t]/=s},initMeansWithKMeans(t){if(!t||t.empty())return;const s=Object(e.a)(Object(a.a)({inputDimension:this.params.inputDimension,outputDimension:this.params.outputDimension}),this.params.gaussians,{initialization:"data"}).train(t);for(let t=0;t<this.params.gaussians;t+=1)this.params.components[t].mean=s.centers[t]},initCovariances(t){if(!t||t.empty())return;for(let t=0;t<this.params.gaussians;t+=1)this.params.components[t].covariance=Array("full"===this.params.covarianceMode?this.params.dimension**2:this.params.dimension).fill(0);const s=Array(this.params.gaussians*this.params.dimension).fill(0),i=Array(this.params.gaussians).fill(0);t.forEach(t=>{const a=Math.floor(t.length/this.params.gaussians);let e=0;for(let r=0;r<this.params.gaussians;r+=1){for(let i=0;i<a;i+=1)for(let a=0;a<this.params.dimension;a+=1)if(s[r*this.params.dimension+a]+=t.get(e+i,a),"full"===this.params.covarianceMode)for(let s=0;s<this.params.dimension;s+=1)this.params.components[r].covariance[a*this.params.dimension+s]+=t.get(e+i,a)*t.get(e+i,s);else this.params.components[r].covariance[a]+=t.get(e+i,a)**2;e+=a,i[r]+=a}});for(let t=0;t<this.params.gaussians;t+=1)for(let a=0;a<this.params.dimension;a+=1)if(s[t*this.params.dimension+a]/=i[t],"full"===this.params.covarianceMode)for(let s=0;s<this.params.dimension;s+=1)this.params.components[t].covariance[a*this.params.dimension+s]/=i[t];else this.params.components[t].covariance[a]/=i[t];for(let t=0;t<this.params.gaussians;t+=1)for(let i=0;i<this.params.dimension;i+=1)if("full"===this.params.covarianceMode)for(let a=0;a<this.params.dimension;a+=1)this.params.components[t].covariance[i*this.params.dimension+a]-=s[t*this.params.dimension+i]*s[t*this.params.dimension+a];else this.params.components[t].covariance[i]-=s[t*this.params.dimension+i]**2},updateTraining(t){let s=0,i=0;t.forEach(t=>{i+=t.length});const a=Object.keys(t.phrases),e=Array.from(Array(this.params.gaussians),()=>new Array(i).fill(0)),r=Array(this.params.gaussians).fill(0);let n=0;t.forEach(t=>{for(let i=0;i<t.length;i+=1){let a=0;for(let s=0;s<this.params.gaussians;s+=1)e[s][n+i]=this.componentLikelihood(t.getFrame(i),s),(0===e[s][n+i]||Number.isNaN(e[s][n+i])||e[s][n+i]===1/0)&&(e[s][n+i]=1e-100),a+=e[s][n+i];for(let t=0;t<this.params.gaussians;t+=1)e[t][n+i]/=a,r[t]+=e[t][n+i];s+=Math.log(a)}n+=t.length});for(let t=0;t<this.params.gaussians;t+=1)this.params.mixtureCoeffs[t]=r[t]/i;for(let s=0;s<this.params.gaussians;s+=1)for(let i=0;i<this.params.dimension;i+=1){this.params.components[s].mean[i]=0,n=0;for(let r=0;r<a.length;r+=1){const o=t.phrases[a[r]];for(let t=0;t<o.length;t+=1)this.params.components[s].mean[i]+=e[s][n+t]*o.get(t,i);n+=o.length}this.params.components[s].mean[i]/=r[s]}if("full"===this.params.covarianceMode)for(let s=0;s<this.params.gaussians;s+=1)for(let i=0;i<this.params.dimension;i+=1)for(let o=i;o<this.params.dimension;o+=1){this.params.components[s].covariance[i*this.params.dimension+o]=0,n=0;for(let r=0;r<a.length;r+=1){const h=t.phrases[a[r]];for(let t=0;t<h.length;t+=1)this.params.components[s].covariance[i*this.params.dimension+o]+=e[s][n+t]*(h.get(t,i)-this.params.components[s].mean[i])*(h.get(t,o)-this.params.components[s].mean[o]);n+=h.length}this.params.components[s].covariance[i*this.params.dimension+o]/=r[s],i!==o&&(this.params.components[s].covariance[o*this.params.dimension+i]=this.params.components[s].covariance[i*this.params.dimension+o])}else for(let s=0;s<this.params.gaussians;s+=1)for(let i=0;i<this.params.dimension;i+=1){this.params.components[s].covariance[i]=0,n=0;for(let r=0;r<a.length;r+=1){const o=t.phrases[a[r]];for(let t=0;t<o.length;t+=1){const a=o.get(t,i)-this.params.components[s].mean[i];this.params.components[s].covariance[i]+=e[s][n+t]*a*a}n+=o.length}this.params.components[s].covariance[i]/=r[s]}return this.regularize(),this.updateInverseCovariances(),s},terminateTraining(){}}},function(t,s,i){"use strict";s.a=function(t){const s=Object.create(a);return s.capacity=t,s.clear(),s};const a={clear(){this.length=0,this.index=0,this.full=!1,this.buffer=[]},push(t){this.full?(this.buffer[this.index]=t,this.index=(this.index+1)%this.capacity):(this.buffer.push(t),this.length+=1,this.full=this.length===this.capacity)},get(t){return this.buffer[(t+this.index)%this.capacity]},fill(t){this.length=this.capacity,this.index=0,this.full=!0,this.buffer=Array(this.capacity).fill(t)},forEach(t){for(let s=0;s<this.length;s+=1)t(this.buffer[(s+this.index)%this.capacity],s)},values(){return this.buffer.slice(this.index).concat(this.buffer.slice(0,this.index))}}},function(t,s,i){"use strict";s.a=function(t){if(!Object(e.b)(t))throw new Error("The base object must include a standard set of parameters (`params` key), @see `ModelBase`.");return Object(a.a)("GMM",r(t.params.gaussians),t.params),Object.assign(t,{beta:new Array(t.params.gaussians).fill(0)})};var a=i(10),e=i(0);const r=t=>({gaussians:{required:!0,check:{min:1}},regularization:{required:!0,check:({absolute:t,relative:s})=>t&&s&&t>0&&s>0},covarianceMode:{required:!0,check:["full","diagonal"]},mixtureCoeffs:{required:!0,check:s=>s.length===t},components:{required:!0,check:s=>s.length===t}})},function(t,s,i){"use strict";s.d=f,s.e=function(t,s,i){const{inputDimension:a,outputDimension:e}=t;return Object(h.a)(Object(o.a)(c({inputDimension:a,outputDimension:e},s)),t=>f(t,s,i)).train(t)},s.a=d,s.c=function(t,s){const i=Object(p.a)(Object(o.a)(t));return i.models={},Object.keys(t.classes).forEach(a=>{i.models[a]=d(t.classes[a],s)}),i.reset(),i},s.b=function(t,s){let i=Object(o.a)(t);return i.models={},Object.keys(t.classes).forEach(a=>{i.models[a]=d(t.classes[a],s)}),(i=Object(u.a)(Object(p.a)(i))).reset(),i};var a=i(0),e=i(5),r=i(21),n=i(22),o=i(7),h=i(8),l=i(9),m=i(23),p=i(11),u=i(24),c=Object.assign||function(t){for(var s=1;s<arguments.length;s++){var i=arguments[s];for(var a in i)Object.prototype.hasOwnProperty.call(i,a)&&(t[a]=i[a])}return t};function f(t,s,i){const{inputDimension:o,outputDimension:h}=t,{states:l,gaussians:m,regularization:p,transitionMode:u,covarianceMode:f}=s;return Object(n.a)(Object(e.a)(Object(r.a)(Object(a.a)(c({inputDimension:o,outputDimension:h},s))),i),l,m,p,u,f).train(t)}function d(t,s){const i=Object(m.a)(Object(l.a)(Object(r.a)(Object(a.a)(t)),s));return i.reset(),i}},function(t,s,i){"use strict";s.a=function(t){if(!Object(a.b)(t))throw new Error("The base object must include a standard set of parameters (`params` key), @see `ModelBase`.");return Object.assign(t,e)};var a=i(0);const e={forwardInitialized:!1,isHierarchical:!1,initializeForwardAlgorithm(t){let s=0;if("ergodic"===this.params.transitionMode)for(let i=0;i<this.params.states;i+=1)this.alpha[i]=this.params.prior[i]*this.params.xStates[i].likelihood(t),s+=this.alpha[i];else this.alpha=new Array(this.params.states).fill(0),this.alpha[0]=this.params.xStates[0].likelihood(t),s+=this.alpha[0];if(this.forwardInitialized=!0,s>0){for(let t=0;t<this.params.states;t+=1)this.alpha[t]/=s;return 1/s}for(let t=0;t<this.params.states;t+=1)this.alpha[t]=1/this.params.states;return 1},updateForwardAlgorithm(t){let s=0;this.previousAlpha=this.alpha.slice();for(let i=0;i<this.params.states;i+=1){if(this.alpha[i]=0,"ergodic"===this.params.transitionMode)for(let t=0;t<this.params.states;t+=1)this.alpha[i]+=this.previousAlpha[t]*this.params.transition[t][i];else this.alpha[i]+=this.previousAlpha[i]*this.params.transition[2*i],i>0?this.alpha[i]+=this.previousAlpha[i-1]*this.params.transition[2*(i-1)+1]:this.alpha[0]+=this.previousAlpha[this.params.states-1]*this.params.transition[2*this.params.states-1];this.alpha[i]*=this.params.xStates[i].likelihood(t),s+=this.alpha[i]}if(s>1e-300){for(let t=0;t<this.params.states;t+=1)this.alpha[t]/=s;return 1/s}return 0}}},function(t,s,i){"use strict";s.a=function(t,s=1,i=1,a={absolute:.001,relative:.01},e="leftright",r="full"){if(!Object.keys(t).includes("params"))throw new Error("The base object must include a standard set of parameters (`params` key), @see `ModelBase`.");return Object.assign(t,h,{params:o({},t.params,{states:s,gaussians:i,regularization:a,transitionMode:e,covarianceMode:r})})};var a=i(2),e=i(0),r=i(6),n=i(1),o=Object.assign||function(t){for(var s=1;s<arguments.length;s++){var i=arguments[s];for(var a in i)Object.prototype.hasOwnProperty.call(i,a)&&(t[a]=i[a])}return t};const h={initTraining(t){t&&!t.empty()&&(this.allocate(t),this.initParametersToDefault(t.standardDeviation()),this.params.gaussians>1?this.initMeansCovariancesWithGMMEM(t):(this.initMeansWithAllPhrases(t),this.initCovariancesFullyObserved(t)))},allocate(t){const{inputDimension:s,outputDimension:i,gaussians:a,regularization:n,covarianceMode:o}=this.params;this.params.xStates=Array.from(new Array(this.params.states),()=>Object(r.a)(Object(e.a)({inputDimension:s,outputDimension:i,gaussians:a,regularization:n,covarianceMode:o}))),this.params.xStates.forEach(t=>t.allocate()),this.alpha=new Array(this.params.states).fill(0),this.previousAlpha=new Array(this.params.states).fill(0),this.beta=new Array(this.params.states).fill(0),this.previousBeta=new Array(this.params.states).fill(0);const h=t.size();this.gammaSequence=new Array(h).fill(null),this.epsilonSequence=new Array(h).fill(null),this.gammaSequenceperMixture=new Array(h).fill(null);let l=0,m=0;t.forEach(t=>{const s=t.length;this.gammaSequence[m]=Array.from(new Array(s),()=>new Array(this.params.states).fill(0)),"ergodic"===this.params.transitionMode?this.epsilonSequence[m]=Array.from(new Array(s),()=>Array.from(new Array(this.params.states),()=>new Array(this.params.states).fill(0))):this.epsilonSequence[m]=Array.from(new Array(s),()=>new Array(2*this.params.states).fill(0)),this.gammaSequenceperMixture[m]=new Array(this.params.gaussians).fill(0);for(let t=0;t<this.params.gaussians;t+=1)this.gammaSequenceperMixture[m][t]=Array.from(new Array(s),()=>new Array(this.params.states).fill(0));s>l&&(l=s),m+=1}),this.gammaSum=new Array(this.params.states).fill(0),this.gammaSumPerMixture=new Array(this.params.states*this.params.gaussians).fill(0)},updateTraining(t){let s=0,i=0;t.forEach(t=>{t.length>0&&(s+=this.baumWelchForwardBackward(t,i)),i+=1}),this.baumWelchGammaSum(t);for(let t=0;t<this.params.states;t+=1)for(let s=0;s<this.params.gaussians;s+=1)this.params.xStates[t].params.mixtureCoeffs[s]=0,"full"===this.params.covarianceMode?this.params.xStates[t].params.components[s].covariance=new Array(this.params.dimension**2).fill(0):this.params.xStates[t].params.components[s].covariance=new Array(this.params.dimension).fill(0);return this.baumWelchEstimateMixtureCoefficients(t),this.baumWelchEstimateMeans(t),this.baumWelchEstimateCovariances(t),"ergodic"===this.params.transitionMode&&this.baumWelchEstimatePrior(t),this.baumWelchEstimateTransitions(t),s},terminateTraining(){this.normalizeTransitions(),this.gammaSequence=null,this.epsilonSequence=null,this.gammaSequenceperMixture=null,this.alphaSeq=null,this.betaSeq=null,this.gammaSum=null,this.gammaSumPerMixture=null,this.params.xStates=this.params.xStates.map(t=>t.params)},initParametersToDefault(t){"ergodic"===this.params.transitionMode?this.setErgodic():this.setLeftRight();const s=t.map(t=>Math.max(this.params.regularization.absolute,this.params.regularization.relative*t)),i="full"===this.params.covarianceMode?()=>new Array(this.params.dimension**2).fill(this.params.regularization.absolute/2):()=>new Array(this.params.dimension).fill(0);for(let t=0;t<this.params.states;t+=1){const a=this.params.xStates[t];a.currentRegularization=s;for(let t=0;t<this.params.gaussians;t+=1)a.params.components[t].covariance=i(),a.params.components[t].regularize(s),a.params.mixtureCoeffs[t]=1/this.params.gaussians}},initMeansWithAllPhrases(t){if(!t||t.empty())return;for(let t=0;t<this.params.states;t+=1)for(let s=0;s<this.params.dimension;s+=1)this.params.xStates[t].params.components[0].mean[s]=0;const s=new Array(this.params.states).fill(0);t.forEach(t=>{const i=Math.floor(t.length/this.params.states);let a=0;for(let e=0;e<this.params.states;e+=1){for(let s=0;s<i;s+=1)for(let i=0;i<this.params.dimension;i+=1)this.params.xStates[e].params.components[0].mean[i]+=t.get(a+s,i);a+=i,s[e]+=i}});for(let t=0;t<this.params.states;t+=1)for(let i=0;i<this.params.dimension;i+=1)this.params.xStates[t].params.components[0].mean[i]/=s[t]},initCovariancesFullyObserved(t){if(!t||t.empty())return;for(let t=0;t<this.params.states;t+=1)this.params.xStates[t].params.components[0].covariance=new Array(this.params.dimension**("full"===this.params.covarianceMode?2:1)).fill(0);const s=new Array(this.params.states).fill(0),i=new Array(this.params.states*this.params.dimension).fill(0);t.forEach(t=>{const a=Math.floor(t.length/this.params.states);let e=0;for(let r=0;r<this.params.states;r+=1){for(let s=0;s<a;s+=1)for(let a=0;a<this.params.dimension;a+=1)if(i[r*this.params.dimension+a]+=t.get(e+s,a),"full"===this.params.covarianceMode)for(let i=0;i<this.params.dimension;i+=1)this.params.xStates[r].params.components[0].covariance[a*this.params.dimension+i]+=t.get(e+s,a)*t.get(e+s,i);else this.params.xStates[r].params.components[0].covariance[a]+=t.get(e+s,a)**2;e+=a,s[r]+=a}});for(let t=0;t<this.params.states;t+=1)for(let a=0;a<this.params.dimension;a+=1)if(i[t*this.params.dimension+a]/=s[t],"full"===this.params.covarianceMode)for(let i=0;i<this.params.dimension;i+=1)this.params.xStates[t].params.components[0].covariance[a*this.params.dimension+i]/=s[t];else this.params.xStates[t].params.components[0].covariance[a]/=s[t];for(let t=0;t<this.params.states;t+=1){for(let s=0;s<this.params.dimension;s+=1)if("full"===this.params.covarianceMode)for(let a=0;a<this.params.dimension;a+=1)this.params.xStates[t].params.components[0].covariance[s*this.params.dimension+a]-=i[t*this.params.dimension+s]*i[t*this.params.dimension+a];else this.params.xStates[t].params.components[0].covariance[s]-=i[t*this.params.dimension+s]*i[t*this.params.dimension+s];this.params.xStates[t].regularize(),this.params.xStates[t].updateInverseCovariances()}},initMeansCovariancesWithGMMEM(t){for(let s=0;s<this.params.states;s+=1){const i=Object(a.a)(this.params);if(t.forEach((t,a)=>{const e=Math.floor(t.length/this.params.states);if(e>0){i.push(a,t.label);for(let r=s*e;r<(s+1)*e;r+=1)i.getPhrase(a).push(t.getFrame(r))}}),!i.empty()){const t=Object(n.c)(i,this.params);for(let i=0;i<this.params.gaussians;i+=1)this.params.xStates[s].params.components[i].mean=t.components[i].mean,this.params.xStates[s].params.components[i].covariance=t.components[i].covariance,this.params.xStates[s].updateInverseCovariances()}}},setErgodic(){const t=1/this.params.states;this.params.prior=new Array(this.params.states).fill(t),this.params.transition=Array.from(new Array(this.params.states),()=>new Array(this.params.states).fill(t))},setLeftRight(){this.params.prior=new Array(this.params.states).fill(0),this.params.prior[0]=1,this.params.transition=new Array(2*this.params.states).fill(.5),this.params.transition[2*(this.params.states-1)]=1,this.params.transition[2*(this.params.states-1)+1]=0},normalizeTransitions(){if("ergodic"===this.params.transitionMode){const t=this.params.prior.reduce((t,s)=>t+s,0);for(let s=0;s<this.params.states;s+=1){this.params.prior[s]/=t;let i=0;for(let t=0;t<this.params.states;t+=1)i+=this.params.transition[s][t];for(let t=0;t<this.params.states;t+=1)this.params.transition[s][t]/=i}}else for(let t=0;t<this.params.states;t+=1){const s=this.params.transition[2*t]+this.params.transition[2*t+1];this.params.transition[2*t]/=s,this.params.transition[2*t+1]/=s}},initializeBackwardAlgorithm(t){for(let s=0;s<this.params.states;s+=1)this.beta[s]=t},updateBackwardAlgorithm(t,s){this.previousBeta=this.beta.slice();for(let i=0;i<this.params.states;i+=1){if(this.beta[i]=0,"ergodic"===this.params.transitionMode)for(let t=0;t<this.params.states;t+=1)this.beta[i]+=this.params.transition[i][t]*this.previousBeta[t]*this.params.xStates[t].likelihood(s);else this.beta[i]+=this.params.transition[2*i]*this.previousBeta[i]*this.params.xStates[i].likelihood(s),i<this.params.states-1&&(this.beta[i]+=this.params.transition[2*i+1]*this.previousBeta[i+1]*this.params.xStates[i+1].likelihood(s));this.beta[i]*=t,(Number.isNaN(this.beta[i])||Math.abs(this.beta[i])===1/0)&&(this.beta[i]=1e100)}},baumWelchForwardUpdate(t){let s=0;this.previousAlpha=this.alpha.slice();for(let i=0;i<this.params.states;i+=1){if(this.alpha[i]=0,"ergodic"===this.params.transitionMode)for(let t=0;t<this.params.states;t+=1)this.alpha[i]+=this.previousAlpha[t]*this.params.transition[t][i];else this.alpha[i]+=this.previousAlpha[i]*this.params.transition[2*i],i>0?this.alpha[i]+=this.previousAlpha[i-1]*this.params.transition[2*(i-1)+1]:this.alpha[0]+=this.previousAlpha[this.params.states-1]*this.params.transition[2*this.params.states-1];this.alpha[i]*=t[i],s+=this.alpha[i]}if(Number.isNaN(s))throw new Error("Holy molly");if(s>1e-300){for(let t=0;t<this.params.states;t+=1)this.alpha[t]/=s;return 1/s}return 0},baumWelchBackwardUpdate(t,s){this.previousBeta=this.beta.slice();for(let i=0;i<this.params.states;i+=1){if(this.beta[i]=0,"ergodic"===this.params.transitionMode)for(let t=0;t<this.params.states;t+=1)this.beta[i]+=this.params.transition[i][t]*this.previousBeta[t]*s[t];else this.beta[i]+=this.params.transition[2*i]*this.previousBeta[i]*s[i],i<this.params.states-1&&(this.beta[i]+=this.params.transition[2*i+1]*this.previousBeta[i+1]*s[i+1]);this.beta[i]*=t,(Number.isNaN(this.beta[i])||Math.abs(this.beta[i])===1/0)&&(this.beta[i]=1e100)}},baumWelchForwardBackward(t,s){const i=t.length,a=new Array(i).fill(0);let e;this.alphaSeq=[],this.betaSeq=[];const r=Array.from(new Array(i),()=>new Array(this.params.states).fill(0));for(let s=0;s<i;s+=1)for(let i=0;i<this.params.states;i+=1)r[s][i]=this.params.xStates[i].likelihood(t.getFrame(s));a[0]=this.initializeForwardAlgorithm(t.getFrame(0)),e=-Math.log(a[0]),this.alphaSeq.push(this.alpha.slice());for(let t=1;t<i;t+=1)a[t]=this.baumWelchForwardUpdate(r[t]),e-=Math.log(a[t]),this.alphaSeq.push(this.alpha.slice());this.initializeBackwardAlgorithm(a[i-1]),this.betaSeq.push(this.beta.slice());for(let t=i-2;t>=0;t-=1)this.baumWelchBackwardUpdate(a[t],r[t+1]),this.betaSeq.push(this.beta.slice());this.betaSeq.reverse();for(let t=0;t<i;t+=1)for(let i=0;i<this.params.states;i+=1)this.gammaSequence[s][t][i]=this.alphaSeq[t][i]*this.betaSeq[t][i]/a[t];let n;for(let a=0;a<i;a+=1)for(let i=0;i<this.params.states;i+=1){if(n=0,1===this.params.gaussians){const t=r[a][i];this.gammaSequenceperMixture[s][0][a][i]=this.gammaSequence[s][a][i]*t,n+=t}else for(let e=0;e<this.params.gaussians;e+=1){const r=this.params.xStates[i].componentLikelihood(t.getFrame(a),e);this.gammaSequenceperMixture[s][e][a][i]=this.gammaSequence[s][a][i]*r,n+=r}if(n>0)for(let t=0;t<this.params.gaussians;t+=1)this.gammaSequenceperMixture[s][t][a][i]/=n}if("ergodic"===this.params.transitionMode)for(let t=0;t<i-1;t+=1)for(let i=0;i<this.params.states;i+=1)for(let a=0;a<this.params.states;a+=1)this.epsilonSequence[s][t][i][a]=this.alphaSeq[t][i]*this.params.transition[i][a]*this.betaSeq[t+1][a],this.epsilonSequence[s][t][i][a]*=r[t+1][a];else for(let t=0;t<i-1;t+=1)for(let i=0;i<this.params.states;i+=1)this.epsilonSequence[s][t][2*i]=this.alphaSeq[t][i]*this.params.transition[2*i]*this.betaSeq[t+1][i],this.epsilonSequence[s][t][2*i]*=r[t+1][i],i<this.params.states-1&&(this.epsilonSequence[s][t][2*i+1]=this.alphaSeq[t][i]*this.params.transition[2*i+1]*this.betaSeq[t+1][i+1],this.epsilonSequence[s][t][2*i+1]*=r[t+1][i+1]);return e},baumWelchGammaSum(t){for(let t=0;t<this.params.states;t+=1){this.gammaSum[t]=0;for(let s=0;s<this.params.gaussians;s+=1)this.gammaSumPerMixture[t*this.params.gaussians+s]=0}let s=0;t.forEach(t=>{for(let i=0;i<this.params.states;i+=1)for(let a=0;a<t.length;a+=1){this.gammaSum[i]+=this.gammaSequence[s][a][i];for(let t=0;t<this.params.gaussians;t+=1)this.gammaSumPerMixture[i*this.params.gaussians+t]+=this.gammaSequenceperMixture[s][t][a][i]}s+=1})},baumWelchEstimateMixtureCoefficients(t){let s=0;t.forEach(t=>{for(let i=0;i<this.params.states;i+=1)for(let a=0;a<t.length;a+=1)for(let t=0;t<this.params.gaussians;t+=1)this.params.xStates[i].params.mixtureCoeffs[t]+=this.gammaSequenceperMixture[s][t][a][i];s+=1});for(let t=0;t<this.params.states;t+=1)this.params.xStates[t].normalizeMixtureCoeffs()},baumWelchEstimateMeans(t){for(let t=0;t<this.params.states;t+=1)for(let s=0;s<this.params.gaussians;s+=1)this.params.xStates[t].params.components[s].mean.fill(0);let s=0;t.forEach(t=>{for(let i=0;i<this.params.states;i+=1)for(let a=0;a<t.length;a+=1)for(let e=0;e<this.params.gaussians;e+=1)for(let r=0;r<this.params.dimension;r+=1)this.params.xStates[i].params.components[e].mean[r]+=this.gammaSequenceperMixture[s][e][a][i]*t.get(a,r);s+=1});for(let t=0;t<this.params.states;t+=1)for(let s=0;s<this.params.gaussians;s+=1)for(let i=0;i<this.params.dimension;i+=1)if(this.gammaSumPerMixture[t*this.params.gaussians+s]>0&&(this.params.xStates[t].params.components[s].mean[i]/=this.gammaSumPerMixture[t*this.params.gaussians+s]),Number.isNaN(this.params.xStates[t].params.components[s].mean[i]))throw new Error("Convergence Error")},baumWelchEstimateCovariances(t){let s=0;t.forEach(t=>{for(let i=0;i<this.params.states;i+=1)for(let a=0;a<t.length;a+=1)for(let e=0;e<this.params.gaussians;e+=1)for(let r=0;r<this.params.dimension;r+=1)if("full"===this.params.covarianceMode)for(let n=r;n<this.params.dimension;n+=1)this.params.xStates[i].params.components[e].covariance[r*this.params.dimension+n]+=this.gammaSequenceperMixture[s][e][a][i]*(t.get(a,r)-this.params.xStates[i].params.components[e].mean[r])*(t.get(a,n)-this.params.xStates[i].params.components[e].mean[n]);else{const n=t.get(a,r)-this.params.xStates[i].params.components[e].mean[r];this.params.xStates[i].params.components[e].covariance[r]+=this.gammaSequenceperMixture[s][e][a][i]*n**2}s+=1});for(let t=0;t<this.params.states;t+=1){for(let s=0;s<this.params.gaussians;s+=1)if(this.gammaSumPerMixture[t*this.params.gaussians+s]>0)for(let i=0;i<this.params.dimension;i+=1)if("full"===this.params.covarianceMode)for(let a=i;a<this.params.dimension;a+=1)this.params.xStates[t].params.components[s].covariance[i*this.params.dimension+a]/=this.gammaSumPerMixture[t*this.params.gaussians+s],i!==a&&(this.params.xStates[t].params.components[s].covariance[a*this.params.dimension+i]=this.params.xStates[t].params.components[s].covariance[i*this.params.dimension+a]);else this.params.xStates[t].params.components[s].covariance[i]/=this.gammaSumPerMixture[t*this.params.gaussians+s];this.params.xStates[t].regularize(),this.params.xStates[t].updateInverseCovariances()}},baumWelchEstimatePrior(t){this.params.prior.fill(0);let s=0;for(let i=0;i<t.size();i+=1)for(let t=0;t<this.params.states;t+=1)this.params.prior[t]+=this.gammaSequence[i][0][t],s+=this.params.prior[t];if(!(s>0))throw new Error("The Prior is all ZERO.....");for(let t=0;t<this.params.states;t+=1)this.params.prior[t]/=s},baumWelchEstimateTransitions(t){this.params.transition="ergodic"===this.params.transitionMode?Array.from(new Array(this.params.states),()=>new Array(this.params.states).fill(0)):new Array(2*this.params.states).fill(0);let s=0;if(t.forEach(t=>{if(t.length>0)for(let i=0;i<this.params.states;i+=1)if("leftright"===this.params.transitionMode&&(this.params.transition[2*i]+=1e-5,i<this.params.states-1?this.params.transition[2*i+1]+=1e-5:this.params.transition[2*i]+=1e-5),"ergodic"===this.params.transitionMode)for(let a=0;a<this.params.states;a+=1)for(let e=0;e<t.length-1;e+=1)this.params.transition[i][a]+=this.epsilonSequence[s][e][i][a];else{for(let a=0;a<t.length-1;a+=1)this.params.transition[2*i]+=this.epsilonSequence[s][a][2*i];if(i<this.params.states-1)for(let a=0;a<t.length-1;a+=1)this.params.transition[2*i+1]+=this.epsilonSequence[s][a][2*i+1]}s+=1}),"ergodic"===this.params.transitionMode){for(let t=0;t<this.params.states;t+=1)for(let s=0;s<this.params.states;s+=1)if(this.params.transition[t][s]/=this.gammaSum[t]+2e-5,Number.isNaN(this.params.transition[t][s]))throw new Error("Convergence Error. Check your training data or increase the variance offset")}else for(let t=0;t<this.params.states;t+=1){if(this.params.transition[2*t]/=this.gammaSum[t]+2e-5,Number.isNaN(this.params.transition[2*t]))throw new Error("Convergence Error. Check your training data or increase the variance offset");if(t<this.params.states-1&&(this.params.transition[2*t+1]/=this.gammaSum[t]+2e-5,Number.isNaN(this.params.transition[2*t+1])))throw new Error("Convergence Error. Check your training data or increase the variance offset")}}}},function(t,s,i){"use strict";s.a=function(t){if(!Object(e.b)(t))throw new Error("The base object must include a standard set of parameters (`params` key), @see `ModelBase`.");return Object(a.a)("HMM",n(t.params.states,t.params.transitionMode),t.params),Object.assign(t,o,t.params.bimodal?h:{},{alpha:new Array(t.params.states).fill(0),previous_alpha_:new Array(t.params.states).fill(0)}).setup()};var a=i(10),e=i(0),r=i(1);const n=(t,s)=>({states:{required:!0,check:{min:1}},gaussians:{required:!0,check:{min:1}},regularization:{required:!0,check:({absolute:t,relative:s})=>t&&s&&t>0&&s>0},transitionMode:{required:!0,check:["ergodic","leftright"]},covarianceMode:{required:!0,check:["full","diagonal"]},prior:{required:!0,check:i=>"leftright"===s||i.length===t},transition:{required:!0,check:i=>"leftright"===s?i.length===2*t:i.length===t},xStates:{required:!0,check:s=>s.length===t}}),o={forwardInitialized:!1,isHierarchical:!1,setup(){return this.params.xStates=this.params.xStates.map(t=>Object(r.a)(t).reset()),this},reset(){return this.likelihoodBuffer.clear(),this.params.xStates.forEach(t=>{t.reset()}),this},likelihood(t){const s=this.forwardInitialized?this.updateForwardAlgorithm(t):this.initializeForwardAlgorithm(t);return this.updateAlphaWindow(),this.updateProgress(),1/s},updateProgress(){this.results.progress=0;for(let t=this.windowMinindex;t<this.windowMaxindex;t+=1)this.isHierarchical?this.results.progress+=(this.alpha[t]+this.alpha1[t]+this.alpha2[t])*(t/this.windowNormalizationConstant):this.results.progress+=this.alpha[t]*t/this.windowNormalizationConstant;this.results.progress/=this.params.states-1},updateAlphaWindow(){this.results.likeliestState=0;let t=this.isHierarchical?this.alpha[0]+this.alpha1[0]:this.alpha[0];for(let s=1;s<this.params.states;s+=1)this.isHierarchical?this.alpha[s]+this.alpha1[s]>t&&(t=this.alpha[s]+this.alpha1[s],this.results.likeliestState=s):this.alpha[s]>t&&(t=this.alpha[s],this.results.likeliestState=s);this.windowMinindex=this.results.likeliestState-Math.floor(this.params.states/2),this.windowMaxindex=this.results.likeliestState+Math.floor(this.params.states/2),this.windowMinindex=this.windowMinindex>=0?this.windowMinindex:0,this.windowMaxindex=this.windowMaxindex<=this.params.states?this.windowMaxindex:this.params.states,this.windowNormalizationConstant=0;for(let t=this.windowMinindex;t<this.windowMaxindex;t+=1)this.windowNormalizationConstant+=this.isHierarchical?this.alpha[t]+this.alpha1[t]:this.alpha[t]}},h={regression(t){if(this.results.outputValues=Array(this.params.outputDimension).fill(0),this.results.outputCovariance=Array("full"===this.params.covarianceMode?this.params.outputDimension**2:this.params.outputDimension).fill(0),"likeliest"===this.params.regressionEstimator)return this.params.xStates[this.results.likeliestState].predict(t),this.results.outputValues=this.params.xStates[this.results.likeliestState].results.outputValues,this.results.outputValues;const s="full"===this.params.regressionEstimator?0:this.windowMinindex,i="full"===this.params.regressionEstimator?this.params.states:this.windowMaxindex;let a="full"===this.params.regressionEstimator?1:this.windowNormalizationConstant;a<=0&&(a=1);for(let e=s;e<i;e+=1){this.params.xStates[e].likelihood(t),this.params.xStates[e].regression(t);const s=this.params.xStates[e].results.outputValues;for(let t=0;t<this.params.outputDimension;t+=1)if(this.isHierarchical)if(this.results.outputValues[t]+=(this.alpha[e]+this.alpha1[e])*(s[t]/a),"full"===this.params.covarianceMode)for(let s=0;s<this.params.outputDimension;s+=1)this.results.outputCovariance[t*this.params.outputDimension+s]+=(this.alpha[e]+this.alpha1[e])*(this.alpha[e]+this.alpha1[e])*(this.params.xStates[e].results.outputCovariance[t*this.params.outputDimension+s]/a);else this.results.outputCovariance[t]+=(this.alpha[e]+this.alpha1[e])*(this.alpha[e]+this.alpha1[e])*(this.params.xStates[e].results.outputCovariance[t]/a);else if(this.results.outputValues[t]+=this.alpha[e]*(s[t]/a),"full"===this.params.covarianceMode)for(let s=0;s<this.params.outputDimension;s+=1)this.results.outputCovariance[t*this.params.outputDimension+s]+=this.alpha[e]**2*(this.params.xStates[e].results.outputCovariance[t*this.params.outputDimension+s]/a);else this.results.outputCovariance[t]+=this.alpha[e]**2*this.params.xStates[e].results.outputCovariance[t]/a}return this.results.outputValues}}},function(t,s,i){"use strict";s.a=function(t){if(!Object(a.b)(t))throw new Error("The base object must include a standard set of parameters (`params` key), @see `ModelBase`.");return Object.assign(t,e,{}).setup()};var a=i(0);const e={forwardInitialized:!1,setup(){const t=this.size();return this.params.prior=new Array(t).fill(1/t),this.params.transition=Array.from(new Array(t),()=>new Array(t).fill(1/t)),this.params.exitTransition=new Array(t).fill(.1),Object.values(this.models).forEach(t=>{t.isHierarchical=!0}),this.updateExitProbabilities(),this},updateExitProbabilities(t){const s=void 0!==t?t:new Array(this.params.states-1).fill(0).concat([.1]);Object.keys(this.models).forEach(t=>{this.models[t].params.exitProbabilities=s.slice()})},reset(){Object.values(this.models).forEach(t=>t.reset()),this.results={labels:[],instantLikelihoods:[],smoothedLikelihoods:[],smoothedLogLikelihoods:[],smoothedNormalizedLikelihoods:[],exitLikelihood:[],likeliest:null,classes:{}},this.params.bimodal&&this.resetBimodal(),this.forwardInitialized=!1},predict(t){if(this.forwardInitialized?this.updateForwardAlgorithm(t):this.initializeForwardAlgorithm(t),Object.keys(this.models).sort().forEach(t=>{const s=this.models[t];s.updateAlphaWindow(),s.updateProgress(),s.updateResults(s.results.instantLikelihood)}),this.updateResults(),this.params.bimodal)if(Object.values(this.models).forEach(s=>s.regression(t)),"likeliest"===this.params.multiClassRegressionEstimator)this.results.outputValues=this.models[this.results.likeliest].results.outputValues,this.results.outputCovariance=this.models[this.results.likeliest].results.outputCovariance;else{this.results.outputValues=new Array(this.outputDimension).fill(0),this.results.outputCovariance=new Array("full"===this.params.covarianceMode?this.outputDimension**2:this.outputDimension).fill(0);let t=0;Object.values(this.models).forEach(s=>{for(let i=0;i<this.outputDimension;i+=1)if(this.results.outputValues[i]+=this.results.smoothedNormalizedLikelihoods[t]*s.second.results.outputValues[i],"full"===this.params.covarianceMode)for(let a=0;a<this.outputDimension;a+=1)this.results.outputCovariance[i*this.outputDimension+a]+=this.results.smoothedNormalizedLikelihoods[t]*s.results.outputCovariance[i*this.outputDimension+a];else this.results.outputCovariance[i]+=this.results.smoothedNormalizedLikelihoods[t]*s.second.results.outputCovariance[i];t+=1})}},initializeForwardAlgorithm(t){let s=0,i=0;const a=Object.keys(this.models).sort();a.forEach(a=>{const e=this.models[a],r=e.params.states;if(e.alpha1=new Array(r).fill(0),e.alpha2=new Array(r).fill(0),"ergodic"===e.params.transitionMode){e.results.instantLikelihood=0;for(let s=0;s<r;s+=1)e.alpha[s]=this.params.prior[i]*e.params.prior[s]*e.params.xStates[s].likelihood(t),e.results.instantLikelihood+=e.alpha[s]}else e.alpha[0]=this.params.prior[i]*e.params.xStates[0].likelihood(t),[e.results.instantLikelihood]=e.alpha;s+=e.results.instantLikelihood,i+=1}),a.forEach(t=>{const i=this.models[t],a=i.params.states;for(let t=0;t<a;t+=1)i.alpha[t]/=s}),this.frontierV1=new Array(this.size).fill(0),this.frontierV2=new Array(this.size).fill(0),this.forwardInitialized=!0},updateForwardAlgorithm(t){let s=0,i=0;this.frontierV1=this.likelihoodAlpha(1),this.frontierV2=this.likelihoodAlpha(2);let a=0;const e=Object.keys(this.models).sort();e.forEach(e=>{const r=this.models[e],n=r.params.states,o=new Array(n).fill(0);if("ergodic"===r.params.transitionMode)for(let t=0;t<n;t+=1){for(let s=0;s<n;s+=1)o[t]+=r.params.transition[s][t]/(1-r.params.exitProbabilities[s])*r.alpha[s];for(let s=0;s<this.size();s+=1)o[t]+=r.params.prior[t]*(this.frontierV1[s]*this.params.transition[s][a]+this.params.prior[a]*this.frontierV2[s])}else{o[0]=r.params.transition[0]*r.alpha[0];for(let t=0;t<this.size();t+=1)o[0]+=this.frontierV1[t]*this.params.transition[t][a]+this.params.prior[a]*this.frontierV2[t];for(let t=1;t<n;t+=1)o[t]+=r.params.transition[2*t]/(1-r.params.exitProbabilities[t])*r.alpha[t],o[t]+=r.params.transition[2*(t-1)+1]/(1-r.params.exitProbabilities[t-1])*r.alpha[t-1];for(let t=0;t<n;t+=1)r.alpha[t]=0,r.alpha1[t]=0,r.alpha2[t]=0}r.results.exitLikelihood=0,r.results.instantLikelihood=0;for(let e=0;e<n;e+=1)i=r.params.xStates[e].likelihood(t)*o[e],r.alpha2[e]=this.params.exitTransition[a]*r.params.exitProbabilities[e]*i,r.alpha1[e]=(1-this.params.exitTransition[a])*r.params.exitProbabilities[e]*i,r.alpha[e]=(1-r.params.exitProbabilities[e])*i,r.results.exitLikelihood+=r.alpha1[e]+r.alpha2[e],r.results.instantLikelihood+=r.alpha[e]+r.alpha1[e]+r.alpha2[e],s+=i;r.results.exitRatio=r.results.exitLikelihood/r.results.instantLikelihood,a+=1}),e.forEach(t=>{const i=this.models[t],a=i.params.states;for(let t=0;t<a;t+=1)i.alpha[t]/=s,i.alpha1[t]/=s,i.alpha2[t]/=s})},likelihoodAlpha(t){const s=new Array(this.size()).fill(0);if(t<0){let t=0;Object.keys(this.models).sort().forEach(i=>{const a=this.models[i];s[t]=0;for(let i=0;i<a.params.states;i+=1)s[t]+=a.second.alpha[i]+a.second.alpha1[i]+a.second.alpha2[i];t+=1})}else{let i=0;Object.keys(this.models).sort().forEach(a=>{const e=this.models[a];s[i]=0;let{alpha:r}=e;1===t&&(r=e.alpha1),2===t&&(r=e.alpha2);for(let t=0;t<e.params.states;t+=1)s[i]+=r[t];i+=1})}return s}}}])});
//# sourceMappingURL=xmm.js.map