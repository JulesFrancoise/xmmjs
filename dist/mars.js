!function(t,i){"object"==typeof exports&&"object"==typeof module?module.exports=i():"function"==typeof define&&define.amd?define([],i):"object"==typeof exports?exports.mars=i():t.mars=i()}("undefined"!=typeof self?self:this,function(){return function(t){var i={};function s(e){if(i[e])return i[e].exports;var n=i[e]={i:e,l:!1,exports:{}};return t[e].call(n.exports,n,n.exports,s),n.l=!0,n.exports}return s.m=t,s.c=i,s.d=function(t,i,e){s.o(t,i)||Object.defineProperty(t,i,{configurable:!1,enumerable:!0,get:e})},s.n=function(t){var i=t&&t.__esModule?function(){return t.default}:function(){return t};return s.d(i,"a",i),i},s.o=function(t,i){return Object.prototype.hasOwnProperty.call(t,i)},s.p="",s(s.s=4)}([function(t,i,s){"use strict";i.a=function(t){let{inputDimension:i,outputDimension:s}=t;const n=function(t,i){var s={};for(var e in t)i.indexOf(e)>=0||Object.prototype.hasOwnProperty.call(t,e)&&(s[e]=t[e]);return s}(t,["inputDimension","outputDimension"]);return delete n.bimodal,delete n.inputDimension,delete n.outputDimension,delete n.dimension,{params:e({},n,{get bimodal(){return s>0},get inputDimension(){return i},get outputDimension(){return s},get dimension(){return i+s}})}},i.b=function(t){if(!Object.keys(t).includes("params"))return!1;return["bimodal","inputDimension","outputDimension","dimension"].map(i=>Object.keys(t.params).includes(i)).reduce((t,i)=>t&&i,!0)};var e=Object.assign||function(t){for(var i=1;i<arguments.length;i++){var s=arguments[i];for(var e in s)Object.prototype.hasOwnProperty.call(s,e)&&(t[e]=s[e])}return t}},function(t,i,s){"use strict";i.a=function(t,i,s={}){if(!Object(e.b)(t))throw new Error("The base object must include a standard set of parameters (`params` key), @see `ModelBase`.");const n=Object.assign({initialization:"random",relativeDistanceThreshold:.001,minIterations:5,maxIterations:100},s),r=Object.assign(t,a,{trainingConfig:n});return r.params.clusters=i,r};var e=s(0),n=s(8);const a={train(t){if(!t||t.empty())throw new Error("The training set is empty");if(this.params.centers=Array.from(Array(this.params.clusters),()=>new Array(this.params.dimension).fill(0)),"random"===this.trainingConfig.initialization)this.initializeClustersRandom(t);else if("forgy"===this.trainingConfig.initialization)this.initializeClustersForgy(t);else{if("data"!==this.trainingConfig.initialization)throw new Error("Unknown K-Means initialization, must be `random`, `forgy` or `data`");this.initClustersWithFirstPhrase(t)}for(let i=0;i<this.trainingConfig.maxIterations;i+=1){const i=this.params.centers;this.updateCenters(i,t);let s=0,e=0;for(let t=0;t<this.params.clusters;t+=1){for(let i=0;i<this.params.clusters;i+=1)t!==i&&(s+=Object(n.a)(this.params.centers[t],this.params.centers[i]));e=Math.max(Object(n.a)(i[t],this.params.centers[t]),e)}if(s/=this.params.clusters*(this.params.clusters-1),e/=this.params.clusters,(e/=s)<this.trainingConfig.relativeDistanceThreshold)break}return this.params},initClustersWithFirstPhrase(t){const i=t.getPhrase(t.indices()[0]),s=Math.floor(i.length/this.params.clusters);let e=0;for(let t=0;t<this.params.clusters;t+=1){this.params.centers[t]=new Array(this.params.dimension).fill(0);for(let n=0;n<s;n+=1)for(let a=0;a<this.params.dimension;a+=1)this.params.centers[t][a]+=i.get(e+n,a)/s;e+=s}},initializeClustersRandom(t){const i=t.getPhrase(t.indices()[0]),s=Array.from(Array(i.length),()=>Math.floor(Math.random()*this.params.clusters)),e=s.reduce((t,i)=>{const s=t;return s[i]+=1,s},Array(this.params.clusters).fill(0));for(let t=0;t<s.length;t+=1){const e=s[t];for(let s=0;s<this.params.dimension;s+=1)this.params.centers[e][s]+=i.get(t,s)}this.params.centers.forEach((t,i)=>{this.params.centers[i]=this.params.centers[i].map(t=>t/e[i])})},initializeClustersForgy(t){const i=t.getPhrase(t.indices()[0]),s=Array.from(Array(this.params.clusters),()=>Math.floor(Math.random()*i.length));this.params.centers=s.map(t=>i.getFrame(t))},updateCenters(t,i){this.params.centers=Array.from(Array(this.params.clusters),()=>new Array(this.params.dimension).fill(0));const s=Array(this.params.clusters).fill(0);i.forEach(i=>{for(let e=0;e<i.length;e+=1){const a=i.getFrame(e);let r=Object(n.a)(a,t[0]),o=0;for(let i=1;i<this.params.clusters;i+=1){const s=Object(n.a)(a,t[i],this.params.dimension);s<r&&(o=i,r=s)}s[o]+=1;for(let t=0;t<this.params.dimension;t+=1)this.params.centers[o][t]+=i.get(e,t)}});for(let t=0;t<this.params.clusters;t+=1)if(s[t]>0)for(let i=0;i<this.params.dimension;i+=1)this.params.centers[t][i]/=s[t]}}},function(t,i,s){"use strict";i.a=function(t){if(!Object(e.b)(t))throw new Error("The base object must include a standard set of parameters (`params` key), @see `ModelBase`.");return Object.assign(t,n,t.params.bimodal?a:{})};var e=s(0);const n={likelihood(t){let i=0;for(let s=0;s<this.params.gaussians;s+=1)this.beta[s]=this.componentLikelihood(t,s),i+=this.beta[s];for(let t=0;t<this.params.gaussians;t+=1)this.beta[t]/=i;return i},componentLikelihood(t,i){if(i>=this.params.gaussians)throw new Error("The index of the Gaussian Mixture Component is out of bounds");return this.params.mixtureCoeffs[i]*this.params.components[i].likelihood(t)}},a={regression(t){let i;this.results.outputValues=Array(this.params.outputDimension).fill(0),this.results.outputCovariance=Array("full"===this.params.covarianceMode?this.params.outputDimension**2:this.params.outputDimension).fill(0);for(let s=0;s<this.params.gaussians;s+=1){i=this.params.components[s].regression(t);for(let t=0;t<this.params.outputDimension;t+=1)if(this.results.outputValues[t]+=this.beta[s]*i[t],"full"===this.params.covarianceMode)for(let i=0;i<this.params.outputDimension;i+=1)this.results.outputCovariance[t*this.params.outputDimension+i]+=this.beta[s]**2*this.params.components[s].outputCovariance[t*this.params.outputDimension+i];else this.results.outputCovariance[t]+=this.beta[s]**2*this.params.components[s].outputCovariance[t]}return this.results.outputValues}}},function(t,i,s){"use strict";i.a=function(t){let{inputDimension:i,outputDimension:s}=t,r=function(t,i){var s={};for(var e in t)i.indexOf(e)>=0||Object.prototype.hasOwnProperty.call(t,e)&&(s[e]=t[e]);return s}(t,["inputDimension","outputDimension"]);return Object.assign(Object(e.a)(n({inputDimension:i,outputDimension:s},r)),a)};var e=s(0),n=Object.assign||function(t){for(var i=1;i<arguments.length;i++){var s=arguments[i];for(var e in s)Object.prototype.hasOwnProperty.call(s,e)&&(t[e]=s[e])}return t};const a={size(){return this.models.size},includes(t){return Object.keys(this.models).includes(t)},remove(t){this.includes(t)&&delete this.models[t]}}},function(t,i,s){"use strict";Object.defineProperty(i,"__esModule",{value:!0});var e=s(5);s.d(i,"TrainingSet",function(){return e.a});var n=s(7);s.d(i,"trainKmeans",function(){return n.b}),s.d(i,"trainGMM",function(){return n.a}),s.d(i,"trainMulticlassGMM",function(){return n.c});var a=s(14);s.d(i,"GMMPredictor",function(){return a.a}),s.d(i,"multiclassGMMPredictor",function(){return a.b})},function(t,i,s){"use strict";i.a=r;var e=s(6),n=Object.assign||function(t){for(var i=1;i<arguments.length;i++){var s=arguments[i];for(var e in s)Object.prototype.hasOwnProperty.call(s,e)&&(t[e]=s[e])}return t};const a={size(){return Object.keys(this.phrases).length},empty(){return 0===this.length},getPhrase(t){return Object.keys(this.phrases).includes(t.toString())?this.phrases[t.toString()]:null},forEach(t){Object.keys(this.phrases).forEach(i=>{t(this.phrases[i],i,this.phrases)})},push(t,i,s){const n=void 0!==s?s:Object(e.a)({inputDimension:this.inputDimension,outputDimension:this.outputDimension,columnNames:this.columnNames,label:void 0!==i?i:t.toString()});return this.phrases[t]=n,n},remove(t){delete this.phrases[t]},removeClass(t){this.phrases=Object.keys(this.phrases).filter(i=>this.phrases[i].label!==t).map(t=>({i:this.phrases[t]})).reduce((t,i)=>n({},t,i),{})},clear(){this.phrases={}},getPhrasesOfClass(t){const i=r(this);return i.phrases=Object.keys(this.phrases).filter(i=>this.phrases[i].label===t).map(t=>({i:this.phrases[t]})).reduce((t,i)=>n({},t,i),{}),i},labels(){return Object.keys(this.phrases).map(t=>this.phrases[t].label).reduce((t,i)=>t.includes(i)?t:t.concat([i]),[])},indices(){return Object.keys(this.phrases)},mean(){const t=Array(this.dimension).fill(0);let i=0;return Object.keys(this.phrases).forEach(s=>{for(let i=0;i<this.dimension;i+=1)for(let e=0;e<this.phrases[s].length;e+=1)t[i]+=this.phrases[s].get(e,i);i+=this.phrases[s].length}),t.map(t=>t/i)},standardDeviation(){const t=Array(this.dimension).fill(0),i=this.mean();let s=0;return Object.keys(this.phrases).forEach(e=>{for(let s=0;s<this.dimension;s+=1)for(let n=0;n<this.phrases[e].length;n+=1)t[s]+=(this.phrases[e].get(n,s)-i[s])**2;s+=this.phrases[e].length}),t.map(t=>Math.sqrt(t/s))},minmax(){const t=Array.from(Array(this.dimension),()=>({min:1/0,max:-1/0}));return Object.keys(this.phrases).forEach(i=>{for(let s=0;s<this.dimension;s+=1)for(let e=0;e<this.phrases[i].length;e+=1)t[s].min+=Math.min(t[s].min,this.phrases[i].get(e,s)),t[s].max+=Math.max(t[s].max,this.phrases[i].get(e,s))}),t}};function r({inputDimension:t=1,outputDimension:i=0,columnNames:s=null}={}){const e=t+i;return Object.assign(Object.create(a),{bimodal:i>0,inputDimension:t,outputDimension:i,dimension:e,columnNames:s||Array(e).fill(""),phrases:{}})}},function(t,i,s){"use strict";i.a=function({inputDimension:t=1,outputDimension:i=0,columnNames:s=null,label:n=""}={}){const a=t+i;return Object.assign(Object.create(e),{bimodal:i>0,inputDimension:t,outputDimension:i,dimension:a,length:0,label:n,inputData:[],outputData:[],columnNames:s||Array(a).fill("")})};const e={get(t,i){if("number"!=typeof t||Math.floor(t)!==t)throw new Error("The index must be an integer");if(i>=this.dimension)throw new Error("Phrase: dimension out of bounds");if(this.bimodal){if(i<this.inputDimension){if(t>=this.inputData.length)throw new Error("Phrase: index out of bounds");return this.inputData[t][i]}if(t>=this.outputData.length)throw new Error("Phrase: index out of bounds");return this.outputData[t][i-this.inputDimension]}if(t>=this.length)throw new Error("Phrase: index out of bounds");if(!this.inputData[t])throw new Error("WTF?");return this.inputData[t][i]},getFrame(t){if(t>=this.length)throw new Error("Phrase: index out of bounds");return this.bimodal?this.inputData[t].concat(this.outputData[t]):this.inputData[t]},push(t){if(t.length!==this.dimension)throw new Error("Observation has wrong dimension");this.bimodal?(this.inputData.push(t.slice(0,this.inputDimension)),this.outputData.push(t.slice(this.inputDimension,this.dimension))):this.inputData.push(t),this.length+=1},pushInput(t){if(!this.bimodal)throw new Error("this phrase is unimodal, use `push`");if(t.size()!==this.inputDimension)throw new Error("Observation has wrong dimension");this.inputData.push(t),this.trim()},pushOutput(t){if(!this.bimodal)throw new Error("this phrase is unimodal, use `push`");if(t.size()!==this.outputDimension)throw new Error("Observation has wrong dimension");this.outputData.push(t),this.trim()},clear(){this.length=0,this.inputData=[],this.outputData=[]},clearInput(){this.inputData=[],this.trim()},clearOutput(){this.outputData=[],this.trim()},mean(){const t=Array(this.dimension).fill(0);for(let i=0;i<this.dimension;i+=1){for(let s=0;s<this.length;s+=1)t[i]+=this.get(s,i);t[i]/=this.length}return t},standardDeviation(){const t=Array(this.dimension).fill(0),i=this.mean();for(let s=0;s<this.dimension;s+=1){for(let e=0;e<this.length;e+=1)t[s]+=(this.get(e,s)-i[s])*(this.get(e,s)-i[s]);t[s]/=this.length,t[s]=Math.sqrt(t[s])}return t},minmax(){const t=Array.from(Array(this.dimension),()=>({min:1/0,max:-1/0}));for(let i=0;i<this.dimension;i+=1)for(let s=0;s<this.length;s+=1)t[i].min=Math.min(this.get(s,i),t[i].min),t[i].max=Math.max(this.get(s,i),t[i].max);return t},trim(){this.bimodal&&(this.length=Math.min(this.inputData.length,this.outputData.length))}}},function(t,i,s){"use strict";i.b=function(t,i,s){const{inputDimension:a,outputDimension:r}=t;return Object(n.a)(Object(e.a)({inputDimension:a,outputDimension:r}),i,s).train(t)},i.a=c,i.c=function(t,i,s){const{inputDimension:e,outputDimension:n}=t;return Object(u.a)(Object(h.a)(l({inputDimension:e,outputDimension:n},i)),t=>c(t,i,s)).train(t)};var e=s(0),n=s(1),a=s(9),r=s(2),o=s(10),h=s(3),u=s(13),l=Object.assign||function(t){for(var i=1;i<arguments.length;i++){var s=arguments[i];for(var e in s)Object.prototype.hasOwnProperty.call(s,e)&&(t[e]=s[e])}return t};function c(t,i,s){const{inputDimension:n,outputDimension:h}=t,{gaussians:u,regularization:c,covarianceMode:m}=i;return Object(o.a)(Object(a.a)(Object(r.a)(Object(e.a)(l({inputDimension:n,outputDimension:h},i))),s),u,c,m).train(t)}},function(t,i,s){"use strict";i.a=function(t,i){return Math.sqrt(t.map((t,s)=>(t-i[s])**2).reduce((t,i)=>t+i,0))}},function(t,i,s){"use strict";i.a=function(t,i={percentChange:.001,minIterations:5,maxIterations:100}){return Object.assign(t,e,{convergenceCriteria:i})};const e={train(t){if(!t||t.empty())throw new Error("The training set is empty");this.initTraining(t);let i=-1/0,s=0,e=i;for(;!this.converged(s,i,e);){e=i,i=this.updateTraining(t);const n=100*Math.abs((i-e)/e);if(Number.isNaN(n)&&s>1)throw new Error("An error occured during training");s+=1}return this.terminateTraining(),this.params},converged(t,i,s){if(t>=this.convergenceCriteria.maxIterations)return!0;if(this.convergenceCriteria.maxIterations>=this.convergenceCriteria.minIterations)return t>=this.convergenceCriteria.maxIterations;if(t<this.convergenceCriteria.minIterations)return!1;return 100*Math.abs((i-s)/i)<=this.convergenceCriteria.percentChange}}},function(t,i,s){"use strict";i.a=function(t,i=1,s={absolute:.001,relative:.01},e="full"){if(!Object.keys(t).includes("params"))throw new Error("The base object must include a standard set of parameters (`params` key), @see `ModelBase`.");return Object.assign(t,o,{params:r({},t.params,{gaussians:i,regularization:s,covarianceMode:e})})};var e=s(0),n=s(1),a=s(11),r=Object.assign||function(t){for(var i=1;i<arguments.length;i++){var s=arguments[i];for(var e in s)Object.prototype.hasOwnProperty.call(s,e)&&(t[e]=s[e])}return t};const o={initTraining(t){this.allocate(),this.initParametersToDefault(t.standardDeviation()),this.initMeansWithKMeans(t),this.initCovariances(t),this.addCovarianceOffset(),this.updateInverseCovariances()},allocate(){this.params.components=Array.from(Array(this.params.gaussians),()=>new a.a(this.params.inputDimension,this.params.outputDimension,this.params.covarianceMode)),this.params.mixtureCoeffs=Array(this.params.gaussians).fill(0)},initParametersToDefault(t){let i=0;this.currentRegularization=t.map(t=>Math.max(this.params.regularization.absolute,this.params.regularization.relative*t));for(let t=0;t<this.params.gaussians;t+=1)"full"===this.params.covarianceMode?this.params.components[t].covariance=Array(this.params.dimension**2).fill(this.params.regularization.absolute/2):this.params.components[t].covariance=Array(this.params.dimension).fill(0),this.params.components[t].regularize(this.currentRegularization),this.params.mixtureCoeffs[t]=1/this.params.gaussians,i+=this.params.mixtureCoeffs[t];for(let t=0;t<this.params.gaussians;t+=1)this.params.mixtureCoeffs[t]/=i},initMeansWithKMeans(t){if(!t||t.empty())return;const i=Object(n.a)(Object(e.a)({inputDimension:this.params.inputDimension,outputDimension:this.params.outputDimension}),this.params.gaussians,{initialization:"random"}).train(t);for(let t=0;t<this.params.gaussians;t+=1)this.params.components[t].mean=i.centers[t]},initCovariances(t){if(!t||t.empty())return;for(let t=0;t<this.params.gaussians;t+=1)this.params.components[t].covariance=Array("full"===this.params.covarianceMode?this.params.dimension**2:this.params.dimension).fill(0);const i=Array(this.params.gaussians*this.params.dimension).fill(0),s=Array(this.params.gaussians).fill(0);t.forEach(t=>{const e=Math.floor(t.length/this.params.gaussians);let n=0;for(let a=0;a<this.params.gaussians;a+=1){for(let s=0;s<e;s+=1)for(let e=0;e<this.params.dimension;e+=1)if(i[a*this.params.dimension+e]+=t.get(n+s,e),"full"===this.params.covarianceMode)for(let i=0;i<this.params.dimension;i+=1)this.params.components[a].covariance[e*this.params.dimension+i]+=t.get(n+s,e)*t.get(n+s,i);else this.params.components[a].covariance[e]+=t.get(n+s,e)**2;n+=e,s[a]+=e}});for(let t=0;t<this.params.gaussians;t+=1)for(let e=0;e<this.params.dimension;e+=1)if(i[t*this.params.dimension+e]/=s[t],"full"===this.params.covarianceMode)for(let i=0;i<this.params.dimension;i+=1)this.params.components[t].covariance[e*this.params.dimension+i]/=s[t];else this.params.components[t].covariance[e]/=s[t];for(let t=0;t<this.params.gaussians;t+=1)for(let s=0;s<this.params.dimension;s+=1)if("full"===this.params.covarianceMode)for(let e=0;e<this.params.dimension;e+=1)this.params.components[t].covariance[s*this.params.dimension+e]-=i[t*this.params.dimension+s]*i[t*this.params.dimension+e];else this.params.components[t].covariance[s]-=i[t*this.params.dimension+s]**2},addCovarianceOffset(){this.params.components.forEach(t=>{t.regularize(this.currentRegularization)})},updateInverseCovariances(){this.params.components.forEach(t=>{t.updateInverseCovariance()});try{this.params.components.forEach(t=>{t.updateInverseCovariance()})}catch(t){throw new Error("Matrix inversion error: varianceoffset must be too small")}},updateTraining(t){let i=0,s=0;t.forEach(t=>{s+=t.length});const e=Object.keys(t.phrases),n=Array.from(Array(this.params.gaussians),()=>new Array(s).fill(0)),a=Array(this.params.gaussians).fill(0);let r=0;t.forEach(t=>{for(let s=0;s<t.length;s+=1){let e=0;for(let i=0;i<this.params.gaussians;i+=1)n[i][r+s]=this.componentLikelihood(t.getFrame(s),i),(0===n[i][r+s]||Number.isNaN(n[i][r+s])||n[i][r+s]===1/0)&&(n[i][r+s]=1e-100),e+=n[i][r+s];for(let t=0;t<this.params.gaussians;t+=1)n[t][r+s]/=e,a[t]+=n[t][r+s];i+=Math.log(e)}r+=t.length});for(let t=0;t<this.params.gaussians;t+=1)this.params.mixtureCoeffs[t]=a[t]/s;for(let i=0;i<this.params.gaussians;i+=1)for(let s=0;s<this.params.dimension;s+=1){this.params.components[i].mean[s]=0,r=0;for(let a=0;a<e.length;a+=1){const o=t.phrases[e[a]];for(let t=0;t<o.length;t+=1)this.params.components[i].mean[s]+=n[i][r+t]*o.get(t,s);r+=o.length}this.params.components[i].mean[s]/=a[i]}if("full"===this.params.covarianceMode)for(let i=0;i<this.params.gaussians;i+=1)for(let s=0;s<this.params.dimension;s+=1)for(let o=s;o<this.params.dimension;o+=1){this.params.components[i].covariance[s*this.params.dimension+o]=0,r=0;for(let a=0;a<e.length;a+=1){const h=t.phrases[e[a]];for(let t=0;t<h.length;t+=1)this.params.components[i].covariance[s*this.params.dimension+o]+=n[i][r+t]*(h.get(t,s)-this.params.components[i].mean[s])*(h.get(t,o)-this.params.components[i].mean[o]);r+=h.length}this.params.components[i].covariance[s*this.params.dimension+o]/=a[i],s!==o&&(this.params.components[i].covariance[o*this.params.dimension+s]=this.params.components[i].covariance[s*this.params.dimension+o])}else for(let i=0;i<this.params.gaussians;i+=1)for(let s=0;s<this.params.dimension;s+=1){this.params.components[i].covariance[s]=0,r=0;for(let a=0;a<e.length;a+=1){const o=t.phrases[e[a]];for(let t=0;t<o.length;t+=1){const e=o.get(t,s)-this.params.components[i].mean[s];this.params.components[i].covariance[s]+=n[i][r+t]*e*e}r+=o.length}this.params.components[i].covariance[s]/=a[i]}return this.addCovarianceOffset(),this.updateInverseCovariances(),i},normalizeMixtureCoeffs(){let t=0;for(let i=0;i<this.params.gaussians;i+=1)t+=this.params.mixtureCoeffs[i];if(t>0)for(let i=0;i<this.params.gaussians;i+=1)this.params.mixtureCoeffs[i]/=t;else for(let t=0;t<this.params.gaussians;t+=1)this.params.mixtureCoeffs[t]=1/this.params.gaussians},terminateTraining(){}}},function(t,i,s){"use strict";i.a=function(t=1,i=0,s="full"){const e=i>0,r=t+i,o=e?Object.assign({},n,a):n,h=Object.assign({bimodal:e,dimension:r,inputDimension:t,outputDimension:i,covarianceMode:s,covarianceDeterminant:0},e?{covarianceDeterminantInput:0}:{}),u=Object.assign(Object.create(o),h);return u.allocate(),u};var e=s(12);const n={allocate(){this.mean=new Array(this.dimension).fill(0),"full"===this.covarianceMode?(this.covariance=new Array(this.dimension**2).fill(0),this.inverseCovariance=new Array(this.dimension**2).fill(0)):(this.covariance=new Array(this.dimension).fill(0),this.inverseCovariance=new Array(this.dimension).fill(0)),this.bimodal&&this.allocateBimodal()},likelihood(t){if(0===this.covarianceDeterminant)throw new Error("Covariance Matrix is not invertible");if(this.bimodal&&t.length===this.inputDimension)return this.inputLikelihood(t);if(t.length!==this.dimension)throw new Error(`GaussianDistribution: observation has wrong dimension. Expected \`${this.dimension}\`, got \`${t.length}\``);let i=0;if("full"===this.covarianceMode)for(let s=0;s<this.dimension;s+=1){let e=0;for(let i=0;i<this.dimension;i+=1)e+=this.inverseCovariance[s*this.dimension+i]*(t[i]-this.mean[i]);i+=(t[s]-this.mean[s])*e}else for(let s=0;s<this.dimension;s+=1)i+=this.inverseCovariance[s]*(t[s]-this.mean[s])*(t[s]-this.mean[s]);let s=Math.exp(-.5*i)/Math.sqrt(this.covarianceDeterminant*(2*Math.PI)**this.dimension);return(s<1e-180||Number.isNaN(s)||Math.abs(s)===1/0)&&(s=1e-180),s},regularize(t){if("full"===this.covarianceMode)for(let i=0;i<this.dimension;i+=1)this.covariance[i*this.dimension+i]+=t[i];else for(let i=0;i<this.dimension;i+=1)this.covariance[i]+=t[i]},updateInverseCovariance(){if("full"===this.covarianceMode){const t=Object(e.a)(this.dimension,this.dimension);t.data=this.covariance.slice();const i=t.pinv();this.covarianceDeterminant=i.determinant,this.inverseCovariance=i.matrix.data}else{this.covarianceDeterminant=1;for(let t=0;t<this.dimension;t+=1){if(this.covariance[t]<=0)throw new Error("Non-invertible matrix");this.inverseCovariance[t]=1/this.covariance[t],this.covarianceDeterminant*=this.covariance[t]}}this.bimodal&&this.updateInverseCovarianceBimodal()},toEllipse(t,i){if(t>=this.dimension||i>=this.dimension)throw new Error("dimensions out of range");const s={x:0,y:0,width:0,height:0,angle:0};let e,n,a;s.x=this.mean[t],s.y=this.mean[i],"full"===this.covarianceMode?(e=this.covariance[t*this.dimension+t],n=this.covariance[t*this.dimension+i],a=this.covariance[i*this.dimension+i]):(e=this.covariance[t],n=0,a=this.covariance[i]);const r=e+a,o=e*a-n*n,h=.5*(r+Math.sqrt(r**2-4*o)),u=.5*(r-Math.sqrt(r**2-4*o));return s.width=Math.sqrt(5.991*h),s.height=Math.sqrt(5.991*u),s.angle=Math.atan(n/(h-a)),Number.isNaN(s.angle)&&(s.angle=Math.PI/2),s},fromEllipse(t,i,s){if(i>=this.dimension||s>=this.dimension)throw new Error("dimensions out of range");this.mean[i]=t.x,this.mean[s]=t.y;const e=t.width*t.width/5.991,n=t.height*t.height/5.991,a=Math.tan(t.angle),r=(e-n)*a/(a**2+1),o=e-r/a,h=n+r/a;"full"===this.covarianceMode?(this.covariance[i*this.dimension+i]=h,this.covariance[i*this.dimension+s]=r,this.covariance[s*this.dimension+i]=r,this.covariance[s*this.dimension+s]=o):(this.covariance[i]=h,this.covariance[s]=o),this.updateInverseCovariance()}},a={allocateBimodal(){"full"===this.covarianceMode?this.inverseCovarianceInput=new Array(this.inputDimension**2).fill(0):this.inverseCovarianceInput=new Array(this.inputDimension).fill(0)},inputLikelihood(t){if(0===this.covarianceDeterminantInput)throw new Error("Covariance Matrix of input modality is not invertible");let i=0;if("full"===this.covarianceMode)for(let s=0;s<this.inputDimension;s+=1){let e=0;for(let i=0;i<this.inputDimension;i+=1)e+=this.inverseCovarianceInput[s*this.inputDimension+i]*(t[i]-this.mean[i]);i+=(t[s]-this.mean[s])*e}else for(let s=0;s<this.inputDimension;s+=1)i+=this.inverseCovariance[s]*(t[s]-this.mean[s])*(t[s]-this.mean[s]);let s=Math.exp(-.5*i)/Math.sqrt(this.covarianceDeterminantInput*(2*Math.PI)**this.inputDimension);return(s<1e-180||Number.isNaN(s)||Math.abs(s)===1/0)&&(s=1e-180),s},regression(t){const i=this.dimension-this.inputDimension,s=Array(i).fill(0);if("full"===this.covarianceMode)for(let e=0;e<i;e+=1){s[e]=this.mean[this.inputDimension+e];for(let i=0;i<this.inputDimension;i+=1){let n=0;for(let s=0;s<this.inputDimension;s+=1)n+=this.inverseCovarianceInput[i*this.inputDimension+s]*(t[s]-this.mean[s]);s[e]+=n*this.covariance[(e+this.inputDimension)*this.dimension+i]}}else for(let t=0;t<i;t+=1)s[t]=this.mean[this.inputDimension+t];return s},updateInverseCovarianceBimodal(){if("full"===this.covarianceMode){const t=Object(e.a)(this.inputDimension,this.inputDimension);for(let i=0;i<this.inputDimension;i+=1)for(let s=0;s<this.inputDimension;s+=1)t.data[i*this.inputDimension+s]=this.covariance[i*this.dimension+s];const i=t.pinv();this.covarianceDeterminantInput=i.determinant,this.inverseCovarianceInput=i.matrix.data}else{this.covarianceDeterminantInput=1;for(let t=0;t<this.inputDimension;t+=1){if(this.covariance[t]<=0)throw new Error("Non-invertible matrix");this.inverseCovarianceInput[t]=1/this.covariance[t],this.covarianceDeterminantInput*=this.covariance[t]}}this.updateOutputCovariance()},updateOutputCovariance(){if("diagonal"===this.covarianceMode)return void(this.outputCovariance=this.covariance.slice(0,this.inputDimension));const t=Object(e.a)(this.inputDimension,this.inputDimension);for(let i=0;i<this.inputDimension;i+=1)for(let s=0;s<this.inputDimension;s+=1)t.data[i*this.inputDimension+s]=this.covariance[i*this.dimension+s];const i=t.pinv(),s=Object(e.a)(this.inputDimension,this.outputDimension);for(let t=0;t<this.inputDimension;t+=1)for(let i=0;i<this.outputDimension;i+=1)s.data[t*this.outputDimension+i]=this.covariance[t*this.dimension+this.inputDimension+i];const n=Object(e.a)(this.outputDimension,this.inputDimension);for(let t=0;t<this.outputDimension;t+=1)for(let i=0;i<this.inputDimension;i+=1)n.data[t*this.inputDimension+i]=this.covariance[(this.inputDimension+t)*this.dimension+i];const a=i.matrix.product(s),r=n.product(a);this.outputCovariance=Array(this.outputDimension**2).fill(0);for(let t=0;t<this.outputDimension;t+=1)for(let i=0;i<this.outputDimension;i+=1)this.outputCovariance[t*this.outputDimension+i]=this.covariance[(this.inputDimension+t)*this.dimension+this.inputDimension+i]-r.data[t*this.outputDimension+i]}}},function(t,i,s){"use strict";i.a=n;const e={sum(){return this.data.reduce((t,i)=>t+i,0)},transpose(){const t=n(this.ncols,this.nrows);for(let i=0;i<this.ncols;i+=1)for(let s=0;s<this.nrows;s+=1)t.data[i*this.nrows+s]=this.data[s*this.ncols+i];return t},product(t){if(this.ncols!==t.nrows)throw new Error("Wrong dimensions for matrix product");const i=n(this.nrows,t.ncols);for(let s=0;s<this.nrows;s+=1)for(let e=0;e<t.ncols;e+=1){i.data[s*t.ncols+e]=0;for(let n=0;n<this.ncols;n+=1)i.data[s*t.ncols+e]+=this.data[s*this.ncols+n]*t.data[n*t.ncols+e]}return i},pinv(){if(this.nrows===this.ncols)return this.gaussJordanInverse();const t=this.transpose();if(this.nrows>=this.ncols){const i=t.product(this),{determinant:s,matrix:e}=i.gaussJordanInverse();return{determinant:s,matrix:e.product(t)}}const i=this.product(t),{determinant:s,matrix:e}=i.gaussJordanInverse();return{determinant:s,matrix:t.product(e)}},gaussJordanInverse(){if(this.nrows!==this.ncols)throw new Error("Gauss-Jordan inversion: Cannot invert Non-square matrix");let t=1;const i=n(this.nrows,2*this.ncols),s=n(this.nrows,2*this.ncols),e=this.nrows;for(let t=0;t<e;t+=1){for(let s=0;s<e;s+=1)i.data[2*t*e+s]=this.data[t*e+s];i.data[2*t*e+e+t]=1}for(let n=0;n<e;n+=1){let a=n;for(;Math.abs(i.data[2*a*e+n])<1e-9;)if((a+=1)===e)throw new Error("Non-invertible matrix");t*=i.data[2*a*e+n],a!==n&&i.swapLines(a,n),s.data=i.data.slice();for(let t=0;t<2*e;t+=1)s.data[2*n*e+t]/=i.data[2*n*e+n];for(let t=0;t<e;t+=1)if(t!==n)for(let a=0;a<2*e;a+=1)s.data[2*t*e+a]-=i.data[2*t*e+n]*s.data[2*n*e+a];i.data=s.data.slice()}const a=n(this.nrows,this.ncols);for(let t=0;t<e;t+=1)for(let s=0;s<e;s+=1)a.data[t*e+s]=i.data[2*t*e+e+s];return{determinant:t,matrix:a}},swapLines(t,i){for(let s=0;s<this.ncols;s+=1){const e=this.data[t*this.ncols+s];this.data[t*this.ncols+s]=this.data[i*this.ncols+s],this.data[i*this.ncols+s]=e}},swapColumns(t,i){for(let s=0;s<this.nrows;s+=1){const e=this.data[s*this.ncols+t];this.data[s*this.ncols+t]=this.data[s*this.ncols+i],this.data[s*this.ncols+i]=e}}};function n(t=0,i=-1){const s=i<0?t:i;return Object.assign(Object.create(e),{nrows:t,ncols:s,data:Array(t*s).fill(0)})}},function(t,i,s){"use strict";i.a=function(t,i){return Object.assign(t,{train(t,s){if(!t||t.empty())throw new Error("The training set is empty");s&&s.forEach(t=>{if(!this.includes(t))throw new Error(`Class labeled ${t} does not exist`)}),this.params.classes={};const e=s||t.labels();return e.forEach(s=>{const e=t.getPhrasesOfClass(s);this.params.classes[s]=i(e)}),this.params}})}},function(t,i,s){"use strict";i.a=u,i.b=function(t,i){const s=Object(h.a)(Object(o.a)(t));return s.models={},Object.keys(t.classes).forEach(e=>{s.models[e]=u(t.classes[e],i)}),s.reset(),s};var e=s(0),n=s(15),a=s(2),r=s(17),o=s(3),h=s(19);function u(t,i){const s=Object(r.a)(Object(n.a)(Object(a.a)(Object(e.a)(t)),i));return s.reset(),s}},function(t,i,s){"use strict";i.a=function(t,i=1){if(!Object(e.b)(t))throw new Error("The base object must include a standard set of parameters (`params` key), @see `ModelBase`.");const s=Object.assign({instantLikelihood:0,logLikelihood:0},t.params.bimodal?{outputValues:[],outputCovariance:[]}:{});return Object.assign(t,a(t.params.bimodal),{results:s,likelihoodBuffer:Object(n.a)(i)})};var e=s(0),n=s(16);const a=t=>({likelihoodBuffer:Object(n.a)(1),get likelihoodWindow(){return this.likelihoodBuffer.capacity},set likelihoodWindow(t){this.likelihoodBuffer=Object(n.a)(t)},reset(){this.likelihoodBuffer.clear()},predict(i){const s=this.likelihood(i);return t&&this.regression(i),this.updateResults(s),this.results},updateResults(t){this.results.instantLikelihood=t,this.likelihoodBuffer.push(Math.log(t)),this.results.logLikelihood=0;const i=this.likelihoodBuffer.length;for(let t=0;t<i;t+=1)this.results.logLikelihood+=this.likelihoodBuffer.get(t);this.results.logLikelihood/=i}})},function(t,i,s){"use strict";i.a=function(t){const i=Object.create(e);return i.capacity=t,i.clear(),i};const e={clear(){this.length=0,this.index=0,this.full=!1,this.buffer=[]},push(t){this.full?(this.buffer[this.index]=t,this.index=(this.index+1)%this.capacity):(this.buffer.push(t),this.length+=1,this.full=this.length===this.capacity)},get(t){return this.buffer[(t+this.index)%this.capacity]},fill(t){this.length=this.capacity,this.index=0,this.full=!0,this.buffer=Array(this.capacity).fill(t)},forEach(t){for(let i=0;i<this.length;i+=1)t(this.buffer[(i+this.index)%this.capacity],i)},values(){return this.buffer.slice(this.index).concat(this.buffer.slice(0,this.index))}}},function(t,i,s){"use strict";i.a=function(t){if(!Object(n.b)(t))throw new Error("The base object must include a standard set of parameters (`params` key), @see `ModelBase`.");return Object(e.a)("GMM",a(t.params.gaussians),t.params),Object.assign(t,{beta:new Array(t.params.gaussians).fill(0)})};var e=s(18),n=s(0);const a=t=>({gaussians:{required:!0,check:{min:1}},regularization:{required:!0,check:({absolute:t,relative:i})=>t&&i&&t>0&&i>0},covarianceMode:{required:!0,check:["full","diagonal"]},mixtureCoeffs:{required:!0,check:i=>i.length===t},components:{required:!0,check:i=>i.length===t}})},function(t,i,s){"use strict";i.a=function(t,i,s){const e=Object.assign({},s);return Object.keys(i).forEach(n=>{const a=i[n];if(a.required&&!Object.keys(s).includes(n))throw new Error(`Stream parameter '${n}' is required for model '${t}'.`);!function(t,i,s,e){if(s){if(s.constructor===Array&&!s.includes(e))throw new Error(`Attribute '${i}' (value: '${e}') is not allowed for model '${t}' (options: [${s}]).`);if(s.constructor===Object){if(Object.keys(s).includes("min")&&e<s.min)throw new Error(`Attribute '${i}' (value: ${e}) is inferior to the minimum required value of ${s.min} for model '${t}'.`);if(Object.keys(s).includes("max")&&e>s.max)throw new Error(`Attribute '${i}' (value: ${e}) is superior to the maximum required value of ${s.min} for model '${t}'.`)}else if("function"==typeof s&&!s(e))throw new Error(`Attribute '${i}' (value: ${e}) is incompatible with model '${t}'.`)}}(t,n,a.check,s[n]),e[n]=a.transform?a.transform(s[n]):s[n]}),e}},function(t,i,s){"use strict";i.a=function(t,i="likeliest"){if(!Object(e.b)(t))throw new Error("The base object must include a standard set of parameters (`params` key), @see `ModelBase`.");const s=Object.assign(t,a,t.params.bimodal?r:{});return s.params.multiClassRegressionEstimator=i,s};var e=s(0),n=Object.assign||function(t){for(var i=1;i<arguments.length;i++){var s=arguments[i];for(var e in s)Object.prototype.hasOwnProperty.call(s,e)&&(t[e]=s[e])}return t};const a={reset(){Object.values(this.models).forEach(t=>t.reset()),this.results={labels:[],instantLikelihoods:[],smoothedLikelihoods:[],smoothedLogLikelihoods:[],smoothedNormalizedLikelihoods:[],likeliest:null,classes:{}},this.params.bimodal&&this.resetBimodal()},predict(t){Object.values(this.models).forEach(i=>i.predict(t)),this.updateResults()},updateResults(){const t=Object.keys(this.models).sort();this.results.labels=t;let i=0,s=0,e=-1/0;this.results.classes=t.map((t,n)=>(this.results.instantLikelihoods[n]=this.models[t].results.instantLikelihood,this.results.smoothedLogLikelihoods[n]=this.models[t].results.logLikelihood,this.results.smoothedLikelihoods[n]=Math.exp(this.results.smoothedLogLikelihoods[n]),i+=this.results.instantLikelihoods[n],s+=this.results.smoothedLikelihoods[n],this.results.smoothedLogLikelihoods[n]>e&&(e=this.results.smoothedLogLikelihoods[n],this.results.likeliest=t),{[t]:this.models[t].results})).reduce((t,i)=>n({},t,i),{}),this.results.smoothedNormalizedLikelihoods=this.results.smoothedLikelihoods.map(t=>t/s),this.results.instantNormalizedLikelihoods=this.results.instantLikelihoods.map(t=>t/i),this.params.bimodal&&this.updateRegressionResults()}},r={resetBimodal(){this.results.outputValues=[],this.results.outputCovariance=[]},updateRegressionResults(){if("likeliest"===this.params.multiClassRegressionEstimator)this.results.outputValues=this.models[this.results.likeliest].results.outputValues,this.results.outputCovariance=this.models[this.results.likeliest].results.outputCovariance;else{if("mixture"!==this.params.multiClassRegressionEstimator)throw new Error("Unknown regression estimator, use `likeliest` or `mixture`");this.results.outputValues=Array(this.outputDimension).fill(0),this.results.outputCovariance=Array(this.outputDimension**("full"===this.configuration.covarianceMode?2:1)).fill(0),this.results.labels.forEach(t=>{this.results.outputValues.map((i,s)=>i+this.results.smoothedNormalizedLikelihoods[s]*this.models[t].results.outputValues[s]),this.results.outputCovariance.map((i,s)=>i+this.results.smoothedNormalizedLikelihoods[s]*this.models[t].results.outputCovariance[s])})}}}}])});
//# sourceMappingURL=mars.js.map