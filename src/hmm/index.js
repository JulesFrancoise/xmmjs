import ModelBase from '../core/model_base_mixin';
import withEMTraining from '../core/em_training_mixin';
import withHMMBase from './hmm_base_mixin';
import withHMMTraining from './hmm_training_mixin';
import MulticlassModelBase from '../core/multiclass_mixin';
import withMulticlassTraining from '../core/multiclass_training_mixin';
import withAbtractPrediction from '../core/prediction_mixin';
import withHMMPrediction from './hmm_prediction_mixin';
import withMulticlassPrediction from '../core/multiclass_prediction_mixin';
import withHierarchicalHMMPrediction from './hierarchical_hmm_prediction_mixin';

/**
 * HMM training configuration
 *
 * @typedef {Object} HMMConfiguration
 * @property {Number} states Number of Hidden States
 * @property {Number} gaussians Number of Gaussian components
 * @property {{ absolute: 1e-3, relative: 1e-2 }} regularization An object containing the
 * relative and absolute regularization values. Regularization is an offset value added to the
 * diagonal of covariance matrices for convergence and generalization. The two values represent:
 * - `relative`: the offset relative to the variance of the training data
 * - `absolute`: an absolute lower threshold for the offset
 * @property {String} covarianceMode Type of covariance matrix ('full' or 'diagonal')
 */

/**
 * @typedef {Object} HMMParameters
 * @property {Boolean} bimodal Specifies if the model is bimodal
 * @property {Number} inputDimension Dimension of the input modality
 * @property {Number} outputDimension Dimension of the output modality
 * @property {Number} dimension Total dimension
 * @property {Number} states Number of hidden states in the Markov model
 * @property {Number} gaussians Number of components in the Gaussian mixture
 * observation distribution of each state
 * @property {String} transitionMode Transition matrix mode ('ergodic' or 'leftright')
 * @property {String} covarianceMode Covariance mode ('full' or 'diagonal')
 * @property {Array<Number>} mixtureCoeffs mixture coefficients ('weight' of
 * each gaussian component)
 * @property {Array<GaussianDistribution>} components Gaussian components
 */

/**
 * Train a single-class HMM Model.
 *
 * @todo HMM details
 *
 * @param  {TrainingSet} trainingSet training set
 * @param  {HMMConfiguration} configuration Training configuration
 * @param  {ConvergenceCriteria} [convergenceCriteria=undefined] Convergence criteria of the
 * EM algorithm
 * @return {HMMParameters} Parameters of the trained HMM
 */
export function trainHMM(
  trainingSet,
  configuration,
  convergenceCriteria = undefined,
) {
  const { inputDimension, outputDimension } = trainingSet;
  const {
    states,
    gaussians,
    regularization,
    transitionMode,
    covarianceMode,
  } = configuration;
  const model = withHMMTraining(
    withEMTraining(
      withHMMBase(ModelBase({
        inputDimension,
        outputDimension,
        ...configuration,
      })),
      convergenceCriteria,
    ),
    states,
    gaussians,
    regularization,
    transitionMode,
    covarianceMode,
  );
  return model.train(trainingSet);
}

/**
 * Train a multi-class HMM Model.
 *
 * @todo HMM details
 *
 * @param  {TrainingSet} trainingSet                training set
 * @param  {HMMConfiguration} configuration                   Training configuration
 * @param  {ConvergenceCriteria} [convergenceCriteria=undefined] Convergence criteria of the
 * EM algorithm
 * @return {HMMParameters} Parameters of the trained HMM
 */
export function trainMulticlassHMM(
  trainingSet,
  configuration,
  convergenceCriteria = undefined,
) {
  const { inputDimension, outputDimension } = trainingSet;
  const model = withMulticlassTraining(
    MulticlassModelBase({ inputDimension, outputDimension, ...configuration }),
    (ts) => trainHMM(ts, configuration, convergenceCriteria),
  );
  return model.train(trainingSet);
}

/**
 * Create a HMM Predictor from a full set of parameters (generated by trainHMM).
 * @param {HMMParameters} params                       Model parameters
 * @param {number} [likelihoodWindow=1] Likelihoow window size
 * @function
 */
export function HMMPredictor(
  params,
  likelihoodWindow = 1,
) {
  const model = withHMMPrediction(withAbtractPrediction(
    withHMMBase(ModelBase(params)),
    likelihoodWindow,
  ));
  model.reset();
  return model;
}

/**
 * Create a Multiclass HMM Predictor from a full set of parameters
 * (generated by trainMulticlassHMM).
 * @param {HMMParameters} params                       Model parameters
 * @param {number} [likelihoodWindow=1] Likelihoow window size
 * @function
 */
export function MulticlassHMMPredictor(
  params,
  likelihoodWindow = 1,
) {
  const model = withMulticlassPrediction(MulticlassModelBase(params));
  model.models = {};
  Object.keys(params.classes).forEach((label) => {
    model.models[label] = HMMPredictor(params.classes[label], likelihoodWindow);
  });
  model.reset();
  return model;
}

/**
 * Create a Multiclass HMM Predictor from a full set of parameters
 * (generated by trainMulticlassHMM).
 * @param {HMMParameters} params Model parameters
 * @param {number} [likelihoodWindow=1] Likelihoow window size
 * @function
 */
export function HierarchicalHMMPredictor(
  params,
  likelihoodWindow = 1,
) {
  let model = MulticlassModelBase(params);
  model.models = {};
  Object.keys(params.classes).forEach((label) => {
    model.models[label] = HMMPredictor(params.classes[label], likelihoodWindow);
  });
  model = withHierarchicalHMMPrediction(withMulticlassPrediction(model));
  model.reset();
  return model;
}
