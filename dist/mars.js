!function(t,s){"object"==typeof exports&&"object"==typeof module?module.exports=s():"function"==typeof define&&define.amd?define([],s):"object"==typeof exports?exports.mars=s():t.mars=s()}("undefined"!=typeof self?self:this,function(){return function(t){var s={};function i(e){if(s[e])return s[e].exports;var n=s[e]={i:e,l:!1,exports:{}};return t[e].call(n.exports,n,n.exports,i),n.l=!0,n.exports}return i.m=t,i.c=s,i.d=function(t,s,e){i.o(t,s)||Object.defineProperty(t,s,{configurable:!1,enumerable:!0,get:e})},i.n=function(t){var s=t&&t.__esModule?function(){return t.default}:function(){return t};return i.d(s,"a",s),s},i.o=function(t,s){return Object.prototype.hasOwnProperty.call(t,s)},i.p="",i(i.s=4)}([function(t,s,i){"use strict";s.a=function(t){let{inputDimension:s,outputDimension:i}=t;const n=function(t,s){var i={};for(var e in t)s.indexOf(e)>=0||Object.prototype.hasOwnProperty.call(t,e)&&(i[e]=t[e]);return i}(t,["inputDimension","outputDimension"]);return delete n.bimodal,delete n.inputDimension,delete n.outputDimension,delete n.dimension,{params:e({},n,{get bimodal(){return i>0},get inputDimension(){return s},get outputDimension(){return i},get dimension(){return s+i}})}},s.b=function(t){if(!Object.keys(t).includes("params"))return!1;return["bimodal","inputDimension","outputDimension","dimension"].map(s=>Object.keys(t.params).includes(s)).reduce((t,s)=>t&&s,!0)};var e=Object.assign||function(t){for(var s=1;s<arguments.length;s++){var i=arguments[s];for(var e in i)Object.prototype.hasOwnProperty.call(i,e)&&(t[e]=i[e])}return t}},function(t,s,i){"use strict";s.a=function(t,s,i={}){if(!Object(e.b)(t))throw new Error("The base object must include a standard set of parameters (`params` key), @see `ModelBase`.");const n=Object.assign({initialization:"random",relativeDistanceThreshold:.001,minIterations:5,maxIterations:100},i),r=Object.assign(t,a,{trainingConfig:n});return r.params.clusters=s,r};var e=i(0),n=i(8);const a={train(t){if(!t||t.empty())throw new Error("The training set is empty");if(this.params.centers=Array.from(Array(this.params.clusters),()=>new Array(this.params.dimension).fill(0)),"random"===this.trainingConfig.initialization)this.initializeClustersRandom(t);else if("forgy"===this.trainingConfig.initialization)this.initializeClustersForgy(t);else{if("data"!==this.trainingConfig.initialization)throw new Error("Unknown K-Means initialization, must be `random`, `forgy` or `data`");this.initClustersWithFirstPhrase(t)}for(let s=0;s<this.trainingConfig.maxIterations;s+=1){const s=this.params.centers;this.updateCenters(s,t);let i=0,e=0;for(let t=0;t<this.params.clusters;t+=1){for(let s=0;s<this.params.clusters;s+=1)t!==s&&(i+=Object(n.a)(this.params.centers[t],this.params.centers[s]));e=Math.max(Object(n.a)(s[t],this.params.centers[t]),e)}if(i/=this.params.clusters*(this.params.clusters-1),e/=this.params.clusters,(e/=i)<this.trainingConfig.relativeDistanceThreshold)break}return this.params},initClustersWithFirstPhrase(t){const s=t.getPhrase(t.indices()[0]),i=Math.floor(s.length/this.params.clusters);let e=0;for(let t=0;t<this.params.clusters;t+=1){this.params.centers[t]=new Array(this.params.dimension).fill(0);for(let n=0;n<i;n+=1)for(let a=0;a<this.params.dimension;a+=1)this.params.centers[t][a]+=s.get(e+n,a)/i;e+=i}},initializeClustersRandom(t){const s=t.getPhrase(t.indices()[0]),i=Array.from(Array(s.length),()=>Math.floor(Math.random()*this.params.clusters)),e=i.reduce((t,s)=>{const i=t;return i[s]+=1,i},Array(this.params.clusters).fill(0));for(let t=0;t<i.length;t+=1){const e=i[t];for(let i=0;i<this.params.dimension;i+=1)this.params.centers[e][i]+=s.get(t,i)}this.params.centers.forEach((t,s)=>{this.params.centers[s]=this.params.centers[s].map(t=>t/e[s])})},initializeClustersForgy(t){const s=t.getPhrase(t.indices()[0]),i=Array.from(Array(this.params.clusters),()=>Math.floor(Math.random()*s.length));this.params.centers=i.map(t=>s.getFrame(t))},updateCenters(t,s){this.params.centers=Array.from(Array(this.params.clusters),()=>new Array(this.params.dimension).fill(0));const i=Array(this.params.clusters).fill(0);s.forEach(s=>{for(let e=0;e<s.length;e+=1){const a=s.getFrame(e);let r=Object(n.a)(a,t[0]),o=0;for(let s=1;s<this.params.clusters;s+=1){const i=Object(n.a)(a,t[s],this.params.dimension);i<r&&(o=s,r=i)}i[o]+=1;for(let t=0;t<this.params.dimension;t+=1)this.params.centers[o][t]+=s.get(e,t)}});for(let t=0;t<this.params.clusters;t+=1)if(i[t]>0)for(let s=0;s<this.params.dimension;s+=1)this.params.centers[t][s]/=i[t]}}},function(t,s,i){"use strict";s.a=function(t){if(!Object(e.b)(t))throw new Error("The base object must include a standard set of parameters (`params` key), @see `ModelBase`.");return Object.assign(t,n,t.params.bimodal?a:{})};var e=i(0);const n={likelihood(t){let s=0;for(let i=0;i<this.params.gaussians;i+=1)this.beta[i]=this.componentLikelihood(t,i),s+=this.beta[i];for(let t=0;t<this.params.gaussians;t+=1)this.beta[t]/=s;return s},componentLikelihood(t,s){if(s>=this.params.gaussians)throw new Error("The index of the Gaussian Mixture Component is out of bounds");return this.params.mixtureCoeffs[s]*this.params.components[s].likelihood(t)}},a={regression(t){this.results.outputValues=Array(this.outputDimension).fill(0),this.results.outputCovariance=Array("full"===this.covarianceMode?this.outputDimension**2:this.outputDimension).fill(0);const s=Array(this.outputDimension).fill(0);for(let i=0;i<this.params.gaussians;i+=1){this.params.components[i].regression(t,s);for(let t=0;t<this.outputDimension;t+=1)if(this.results.outputValues[t]+=this.beta[i]*s[t],"full"===this.covarianceMode)for(let s=0;s<this.outputDimension;s+=1)this.results.outputCovariance[t*this.outputDimension+s]+=this.beta[i]**2*this.params.components[i].outputCovariance[t*this.outputDimension+s];else this.results.outputCovariance[t]+=this.beta[i]**2*this.params.components[i].outputCovariance[t]}return this.results.outputValues}}},function(t,s,i){"use strict";s.a=function(t){let{inputDimension:s,outputDimension:i}=t,r=function(t,s){var i={};for(var e in t)s.indexOf(e)>=0||Object.prototype.hasOwnProperty.call(t,e)&&(i[e]=t[e]);return i}(t,["inputDimension","outputDimension"]);return Object.assign(Object(e.a)(n({inputDimension:s,outputDimension:i},r)),a)};var e=i(0),n=Object.assign||function(t){for(var s=1;s<arguments.length;s++){var i=arguments[s];for(var e in i)Object.prototype.hasOwnProperty.call(i,e)&&(t[e]=i[e])}return t};const a={size(){return this.models.size},includes(t){return Object.keys(this.models).includes(t)},remove(t){this.includes(t)&&delete this.models[t]}}},function(t,s,i){"use strict";Object.defineProperty(s,"__esModule",{value:!0});var e=i(5);i.d(s,"TrainingSet",function(){return e.a});var n=i(7);i.d(s,"trainKmeans",function(){return n.b}),i.d(s,"trainGMM",function(){return n.a}),i.d(s,"trainMulticlassGMM",function(){return n.c});var a=i(15);i.d(s,"GMMPredictor",function(){return a.a}),i.d(s,"multiclassGMMPredictor",function(){return a.b})},function(t,s,i){"use strict";var e=i(6),n=Object.assign||function(t){for(var s=1;s<arguments.length;s++){var i=arguments[s];for(var e in i)Object.prototype.hasOwnProperty.call(i,e)&&(t[e]=i[e])}return t};class a{constructor({inputDimension:t=1,outputDimension:s=0,columnNames:i=null}={}){this.bimodal=s>0,this.inputDimension=t,this.outputDimension=s,this.dimension=t+s,this.columnNames=i||Array(this.dimension).fill(""),this.phrases={}}size(){return Object.keys(this.phrases).length}empty(){return 0===this.length}getPhrase(t){return Object.keys(this.phrases).includes(t.toString())?this.phrases[t.toString()]:null}forEach(t){Object.keys(this.phrases).forEach(s=>{t(this.phrases[s],s,this.phrases)})}push(t,s,i){this.phrases[t]=void 0!==i?i:new e.a({inputDimension:this.inputDimension,outputDimension:this.outputDimension,columnNames:this.columnNames,label:void 0!==s?s:t.toString()})}remove(t){delete this.phrases[t]}removeClass(t){this.phrases=Object.keys(this.phrases).filter(s=>this.phrases[s].label!==t).map(t=>({i:this.phrases[t]})).reduce((t,s)=>n({},t,s),{})}clear(){this.phrases={}}getPhrasesOfClass(t){const s=new a(this);return s.phrases=Object.keys(this.phrases).filter(s=>this.phrases[s].label===t).map(t=>({i:this.phrases[t]})).reduce((t,s)=>n({},t,s),{}),s}labels(){return Object.keys(this.phrases).map(t=>this.phrases[t].label).reduce((t,s)=>t.includes(s)?t:t.concat([s]),[])}indices(){return Object.keys(this.phrases)}mean(){const t=Array(this.dimension).fill(0);let s=0;return Object.keys(this.phrases).forEach(i=>{for(let s=0;s<this.dimension;s+=1)for(let e=0;e<this.phrases[i].length;e+=1)t[s]+=this.phrases[i].get(e,s);s+=this.phrases[i].length}),t.map(t=>t/s)}standardDeviation(){const t=Array(this.dimension).fill(0),s=this.mean();let i=0;return Object.keys(this.phrases).forEach(e=>{for(let i=0;i<this.dimension;i+=1)for(let n=0;n<this.phrases[e].length;n+=1)t[i]+=(this.phrases[e].get(n,i)-s[i])**2;i+=this.phrases[e].length}),t.map(t=>Math.sqrt(t/i))}minmax(){const t=Array.from(Array(this.dimension),()=>({min:1/0,max:-1/0}));return Object.keys(this.phrases).forEach(s=>{for(let i=0;i<this.dimension;i+=1)for(let e=0;e<this.phrases[s].length;e+=1)t[i].min+=Math.min(t[i].min,this.phrases[s].get(e,i)),t[i].max+=Math.max(t[i].max,this.phrases[s].get(e,i))}),t}}s.a=a},function(t,s,i){"use strict";s.a=class{constructor({inputDimension:t=1,outputDimension:s=0,columnNames:i=null,label:e=""}={}){this.bimodal=s>0,this.inputDimension=t,this.outputDimension=s,this.dimension=t+s,this.length=0,this.label=e,this.inputData=[],this.outputData=[],this.columnNames=i||Array(this.dimension).fill("")}get(t,s){if("number"!=typeof t||Math.floor(t)!==t)throw new Error("The index must be an integer");if(s>=this.dimension)throw new Error("Phrase: dimension out of bounds");if(this.bimodal){if(s<this.inputDimension){if(t>=this.inputData.length)throw new Error("Phrase: index out of bounds");return this.inputData[t][s]}if(t>=this.outputData.length)throw new Error("Phrase: index out of bounds");return this.outputData[t][s-this.inputDimension]}if(t>=this.length)throw new Error("Phrase: index out of bounds");if(!this.inputData[t])throw new Error("WTF?");return this.inputData[t][s]}getFrame(t){if(t>=this.length)throw new Error("Phrase: index out of bounds");return this.bimodal?this.inputData[t].concat(this.outputData[t]):this.inputData[t]}push(t){if(t.length!==this.dimension)throw new Error("Observation has wrong dimension");this.bimodal?(this.inputData.push(t.slice(0,this.inputDimension)),this.outputData.push(t.slice(this.inputDimension,this.dimension))):this.inputData.push(t),this.length+=1}pushInput(t){if(!this.bimodal)throw new Error("this phrase is unimodal, use `push`");if(t.size()!==this.inputDimension)throw new Error("Observation has wrong dimension");this.inputData.push(t),this.trim()}pushOutput(t){if(!this.bimodal)throw new Error("this phrase is unimodal, use `push`");if(t.size()!==this.outputDimension)throw new Error("Observation has wrong dimension");this.outputData.push(t),this.trim()}clear(){this.length=0,this.inputData=[],this.outputData=[]}clearInput(){this.inputData=[],this.trim()}clearOutput(){this.outputData=[],this.trim()}mean(){const t=Array(this.dimension).fill(0);for(let s=0;s<this.dimension;s+=1){for(let i=0;i<this.length;i+=1)t[s]+=this.get(i,s);t[s]/=this.length}return t}standardDeviation(){const t=Array(this.dimension).fill(0),s=this.mean();for(let i=0;i<this.dimension;i+=1){for(let e=0;e<this.length;e+=1)t[i]+=(this.get(e,i)-s[i])*(this.get(e,i)-s[i]);t[i]/=this.length,t[i]=Math.sqrt(t[i])}return t}minmax(){const t=Array.from(Array(this.dimension),()=>({min:1/0,max:-1/0}));for(let s=0;s<this.dimension;s+=1)for(let i=0;i<this.length;i+=1)t[s].min=Math.min(this.get(i,s),t[s].min),t[s].max=Math.max(this.get(i,s),t[s].max);return t}trim(){this.bimodal&&(this.length=Math.min(this.inputData.length,this.outputData.length))}}},function(t,s,i){"use strict";s.b=function(t,s,i){const{inputDimension:a,outputDimension:r}=t;return Object(n.a)(Object(e.a)({inputDimension:a,outputDimension:r}),s,i).train(t)},s.a=c,s.c=function(t,s,i){const{inputDimension:e,outputDimension:n}=t;return Object(u.a)(Object(h.a)(l({inputDimension:e,outputDimension:n},s)),t=>c(t,s,i)).train(t)};var e=i(0),n=i(1),a=i(9),r=i(2),o=i(10),h=i(3),u=i(14),l=Object.assign||function(t){for(var s=1;s<arguments.length;s++){var i=arguments[s];for(var e in i)Object.prototype.hasOwnProperty.call(i,e)&&(t[e]=i[e])}return t};function c(t,s,i){const{inputDimension:n,outputDimension:h}=t,{gaussians:u,regularization:c,covarianceMode:m}=s;return Object(o.a)(Object(a.a)(Object(r.a)(Object(e.a)(l({inputDimension:n,outputDimension:h},s))),i),u,c,m).train(t)}},function(t,s,i){"use strict";s.a=function(t,s){return Math.sqrt(t.map((t,i)=>(t-s[i])**2).reduce((t,s)=>t+s,0))}},function(t,s,i){"use strict";s.a=function(t,s={percentChange:.001,minIterations:5,maxIterations:100}){return Object.assign(t,e,{convergenceCriteria:s})};const e={train(t){if(!t||t.empty())throw new Error("The training set is empty");this.initTraining(t);let s=-1/0,i=0,e=s;for(;!this.converged(i,s,e);){e=s,s=this.updateTraining(t);const n=100*Math.abs((s-e)/e);if(Number.isNaN(n)&&i>1)throw new Error("An error occured during training");i+=1}return this.terminateTraining(),this.params},converged(t,s,i){if(t>=this.convergenceCriteria.maxIterations)return!0;if(this.convergenceCriteria.maxIterations>=this.convergenceCriteria.minIterations)return t>=this.convergenceCriteria.maxIterations;if(t<this.convergenceCriteria.minIterations)return!1;return 100*Math.abs((s-i)/s)<=this.convergenceCriteria.percentChange}}},function(t,s,i){"use strict";s.a=function(t,s=1,i={absolute:.001,relative:.01},e="full"){if(!Object.keys(t).includes("params"))throw new Error("The base object must include a standard set of parameters (`params` key), @see `ModelBase`.");return Object.assign(t,o,{params:r({},t.params,{gaussians:s,regularization:i,covarianceMode:e})})};var e=i(0),n=i(1),a=i(11),r=Object.assign||function(t){for(var s=1;s<arguments.length;s++){var i=arguments[s];for(var e in i)Object.prototype.hasOwnProperty.call(i,e)&&(t[e]=i[e])}return t};const o={initTraining(t){this.allocate(),this.initParametersToDefault(t.standardDeviation()),this.initMeansWithKMeans(t),this.initCovariances(t),this.addCovarianceOffset(),this.updateInverseCovariances()},allocate(){this.params.components=Array.from(Array(this.params.gaussians),()=>new a.a(this.params.inputDimension,this.params.outputDimension,this.params.covarianceMode)),this.params.mixtureCoeffs=Array(this.params.gaussians).fill(0),this.beta=Array(this.params.gaussians).fill(0)},initParametersToDefault(t){let s=0;this.currentRegularization=t.map(t=>Math.max(this.params.regularization.absolute,this.params.regularization.relative*t));for(let t=0;t<this.params.gaussians;t+=1)"full"===this.params.covarianceMode?this.params.components[t].covariance=Array(this.params.dimension**2).fill(this.params.regularization.absolute/2):this.params.components[t].covariance=Array(this.params.dimension).fill(0),this.params.components[t].regularize(this.currentRegularization),this.params.mixtureCoeffs[t]=1/this.params.gaussians,s+=this.params.mixtureCoeffs[t];for(let t=0;t<this.params.gaussians;t+=1)this.params.mixtureCoeffs[t]/=s},initMeansWithKMeans(t){if(!t||t.empty())return;const s=Object(n.a)(Object(e.a)({inputDimension:this.params.inputDimension,outputDimension:this.params.outputDimension}),this.params.gaussians,{initialization:"random"}).train(t);for(let t=0;t<this.params.gaussians;t+=1)this.params.components[t].mean=s.centers[t]},initCovariances(t){if(!t||t.empty())return;for(let t=0;t<this.params.gaussians;t+=1)this.params.components[t].covariance=Array("full"===this.params.covarianceMode?this.params.dimension**2:this.params.dimension).fill(0);const s=Array(this.params.gaussians*this.params.dimension).fill(0),i=Array(this.params.gaussians).fill(0);t.forEach(t=>{const e=Math.floor(t.length/this.params.gaussians);let n=0;for(let a=0;a<this.params.gaussians;a+=1){for(let i=0;i<e;i+=1)for(let e=0;e<this.params.dimension;e+=1)if(s[a*this.params.dimension+e]+=t.get(n+i,e),"full"===this.params.covarianceMode)for(let s=0;s<this.params.dimension;s+=1)this.params.components[a].covariance[e*this.params.dimension+s]+=t.get(n+i,e)*t.get(n+i,s);else this.params.components[a].covariance[e]+=t.get(n+i,e)**2;n+=e,i[a]+=e}});for(let t=0;t<this.params.gaussians;t+=1)for(let e=0;e<this.params.dimension;e+=1)if(s[t*this.params.dimension+e]/=i[t],"full"===this.params.covarianceMode)for(let s=0;s<this.params.dimension;s+=1)this.params.components[t].covariance[e*this.params.dimension+s]/=i[t];else this.params.components[t].covariance[e]/=i[t];for(let t=0;t<this.params.gaussians;t+=1)for(let i=0;i<this.params.dimension;i+=1)if("full"===this.params.covarianceMode)for(let e=0;e<this.params.dimension;e+=1)this.params.components[t].covariance[i*this.params.dimension+e]-=s[t*this.params.dimension+i]*s[t*this.params.dimension+e];else this.params.components[t].covariance[i]-=s[t*this.params.dimension+i]**2},addCovarianceOffset(){this.params.components.forEach(t=>{t.regularize(this.currentRegularization)})},updateInverseCovariances(){this.params.components.forEach(t=>{t.updateInverseCovariance()});try{this.params.components.forEach(t=>{t.updateInverseCovariance()})}catch(t){throw new Error("Matrix inversion error: varianceoffset must be too small")}},updateTraining(t){let s=0,i=0;t.forEach(t=>{i+=t.length});const e=Object.keys(t.phrases),n=Array.from(Array(this.params.gaussians),()=>new Array(i).fill(0)),a=Array(this.params.gaussians).fill(0);let r=0;t.forEach(t=>{for(let i=0;i<t.length;i+=1){let e=0;for(let s=0;s<this.params.gaussians;s+=1)n[s][r+i]=this.componentLikelihood(t.getFrame(i),s),(0===n[s][r+i]||Number.isNaN(n[s][r+i])||n[s][r+i]===1/0)&&(n[s][r+i]=1e-100),e+=n[s][r+i];for(let t=0;t<this.params.gaussians;t+=1)n[t][r+i]/=e,a[t]+=n[t][r+i];s+=Math.log(e)}r+=t.length});for(let t=0;t<this.params.gaussians;t+=1)this.params.mixtureCoeffs[t]=a[t]/i;for(let s=0;s<this.params.gaussians;s+=1)for(let i=0;i<this.params.dimension;i+=1){this.params.components[s].mean[i]=0,r=0;for(let a=0;a<e.length;a+=1){const o=t.phrases[e[a]];for(let t=0;t<o.length;t+=1)this.params.components[s].mean[i]+=n[s][r+t]*o.get(t,i);r+=o.length}this.params.components[s].mean[i]/=a[s]}if("full"===this.params.covarianceMode)for(let s=0;s<this.params.gaussians;s+=1)for(let i=0;i<this.params.dimension;i+=1)for(let o=i;o<this.params.dimension;o+=1){this.params.components[s].covariance[i*this.params.dimension+o]=0,r=0;for(let a=0;a<e.length;a+=1){const h=t.phrases[e[a]];for(let t=0;t<h.length;t+=1)this.params.components[s].covariance[i*this.params.dimension+o]+=n[s][r+t]*(h.get(t,i)-this.params.components[s].mean[i])*(h.get(t,o)-this.params.components[s].mean[o]);r+=h.length}this.params.components[s].covariance[i*this.params.dimension+o]/=a[s],i!==o&&(this.params.components[s].covariance[o*this.params.dimension+i]=this.params.components[s].covariance[i*this.params.dimension+o])}else for(let s=0;s<this.params.gaussians;s+=1)for(let i=0;i<this.params.dimension;i+=1){this.params.components[s].covariance[i]=0,r=0;for(let a=0;a<e.length;a+=1){const o=t.phrases[e[a]];for(let t=0;t<o.length;t+=1){const e=o.get(t,i)-this.params.components[s].mean[i];this.params.components[s].covariance[i]+=n[s][r+t]*e*e}r+=o.length}this.params.components[s].covariance[i]/=a[s]}return this.addCovarianceOffset(),this.updateInverseCovariances(),s},normalizeMixtureCoeffs(){let t=0;for(let s=0;s<this.params.gaussians;s+=1)t+=this.params.mixtureCoeffs[s];if(t>0)for(let s=0;s<this.params.gaussians;s+=1)this.params.mixtureCoeffs[s]/=t;else for(let t=0;t<this.params.gaussians;t+=1)this.params.mixtureCoeffs[t]=1/this.params.gaussians},terminateTraining(){}}},function(t,s,i){"use strict";s.a=function(t=1,s=0,i="full"){const e=s>0,n=t+s,o=e?Object.assign({},a,r):a,h=Object.assign({bimodal:e,dimension:n,inputDimension:t,outputDimension:s,covarianceMode:i,covarianceDeterminant:0},e?{covarianceDeterminantInput:0}:{}),u=Object.assign(Object.create(o),h);return u.allocate(),u};var e=i(12),n=i(13);const a={allocate(){this.mean=new Array(this.dimension).fill(0),"full"===this.covarianceMode?(this.covariance=new Array(this.dimension**2).fill(0),this.inverseCovariance=new Array(this.dimension**2).fill(0)):(this.covariance=new Array(this.dimension).fill(0),this.inverseCovariance=new Array(this.dimension).fill(0)),this.bimodal&&this.allocateBimodal()},likelihood(t){if(0===this.covarianceDeterminant)throw new Error("Covariance Matrix is not invertible");if(this.bimodal&&t.length===this.inputDimension)return this.inputLikelihood(t);if(t.length!==this.dimension)throw new Error(`GaussianDistribution: observation has wrong dimension. Expected \`${this.dimension}\`, got \`${t.length}\``);let s=0;if("full"===this.covarianceMode)for(let i=0;i<this.dimension;i+=1){let e=0;for(let s=0;s<this.dimension;s+=1)e+=this.inverseCovariance[i*this.dimension+s]*(t[s]-this.mean[s]);s+=(t[i]-this.mean[i])*e}else for(let i=0;i<this.dimension;i+=1)s+=this.inverseCovariance[i]*(t[i]-this.mean[i])*(t[i]-this.mean[i]);let i=Math.exp(-.5*s)/Math.sqrt(this.covarianceDeterminant*(2*Math.PI)**this.dimension);return(i<1e-180||Number.isNaN(i)||Math.abs(i)===1/0)&&(i=1e-180),i},regularize(t){if("full"===this.covarianceMode)for(let s=0;s<this.dimension;s+=1)this.covariance[s*this.dimension+s]+=t[s];else for(let s=0;s<this.dimension;s+=1)this.covariance[s]+=t[s]},updateInverseCovariance(){if("full"===this.covarianceMode){const t=Object(e.a)(this.dimension,this.dimension);t.data=this.covariance.slice();const s=t.pinv();this.covarianceDeterminant=s.determinant,this.inverseCovariance=s.matrix.data}else{this.covarianceDeterminant=1;for(let t=0;t<this.dimension;t+=1){if(this.covariance[t]<=0)throw new Error("Non-invertible matrix");this.inverseCovariance[t]=1/this.covariance[t],this.covarianceDeterminant*=this.covariance[t]}}this.bimodal&&this.updateInverseCovarianceBimodal()},toEllipse(t,s){if(t>=this.dimension||s>=this.dimension)throw new Error("dimensions out of range");const i=Object(n.a)();let e,a,r;i.x=this.mean[t],i.y=this.mean[s],"full"===this.covarianceMode?(e=this.covariance[t*this.dimension+t],a=this.covariance[t*this.dimension+s],r=this.covariance[s*this.dimension+s]):(e=this.covariance[t],a=0,r=this.covariance[s]);const o=e+r,h=e*r-a*a,u=.5*(o+Math.sqrt(o**2-4*h)),l=.5*(o-Math.sqrt(o**2-4*h));return i.width=Math.sqrt(5.991*u),i.height=Math.sqrt(5.991*l),i.angle=Math.atan(a/(u-r)),Number.isNaN(i.angle)&&(i.angle=Math.PI/2),i},fromEllipse(t,s,i){if(s>=this.dimension||i>=this.dimension)throw new Error("dimensions out of range");this.mean[s]=t.x,this.mean[i]=t.y;const e=t.width*t.width/5.991,n=t.height*t.height/5.991,a=Math.tan(t.angle),r=(e-n)*a/(a**2+1),o=e-r/a,h=n+r/a;"full"===this.covarianceMode?(this.covariance[s*this.dimension+s]=h,this.covariance[s*this.dimension+i]=r,this.covariance[i*this.dimension+s]=r,this.covariance[i*this.dimension+i]=o):(this.covariance[s]=h,this.covariance[i]=o),this.updateInverseCovariance()}},r={allocateBimodal(){"full"===this.covarianceMode?this.inverseCovarianceInput=new Array(this.inputDimension**2).fill(0):this.inverseCovarianceInput=new Array(this.inputDimension).fill(0)},inputLikelihood(t){if(0===this.covarianceDeterminantInput)throw new Error("Covariance Matrix of input modality is not invertible");let s=0;if("full"===this.covarianceMode)for(let i=0;i<this.inputDimension;i+=1){let e=0;for(let s=0;s<this.inputDimension;s+=1)e+=this.inverseCovarianceInput[i*this.inputDimension+s]*(t[s]-this.mean[s]);s+=(t[i]-this.mean[i])*e}else for(let i=0;i<this.inputDimension;i+=1)s+=this.inverseCovariance[i]*(t[i]-this.mean[i])*(t[i]-this.mean[i]);let i=Math.exp(-.5*s)/Math.sqrt(this.covarianceDeterminantInput*(2*Math.PI)**this.inputDimension);return(i<1e-180||Number.isNaN(i)||Math.abs(i)===1/0)&&(i=1e-180),i},regression(t){const s=this.dimension-this.inputDimension,i=Array(s).fill(0);if("full"===this.covarianceMode)for(let e=0;e<s;e+=1){i[e]=this.mean[this.inputDimension+e];for(let s=0;s<this.inputDimension;s+=1){let n=0;for(let i=0;i<this.inputDimension;i+=1)n+=this.inverseCovarianceInput[s*this.inputDimension+i]*(t[i]-this.mean[i]);i[e]+=n*this.covariance[(e+this.inputDimension)*this.dimension+s]}}else for(let t=0;t<s;t+=1)i[t]=this.mean[this.inputDimension+t];return i},updateInverseCovarianceBimodal(){if("full"===this.covarianceMode){const t=Object(e.a)(this.inputDimension,this.inputDimension);for(let s=0;s<this.inputDimension;s+=1)for(let i=0;i<this.inputDimension;i+=1)t.data[s*this.inputDimension+i]=this.covariance[s*this.dimension+i];const s=t.pinv();this.covarianceDeterminantInput=s.determinant,this.inverseCovarianceInput=s.matrix.data}else{this.covarianceDeterminantInput=1;for(let t=0;t<this.inputDimension;t+=1){if(this.covariance[t]<=0)throw new Error("Non-invertible matrix");this.inverseCovarianceInput[t]=1/this.covariance[t],this.covarianceDeterminantInput*=this.covariance[t]}}this.updateOutputCovariance()},updateOutputCovariance(){if("diagonal"===this.covarianceMode)return void(this.outputCovariance=this.covariance.slice(0,this.inputDimension));const t=Object(e.a)(this.inputDimension,this.inputDimension);for(let s=0;s<this.inputDimension;s+=1)for(let i=0;i<this.inputDimension;i+=1)t.data[s*this.inputDimension+i]=this.covariance[s*this.dimension+i];const s=t.pinv(),i=Object(e.a)(this.inputDimension,this.outputDimension);for(let t=0;t<this.inputDimension;t+=1)for(let s=0;s<this.outputDimension;s+=1)i.data[t*this.outputDimension+s]=this.covariance[t*this.dimension+this.inputDimension+s];const n=Object(e.a)(this.outputDimension,this.inputDimension);for(let t=0;t<this.outputDimension;t+=1)for(let s=0;s<this.inputDimension;s+=1)n.data[t*this.inputDimension+s]=this.covariance[(this.inputDimension+t)*this.dimension+s];const a=s.matrix.product(i),r=n.product(a);this.outputCovariance=Array(this.outputDimension**2).fill(0);for(let t=0;t<this.outputDimension;t+=1)for(let s=0;s<this.outputDimension;s+=1)this.outputCovariance[t*this.outputDimension+s]=this.covariance[(this.inputDimension+t)*this.dimension+this.inputDimension+s]-r.data[t*this.outputDimension+s]}}},function(t,s,i){"use strict";s.a=n;const e={sum(){return this.data.reduce((t,s)=>t+s,0)},print(){for(let t=0;t<this.nrows;t+=1){let s="";for(let i=0;i<this.ncols;i+=1)s+=`${this.data[t*this.ncols+i]} `.padStart(10);console.log(s)}},transpose(){const t=n(this.ncols,this.nrows);for(let s=0;s<this.ncols;s+=1)for(let i=0;i<this.nrows;i+=1)t.data[s*this.nrows+i]=this.data[i*this.ncols+s];return t},product(t){if(this.ncols!==t.nrows)throw new Error("Wrong dimensions for matrix product");const s=n(this.nrows,t.ncols);for(let i=0;i<this.nrows;i+=1)for(let e=0;e<t.ncols;e+=1){s.data[i*t.ncols+e]=0;for(let n=0;n<this.ncols;n+=1)s.data[i*t.ncols+e]+=this.data[i*this.ncols+n]*t.data[n*t.ncols+e]}return s},pinv(){if(this.nrows===this.ncols)return this.gaussJordanInverse();const t=this.transpose();if(this.nrows>=this.ncols){const s=t.product(this),{determinant:i,matrix:e}=s.gaussJordanInverse();return{determinant:i,matrix:e.product(t)}}const s=this.product(t),{determinant:i,matrix:e}=s.gaussJordanInverse();return{determinant:i,matrix:t.product(e)}},gaussJordanInverse(){if(this.nrows!==this.ncols)throw new Error("Gauss-Jordan inversion: Cannot invert Non-square matrix");let t=1;const s=n(this.nrows,2*this.ncols),i=n(this.nrows,2*this.ncols),e=this.nrows;for(let t=0;t<e;t+=1){for(let i=0;i<e;i+=1)s.data[2*t*e+i]=this.data[t*e+i];s.data[2*t*e+e+t]=1}for(let n=0;n<e;n+=1){let a=n;for(;Math.abs(s.data[2*a*e+n])<1e-9;)if((a+=1)===e)throw new Error("Non-invertible matrix");t*=s.data[2*a*e+n],a!==n&&s.swapLines(a,n),i.data=s.data.slice();for(let t=0;t<2*e;t+=1)i.data[2*n*e+t]/=s.data[2*n*e+n];for(let t=0;t<e;t+=1)if(t!==n)for(let a=0;a<2*e;a+=1)i.data[2*t*e+a]-=s.data[2*t*e+n]*i.data[2*n*e+a];s.data=i.data.slice()}const a=n(this.nrows,this.ncols);for(let t=0;t<e;t+=1)for(let i=0;i<e;i+=1)a.data[t*e+i]=s.data[2*t*e+e+i];return{determinant:t,matrix:a}},swapLines(t,s){for(let i=0;i<this.ncols;i+=1){const e=this.data[t*this.ncols+i];this.data[t*this.ncols+i]=this.data[s*this.ncols+i],this.data[s*this.ncols+i]=e}},swapColumns(t,s){for(let i=0;i<this.nrows;i+=1){const e=this.data[i*this.ncols+t];this.data[i*this.ncols+t]=this.data[i*this.ncols+s],this.data[i*this.ncols+s]=e}}};function n(t=0,s=-1){const i=s<0?t:s;return Object.assign(Object.create(e),{nrows:t,ncols:i,data:Array(t*i).fill(0)})}},function(t,s,i){"use strict";function e(){return{x:0,y:0,width:0,height:0,angle:0,x:0,y:0}}s.a=e},function(t,s,i){"use strict";s.a=function(t,s){return Object.assign(t,{train(t,i){if(!t||t.empty())throw new Error("The training set is empty");i&&i.forEach(t=>{if(!this.includes(t))throw new Error(`Class labeled ${t} does not exist`)}),this.params.classes={};const e=i||t.labels();return e.forEach(i=>{const e=t.getPhrasesOfClass(i);this.params.classes[i]=s(e)}),this.params}})}},function(t,s,i){"use strict";s.a=u,s.b=function(t,s){const i=Object(h.a)(Object(o.a)(t));return i.models={},Object.keys(t.classes).forEach(e=>{i.models[e]=u(t.classes[e],s)}),i.reset(),i};var e=i(0),n=i(16),a=i(2),r=i(18),o=i(3),h=i(19);function u(t,s){const i=Object(r.a)(Object(n.a)(Object(a.a)(Object(e.a)(t)),s));return i.allocate(),i}},function(t,s,i){"use strict";s.a=function(t,s=1){if(!Object(e.b)(t))throw new Error("The base object must include a standard set of parameters (`params` key), @see `ModelBase`.");const i=Object.assign({instantLikelihood:0,logLikelihood:0},t.params.bimodal?{outputValues:[],outputCovariance:[]}:{});return Object.assign(t,a(t.params.bimodal),{results:i,likelihoodBuffer:new n.a(s)})};var e=i(0),n=i(17);const a=t=>({likelihoodBuffer:new n.a(1),get likelihoodWindow(){return this.likelihoodBuffer.capacity},set likelihoodWindow(t){this.likelihoodBuffer=new n.a(t)},reset(){this.likelihoodBuffer.clear()},predict(s){const i=this.likelihood(s);return t&&this.regression(s),this.updateResults(i),this.results},updateResults(t){this.results.instantLikelihood=t,this.likelihoodBuffer.push(Math.log(t)),this.results.logLikelihood=0;const s=this.likelihoodBuffer.length;for(let t=0;t<s;t+=1)this.results.logLikelihood+=this.likelihoodBuffer.get(t);this.results.logLikelihood/=s}})},function(t,s,i){"use strict";s.a=function(t){const s=Object.assign(Object.create(e),{capacity:t});return s.clear(),s};const e={clear(){this.length=0,this.index=0,this.full=!1,this.buffer=[]},push(t){this.full?(this.buffer[this.index]=t,this.index=(this.index+1)%this.capacity):(this.buffer.push(t),this.length+=1,this.full=this.length===this.capacity)},get(t){return this.buffer[(t+this.index)%this.capacity]},fill(t){this.length=this.capacity,this.index=0,this.full=!0,this.buffer=Array(this.capacity).fill(t)},forEach(t){for(let s=0;s<this.length;s+=1)t(this.buffer[(s+this.index)%this.capacity],s)},values(){return this.buffer.slice(this.index).concat(this.buffer.slice(0,this.index))}}},function(t,s,i){"use strict";s.a=function(t){if(!Object(e.b)(t))throw new Error("The base object must include a standard set of parameters (`params` key), @see `ModelBase`.");return Object.assign(t,n,t.params.bimodal?a:{})};var e=i(0);const n={allocate(){this.beta=new Array(this.params.gaussians).fill(0)},likelihood(t){let s=0;for(let i=0;i<this.params.gaussians;i+=1)this.beta[i]=this.componentLikelihood(t,i),s+=this.beta[i];for(let t=0;t<this.params.gaussians;t+=1)this.beta[t]/=s;return s},componentLikelihood(t,s){if(s>=this.params.gaussians)throw new Error("The index of the Gaussian Mixture Component is out of bounds");return this.params.mixtureCoeffs[s]*this.params.components[s].likelihood(t)}},a={regression(t){let s;this.results.outputValues=Array(this.params.outputDimension).fill(0),this.results.outputCovariance=Array("full"===this.covarianceMode?this.params.outputDimension**2:this.params.outputDimension).fill(0);for(let i=0;i<this.params.gaussians;i+=1){s=this.params.components[i].regression(t);for(let t=0;t<this.params.outputDimension;t+=1)if(this.results.outputValues[t]+=this.beta[i]*s[t],"full"===this.covarianceMode)for(let s=0;s<this.params.outputDimension;s+=1)this.results.outputCovariance[t*this.params.outputDimension+s]+=this.beta[i]**2*this.params.components[i].outputCovariance[t*this.params.outputDimension+s];else this.results.outputCovariance[t]+=this.beta[i]**2*this.params.components[i].outputCovariance[t]}}}},function(t,s,i){"use strict";s.a=function(t,s="likeliest"){if(!Object(e.b)(t))throw new Error("The base object must include a standard set of parameters (`params` key), @see `ModelBase`.");const i=Object.assign(t,a,t.params.bimodal?r:{});return i.params.multiClassRegressionEstimator=s,i};var e=i(0),n=Object.assign||function(t){for(var s=1;s<arguments.length;s++){var i=arguments[s];for(var e in i)Object.prototype.hasOwnProperty.call(i,e)&&(t[e]=i[e])}return t};const a={reset(){Object.values(this.models).forEach(t=>t.reset()),this.results={labels:[],instantLikelihoods:[],smoothedLikelihoods:[],smoothedLogLikelihoods:[],smoothedNormalizedLikelihoods:[],likeliest:null,classes:{}},this.params.bimodal&&this.resetBimodal()},predict(t){Object.values(this.models).forEach(s=>s.predict(t)),this.updateResults()},updateResults(){const t=Object.keys(this.models).sort();this.results.labels=t;let s=0,i=0,e=-1/0;this.results.classes=t.map((t,n)=>(this.results.instantLikelihoods[n]=this.models[t].results.instantLikelihood,this.results.smoothedLogLikelihoods[n]=this.models[t].results.logLikelihood,this.results.smoothedLikelihoods[n]=Math.exp(this.results.smoothedLogLikelihoods[n]),s+=this.results.instantLikelihoods[n],i+=this.results.smoothedLikelihoods[n],this.results.smoothedLogLikelihoods[n]>e&&(e=this.results.smoothedLogLikelihoods[n],this.results.likeliest=t),{[t]:this.models[t].results})).reduce((t,s)=>n({},t,s),{}),this.results.smoothedNormalizedLikelihoods=this.results.smoothedLikelihoods.map(t=>t/i),this.results.instantNormalizedLikelihoods=this.results.instantLikelihoods.map(t=>t/s),this.params.bimodal&&this.updateRegressionResults()}},r={resetBimodal(){this.results.outputValues=[],this.results.outputCovariance=[]},updateRegressionResults(){if("likeliest"===this.params.multiClassRegressionEstimator)this.results.outputValues=this.models[this.results.likeliest].results.outputValues,this.results.outputCovariance=this.models[this.results.likeliest].results.outputCovariance;else{if("mixture"!==this.params.multiClassRegressionEstimator)throw new Error("Unknown regression estimator, use `likeliest` or `mixture`");this.results.outputValues=Array(this.outputDimension).fill(0),this.results.outputCovariance=Array(this.outputDimension**("full"===this.configuration.covarianceMode?2:1)).fill(0),this.results.labels.forEach(t=>{this.results.outputValues.map((s,i)=>s+this.results.smoothedNormalizedLikelihoods[i]*this.models[t].results.outputValues[i]),this.results.outputCovariance.map((s,i)=>s+this.results.smoothedNormalizedLikelihoods[i]*this.models[t].results.outputCovariance[i])})}}}}])});
//# sourceMappingURL=mars.js.map