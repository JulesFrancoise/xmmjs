{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///webpack/bootstrap 33e819ad98172699359a","webpack:///./src/core/model_base_mixin.js","webpack:///./src/kmeans/kmeans_training_mixin.js","webpack:///./src/training_set/index.js","webpack:///./src/training_set/phrase.js","webpack:///./src/gmm/index.js","webpack:///./src/core/em_training_mixin.js","webpack:///./src/gmm/gmm_base_mixin.js","webpack:///./src/common/gaussian_distribution.js","webpack:///./src/common/matrix.js","webpack:///./src/gmm/gmm_training_mixin.js","webpack:///./src/common/euclidean.js","webpack:///./src/core/multiclass_mixin.js","webpack:///./src/core/multiclass_training_mixin.js","webpack:///./src/core/prediction_mixin.js","webpack:///./src/common/circular_buffer.js","webpack:///./src/gmm/gmm_prediction_mixin.js","webpack:///./src/common/validation.js","webpack:///./src/core/multiclass_prediction_mixin.js","webpack:///./src/kmeans/index.js"],"names":["root","factory","exports","module","define","amd","self","this","installedModules","__webpack_require__","moduleId","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","configurable","enumerable","get","n","__esModule","object","property","prototype","hasOwnProperty","p","s","_ref","inputDimension","outputDimension","_objectWithoutProperties","bimodal","dimension","params","keys","includes","map","key","reduce","a","b","clusters","trainingConfiguration","__WEBPACK_IMPORTED_MODULE_0__core_model_base_mixin__","Error","trainingConfig","assign","initialization","relativeDistanceThreshold","minIterations","maxIterations","model","kMeansTrainingPrototype","train","trainingSet","empty","centers","Array","from","fill","initializeClustersRandom","initializeClustersForgy","initClustersWithFirstPhrase","trainingNbIterations","previousCenters","updateCenters","meanClusterDistance","maxRelativeCenterVariation","k","__WEBPACK_IMPORTED_MODULE_1__common_euclidean__","Math","max","phrase","getPhrase","indices","step","floor","length","offset","t","random","pointsPerCluster","ppc","clustIdx","forEach","_","x","getFrame","numFramesPerCluster","frame","minDistance","clusterMembership","distance","trainingSetPrototype","size","phrases","phraseIndex","toString","callback","push","label","undefined","__WEBPACK_IMPORTED_MODULE_0__phrase__","columnNames","remove","removeClass","filter","_extends","clear","getPhrasesOfClass","ts","TrainingSet","labels","ll","concat","mean","sum","totalLength","standardDeviation","stddev","sqrt","minmax","min","Infinity","create","__webpack_exports__","phrasePrototype","inputData","outputData","index","dim","observation","slice","pushInput","trim","pushOutput","clearInput","clearOutput","configuration","convergenceCriteria","__WEBPACK_IMPORTED_MODULE_5__core_multiclass_training_mixin__","__WEBPACK_IMPORTED_MODULE_4__core_multiclass_mixin__","MulticlassModelBase","trainGMM","likelihoodWindow","__WEBPACK_IMPORTED_MODULE_8__core_multiclass_prediction_mixin__","models","classes","GMMPredictor","reset","gaussians","regularization","covarianceMode","__WEBPACK_IMPORTED_MODULE_3__gmm_training_mixin__","__WEBPACK_IMPORTED_MODULE_1__core_em_training_mixin__","__WEBPACK_IMPORTED_MODULE_2__gmm_base_mixin__","ModelBase","__WEBPACK_IMPORTED_MODULE_7__gmm_prediction_mixin__","__WEBPACK_IMPORTED_MODULE_6__core_prediction_mixin__","percentChange","trainerPrototype","initTraining","logLikelihood","iterations","previousLogLikelihood","converged","updateTraining","pctChg","abs","Number","isNaN","terminateTraining","iteration","logProb","previousLogProb","gmmBasePrototype","gmmBimodalPrototype","allocate","components","__WEBPACK_IMPORTED_MODULE_1__common_gaussian_distribution__","mixtureCoeffs","beta","likelihood","componentLikelihood","mixtureComponent","updateInverseCovariances","updateInverseCovariance","e","normalizeMixtureCoeffs","normConst","regularize","currentRegularization","regression","inputObservation","tmpOutputValues","results","outputValues","outputCovariance","d2","proto","baseGaussianPrototype","bimodalGaussianPrototype","data","covarianceDeterminant","covarianceDeterminantInput","dist","covariance","inverseCovariance","allocateBimodal","inputLikelihood","euclideanDistance","tmp","exp","PI","covMatrix","__WEBPACK_IMPORTED_MODULE_0__matrix__","inv","pinv","determinant","matrix","updateInverseCovarianceBimodal","toEllipse","dimension1","dimension2","gaussianEllipse","y","width","height","angle","trace","eigenVal1","eigenVal2","atan","fromEllipse","tantheta","tan","inverseCovarianceInput","prediction","f","covMatrixInput","d1","invInput","updateOutputCovariance","covarianceGS","covarianceSG","tmptmptmp","product","covarianceMod","Matrix","matrixPrototype","transpose","out","ncols","nrows","j","mat","gaussJordanInverse","transp","prod","dst","newMat","swapLines","ii","swapColumns","nc","absolute","relative","gmmTrainerPrototype","initParametersToDefault","initMeansWithKMeans","initCovariances","dataStddev","normCoeffs","std","kmeansParams","__WEBPACK_IMPORTED_MODULE_1__kmeans_kmeans_training_mixin__","gmeans","factor","phraseIndices","E","tbase","log","pix","value","v1","v2","x1","parameters","__WEBPACK_IMPORTED_MODULE_0__model_base_mixin__","MulticlassBasePrototype","trainingFunction","labs","instantLikelihood","predictionBasePrototype","likelihoodBuffer","__WEBPACK_IMPORTED_MODULE_1__common_circular_buffer__","capacity","lw","predict","updateResults","bufSize","buffer","circularBufferPrototype","full","idx","values","__WEBPACK_IMPORTED_MODULE_1__core_model_base_mixin__","__WEBPACK_IMPORTED_MODULE_0__common_validation__","gmmParameterSpec","required","check","specification","attr","spec","parameter","constructor","checkSpec","transform","multiClassRegressionEstimator","MulticlassPredictionBasePrototype","MulticlassPredictionBimodalPrototype","instantLikelihoods","smoothedLikelihoods","smoothedLogLikelihoods","smoothedNormalizedLikelihoods","likeliest","resetBimodal","sort","normInstant","normSmoothed","maxLogLikelihood","lab","[object Object]","instantNormalizedLikelihoods","updateRegressionResults","__WEBPACK_IMPORTED_MODULE_1__kmeans_training_mixin__"],"mappings":"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","file":"mars.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"mars\"] = factory();\n\telse\n\t\troot[\"mars\"] = factory();\n})(typeof self !== 'undefined' ? self : this, function() {\nreturn \n\n\n// WEBPACK FOOTER //\n// webpack/universalModuleDefinition"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 2);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 33e819ad98172699359a","/**\n * Create the skeleton of a model\n *\n * @function\n * @param       {Number} inputDimension  input dimension\n * @param       {Number} outputDimension output dimension\n * @param       {Object} parameters      additional parameters to be copied\n * @constructor\n */\nexport default function ModelBase({\n  inputDimension,\n  outputDimension,\n  ...parameters\n}) {\n  const p = parameters;\n  delete p.bimodal;\n  delete p.inputDimension;\n  delete p.outputDimension;\n  delete p.dimension;\n  return /** @lends ModelBase */{\n    params: {\n      ...p,\n      get bimodal() {\n        return outputDimension > 0;\n      },\n      get inputDimension() {\n        return inputDimension;\n      },\n      get outputDimension() {\n        return outputDimension;\n      },\n      get dimension() {\n        return inputDimension + outputDimension;\n      },\n    },\n  };\n}\n\n/**\n * Check if an object is a base model (check for attribute existence)\n * @param  {Object}  o Source object\n * @return {Boolean}\n */\nexport function isBaseModel(o) {\n  if (!Object.keys(o).includes('params')) return false;\n  const keys = ['bimodal', 'inputDimension', 'outputDimension', 'dimension'];\n  return keys.map(key => Object.keys(o.params).includes(key))\n    .reduce((a, b) => a && b, true);\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/core/model_base_mixin.js","import { isBaseModel } from '../core/model_base_mixin';\nimport euclidean from '../common/euclidean';\n\nconst kMeansTrainingPrototype = {\n  train(trainingSet) {\n    if (!trainingSet || trainingSet.empty()) {\n      throw new Error('The training set is empty');\n    }\n\n    this.params.centers = Array.from(\n      Array(this.params.clusters),\n      () => new Array(this.params.dimension).fill(0),\n    );\n\n    // TODO: improve initialization =>\n    // https://www.slideshare.net/djempol/kmeans-initialization-15041920\n    //\n    if (this.trainingConfig.initialization === 'random') {\n      this.initializeClustersRandom(trainingSet);\n    } else if (this.trainingConfig.initialization === 'forgy') {\n      this.initializeClustersForgy(trainingSet);\n    } else if (this.trainingConfig.initialization === 'data') {\n      this.initClustersWithFirstPhrase(trainingSet);\n    } else {\n      throw new Error('Unknown K-Means initialization, must be `random`, `forgy` or `data`');\n    }\n\n    for (\n      let trainingNbIterations = 0;\n      trainingNbIterations < this.trainingConfig.maxIterations;\n      trainingNbIterations += 1\n    ) {\n      const previousCenters = this.params.centers;\n\n      this.updateCenters(previousCenters, trainingSet);\n\n      let meanClusterDistance = 0;\n      let maxRelativeCenterVariation = 0;\n      for (let k = 0; k < this.params.clusters; k += 1) {\n        for (let l = 0; l < this.params.clusters; l += 1) {\n          if (k !== l) {\n            meanClusterDistance += euclidean(\n              this.params.centers[k],\n              this.params.centers[l],\n            );\n          }\n        }\n        maxRelativeCenterVariation = Math.max(\n          euclidean(\n            previousCenters[k],\n            this.params.centers[k],\n          ),\n          maxRelativeCenterVariation,\n        );\n      }\n      meanClusterDistance /= this.params.clusters * (this.params.clusters - 1);\n      maxRelativeCenterVariation /= this.params.clusters;\n      maxRelativeCenterVariation /= meanClusterDistance;\n      if (maxRelativeCenterVariation < this.trainingConfig.relativeDistanceThreshold) break;\n    }\n    return this.params;\n  },\n\n  initClustersWithFirstPhrase(trainingSet) {\n    const phrase = trainingSet.getPhrase(trainingSet.indices()[0]);\n    const step = Math.floor(phrase.length / this.params.clusters);\n\n    let offset = 0;\n    for (let c = 0; c < this.params.clusters; c += 1) {\n      this.params.centers[c] = new Array(this.params.dimension).fill(0);\n      for (let t = 0; t < step; t += 1) {\n        for (let d = 0; d < this.params.dimension; d += 1) {\n          this.params.centers[c][d] += phrase.get(offset + t, d) / step;\n        }\n      }\n      offset += step;\n    }\n  },\n\n  initializeClustersRandom(trainingSet) {\n    const phrase = trainingSet.getPhrase(trainingSet.indices()[0]);\n    const indices = Array.from(\n      Array(phrase.length),\n      () => Math.floor(Math.random() * this.params.clusters),\n    );\n    const pointsPerCluster = indices.reduce(\n      (ppc, i) => {\n        const p = ppc;\n        p[i] += 1;\n        return p;\n      },\n      Array(this.params.clusters).fill(0),\n    );\n    for (let i = 0; i < indices.length; i += 1) {\n      const clustIdx = indices[i];\n      for (let d = 0; d < this.params.dimension; d += 1) {\n        this.params.centers[clustIdx][d] += phrase.get(i, d);\n      }\n    }\n    this.params.centers.forEach((_, c) => {\n      this.params.centers[c] = this.params.centers[c]\n        .map(x => x / pointsPerCluster[c]);\n    });\n  },\n\n  initializeClustersForgy(trainingSet) {\n    const phrase = trainingSet.getPhrase(trainingSet.indices()[0]);\n    const indices = Array.from(\n      Array(this.params.clusters),\n      () => Math.floor(Math.random() * phrase.length),\n    );\n    this.params.centers = indices.map(i => phrase.getFrame(i));\n  },\n\n  updateCenters(previousCenters, trainingSet) {\n    this.params.centers = Array.from(Array(this.params.clusters), () =>\n      new Array(this.params.dimension).fill(0));\n    const numFramesPerCluster = Array(this.params.clusters).fill(0);\n    trainingSet.forEach((phrase) => {\n      for (let t = 0; t < phrase.length; t += 1) {\n        const frame = phrase.getFrame(t);\n        let minDistance = euclidean(frame, previousCenters[0]);\n        let clusterMembership = 0;\n        for (let k = 1; k < this.params.clusters; k += 1) {\n          const distance = euclidean(\n            frame,\n            previousCenters[k],\n            this.params.dimension,\n          );\n          if (distance < minDistance) {\n            clusterMembership = k;\n            minDistance = distance;\n          }\n        }\n        numFramesPerCluster[clusterMembership] += 1;\n        for (let d = 0; d < this.params.dimension; d += 1) {\n          this.params.centers[clusterMembership][d] += phrase.get(t, d);\n        }\n      }\n    });\n    for (let k = 0; k < this.params.clusters; k += 1) {\n      if (numFramesPerCluster[k] > 0) {\n        for (let d = 0; d < this.params.dimension; d += 1) {\n          this.params.centers[k][d] /= numFramesPerCluster[k];\n        }\n      }\n    }\n  },\n};\n\nexport default function withKMeansTraining(\n  o,\n  clusters,\n  trainingConfiguration = {},\n) {\n  if (!isBaseModel(o)) {\n    throw new Error('The base object must include a standard set of parameters (`params` key), @see `ModelBase`.');\n  }\n  const trainingConfig = Object.assign({\n    initialization: 'random',\n    relativeDistanceThreshold: 1e-3,\n    minIterations: 5,\n    maxIterations: 100,\n  }, trainingConfiguration);\n  const model = Object.assign(o, kMeansTrainingPrototype, {\n    trainingConfig,\n  });\n  model.params.clusters = clusters;\n  return model;\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/kmeans/kmeans_training_mixin.js","import Phrase from './phrase';\n\n/**\n * Training Set Prototype\n * @ignore\n */\nconst trainingSetPrototype = /** @lends TrainingSet */ {\n  /**\n   * Get the training set size (number of phrases)\n   * @return {number}\n   */\n  size() {\n    return Object.keys(this.phrases).length;\n  },\n\n  /**\n   * Checks if the training set is empty\n   * @return {boolean}\n   */\n  empty() {\n    return this.length === 0;\n  },\n\n  /**\n   * Get a reference to a phrase by index\n   * @param  {number} phraseIndex phrase index\n   * @return {Phrase}\n   */\n  getPhrase(phraseIndex) {\n    if (Object.keys(this.phrases).includes(phraseIndex.toString())) {\n      return this.phrases[phraseIndex.toString()];\n    }\n    return null;\n  },\n\n  /**\n   * Iterate over all phrases in the training set. The callback function\n   * should take 3 arguments: the phrase, its index in the training set,\n   * and the phrases structure.\n   *\n   * @param  {Function} callback Callback function\n   */\n  forEach(callback) {\n    Object.keys(this.phrases).forEach((phraseIndex) => {\n      callback(this.phrases[phraseIndex], phraseIndex, this.phrases);\n    });\n  },\n\n  /**\n   * Add a phrase to the training set and return it.\n   * @param  {number} phraseIndex        phrase index\n   * @param  {string} [label=undefined]  phrase label (its index if undefined)\n   * @param  {Phrase} [phrase=undefined] Phrase data. If unspecified, an empty\n   * phrase is created.\n   * @return {Phrase}\n   */\n  push(phraseIndex, label = undefined, phrase = undefined) {\n    const p = (phrase !== undefined) ? phrase : Phrase({\n      inputDimension: this.inputDimension,\n      outputDimension: this.outputDimension,\n      columnNames: this.columnNames,\n      label: (label !== undefined) ? label : phraseIndex.toString(),\n    });\n    this.phrases[phraseIndex] = p;\n    return p;\n  },\n\n  /**\n   * Remove a phrase\n   * @param  {number} phraseIndex phrase index\n   */\n  remove(phraseIndex) {\n    delete this.phrases[phraseIndex];\n  },\n\n  /**\n   * Remove all phrases with a given label\n   * @param  {string} label class label\n   */\n  removeClass(label) {\n    this.phrases = Object.keys(this.phrases)\n      .filter(i => this.phrases[i].label !== label)\n      .map(i => ({ i: this.phrases[i] }))\n      .reduce((x, p) => ({ ...x, ...p }), {});\n  },\n\n  /**\n   * Clear the training set (delete all phrases)\n   */\n  clear() {\n    this.phrases = {};\n  },\n\n  /**\n   * Get the sub-training set composed of all phrases of a given class\n   * @param  {string} label class label\n   * @return {TrainingSet}\n   */\n  getPhrasesOfClass(label) {\n    const ts = TrainingSet(this); // eslint-disable-line no-use-before-define\n    ts.phrases = Object.keys(this.phrases)\n      .filter(i => this.phrases[i].label === label)\n      .map(i => ({ i: this.phrases[i] }))\n      .reduce((x, p) => ({ ...x, ...p }), {});\n    return ts;\n  },\n\n  /**\n   * Get the list of unique labels in the training set\n   * @return {Array<string>}\n   */\n  labels() {\n    return Object.keys(this.phrases)\n      .map(i => this.phrases[i].label)\n      .reduce((ll, x) => (ll.includes(x) ? ll : ll.concat([x])), []);\n  },\n\n  /**\n   * Get the list of phrase indices\n   * @return {Array<number>}\n   */\n  indices() {\n    return Object.keys(this.phrases);\n  },\n\n  /**\n   * Get the mean of the training set over all phrases\n   * @return {Array<number>} mean (same dimension as the training set)\n   */\n  mean() {\n    const sum = Array(this.dimension).fill(0);\n    let totalLength = 0;\n    Object.keys(this.phrases).forEach((i) => {\n      for (let d = 0; d < this.dimension; d += 1) {\n        for (let t = 0; t < this.phrases[i].length; t += 1) {\n          sum[d] += this.phrases[i].get(t, d);\n        }\n      }\n      totalLength += this.phrases[i].length;\n    });\n\n    return sum.map(x => x / totalLength);\n  },\n\n  /**\n   * Get the standard deviation of the training set over all phrases\n   * @return {Array<number>} standard deviation (same dimension as the training set)\n   */\n  standardDeviation() {\n    const stddev = Array(this.dimension).fill(0);\n    const mean = this.mean();\n    let totalLength = 0;\n    Object.keys(this.phrases).forEach((i) => {\n      for (let d = 0; d < this.dimension; d += 1) {\n        for (let t = 0; t < this.phrases[i].length; t += 1) {\n          stddev[d] += (this.phrases[i].get(t, d) - mean[d]) ** 2;\n        }\n      }\n      totalLength += this.phrases[i].length;\n    });\n\n    return stddev.map(x => Math.sqrt(x / totalLength));\n  },\n\n  /**\n   * Get the min and max of the training set over all phrases\n   * @return {Array<{ min: number, max: number }>} min/max (same dimension as the training set)\n   */\n  minmax() {\n    const minmax = Array.from(\n      Array(this.dimension),\n      () => ({ min: +Infinity, max: -Infinity }),\n    );\n    Object.keys(this.phrases).forEach((i) => {\n      for (let d = 0; d < this.dimension; d += 1) {\n        for (let t = 0; t < this.phrases[i].length; t += 1) {\n          minmax[d].min += Math.min(minmax[d].min, this.phrases[i].get(t, d));\n          minmax[d].max += Math.max(minmax[d].max, this.phrases[i].get(t, d));\n        }\n      }\n    });\n    return minmax;\n  },\n};\n\n/**\n * Create a Training set, composed of a set of indexed data phrases\n * @param {Object} [params]                   Training set parameters\n * @param {Number} [params.inputDimension=1]  Dimension of the input modality\n * @param {Number} [params.outputDimension=0] Dimension of the output modality\n * (optional)\n * @param {Array<String>} [params.columnNames=null] Data column names, e.g.\n * \\['accX', 'accY', 'accZ'\\] (optional)\n * @return {TrainingSet}\n * @function\n *\n * @property {Boolean} bimodal Specifies if the training set is bimodal\n * @property {Number}  inputDimension Dimension of the input modality\n * @property {Number}  outputDimension Dimension of the output modality\n * @property {Number}  dimension Total dimension\n * @property {Array<String>} columnNames Columns names\n */\nexport default function TrainingSet({\n  inputDimension = 1,\n  outputDimension = 0,\n  columnNames = null,\n} = {}) {\n  const dimension = inputDimension + outputDimension;\n  return Object.assign(\n    Object.create(trainingSetPrototype),\n    {\n      bimodal: outputDimension > 0,\n      inputDimension,\n      outputDimension,\n      dimension,\n      columnNames: columnNames || Array(dimension).fill(''),\n      phrases: {},\n    },\n  );\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/training_set/index.js","/**\n * Data Phrase Prototype\n * @ignore\n */\nconst phrasePrototype = /** @lends Phrase */ {\n  /**\n   * Get the value at a given index and dimension\n   * @param  {Number} index index\n   * @param  {Number} dim   dimension\n   * @return {Number}\n   */\n  get(index, dim) {\n    if (typeof index !== 'number' || Math.floor(index) !== index) {\n      throw new Error('The index must be an integer');\n    }\n    if (dim >= this.dimension) {\n      throw new Error('Phrase: dimension out of bounds');\n    }\n    if (this.bimodal) {\n      if (dim < this.inputDimension) {\n        if (index >= this.inputData.length) {\n          throw new Error('Phrase: index out of bounds');\n        }\n        return this.inputData[index][dim];\n      }\n      if (index >= this.outputData.length) {\n        throw new Error('Phrase: index out of bounds');\n      }\n      return this.outputData[index][dim - this.inputDimension];\n    }\n    if (index >= this.length) {\n      throw new Error('Phrase: index out of bounds');\n    }\n    if (!this.inputData[index]) {\n      throw new Error('WTF?');\n    }\n    return this.inputData[index][dim];\n  },\n\n  /**\n   * Get the data frame at a given index\n   * @param  {Number} index index\n   * @return {Array<number>}\n   * @throws {Error} if the index is out of bounds\n   */\n  getFrame(index) {\n    if (index >= this.length) {\n      throw new Error('Phrase: index out of bounds');\n    }\n    if (this.bimodal) {\n      return this.inputData[index].concat(this.outputData[index]);\n    }\n    return this.inputData[index];\n  },\n\n  /**\n   * Push an observation vector to the phrase\n   * @param  {Array<number>} observation observation data\n   * @throws {Error} if the observation's dimension does not match the\n   * dimension of the training set\n   */\n  push(observation) {\n    // console.log('push:', observation);\n    if (observation.length !== this.dimension) {\n      throw new Error('Observation has wrong dimension');\n    }\n\n    if (this.bimodal) {\n      this.inputData.push(observation.slice(0, this.inputDimension));\n      this.outputData.push(observation.slice(this.inputDimension, this.dimension));\n    } else {\n      this.inputData.push(observation);\n    }\n\n    this.length += 1;\n  },\n\n  /**\n   * Push an observation to the input modality only\n   * @param  {Array<number>} observation observation data\n   * @throws {Error} if the phrase is not bimodal\n   * @throws {Error} if the observation's dimension does not match the\n   * input dimension of the training set\n   */\n  pushInput(observation) {\n    if (!this.bimodal) {\n      throw new Error('this phrase is unimodal, use `push`');\n    }\n    if (observation.size() !== this.inputDimension) {\n      throw new Error('Observation has wrong dimension');\n    }\n\n    this.inputData.push(observation);\n    this.trim();\n  },\n\n  /**\n   * Push an observation to the output modality only\n   * @param  {Array<number>} observation observation data\n   * @throws {Error} if the phrase is not bimodal\n   * @throws {Error} if the observation's dimension does not match the\n   * output dimension of the training set\n   */\n  pushOutput(observation) {\n    if (!this.bimodal) {\n      throw new Error('this phrase is unimodal, use `push`');\n    }\n    if (observation.size() !== this.outputDimension) {\n      throw new Error('Observation has wrong dimension');\n    }\n\n    this.outputData.push(observation);\n    this.trim();\n  },\n\n  /**\n   * Clear the phrase's data\n   */\n  clear() {\n    this.length = 0;\n    this.inputData = [];\n    this.outputData = [];\n  },\n\n  /**\n   * Clear the phrase's input data\n   */\n  clearInput() {\n    this.inputData = [];\n    this.trim();\n  },\n\n  /**\n   * Clear the phrase's output data\n   */\n  clearOutput() {\n    this.outputData = [];\n    this.trim();\n  },\n\n  /**\n   * Compute the mean of the phrase (across time)\n   * @return {Array<number>} The mean vector (same dimension as the\n   * training set)\n   */\n  mean() {\n    const mean = Array(this.dimension).fill(0);\n    for (let d = 0; d < this.dimension; d += 1) {\n      for (let t = 0; t < this.length; t += 1) {\n        mean[d] += this.get(t, d);\n      }\n      mean[d] /= this.length;\n    }\n    return mean;\n  },\n\n  /**\n   * Compute the standard deviation of the phrase (across time)\n   * @return {Array<number>} The standard deviation vector (same dimension as\n   * the training set)\n   */\n  standardDeviation() {\n    const stddev = Array(this.dimension).fill(0);\n    const mean = this.mean();\n    for (let d = 0; d < this.dimension; d += 1) {\n      for (let t = 0; t < this.length; t += 1) {\n        stddev[d] += (this.get(t, d) - mean[d]) * (this.get(t, d) - mean[d]);\n      }\n      stddev[d] /= this.length;\n      stddev[d] = Math.sqrt(stddev[d]);\n    }\n    return stddev;\n  },\n\n  /**\n   * Compute the minimum and maximum of the phrase (across time)\n   * @return {Array<{ min: number, max: number }>} The min/max vector (same\n   * dimension as the training set)\n   */\n  minmax() {\n    const minmax = Array.from(\n      Array(this.dimension),\n      () => ({ min: +Infinity, max: -Infinity }),\n    );\n    for (let d = 0; d < this.dimension; d += 1) {\n      for (let t = 0; t < this.length; t += 1) {\n        minmax[d].min = Math.min(this.get(t, d), minmax[d].min);\n        minmax[d].max = Math.max(this.get(t, d), minmax[d].max);\n      }\n    }\n    return minmax;\n  },\n\n  /**\n   * Trim the phrase length to the minimum of the input and output lengths\n   * @private\n   */\n  trim() {\n    if (this.bimodal) {\n      this.length = Math.min(this.inputData.length, this.outputData.length);\n    }\n  },\n};\n\n/**\n * Create a data phrase, potentially bimodal. Phrases are data structures for\n * temporal data (e.g. gestures), used to constitute training sets.\n *\n * @param {Object} [params]                   Phrase parameters\n * @param {Number} [params.inputDimension=1]  Dimension of the input modality\n * @param {Number} [params.outputDimension=0] Dimension of the output modality\n * (optional)\n * @param {Array<String>} [params.columnNames=null] Data column names, e.g.\n * \\['accX', 'accY', 'accZ'\\] (optional)\n * @param {String} [params.label='']          Phrase label\n * @return {Phrase}\n * @function\n *\n * @property {Boolean} bimodal Specifies if the phrase is bimodal\n * @property {Number} inputDimension Dimension of the input modality\n * @property {Number} outputDimension Dimension of the output modality\n * @property {Number} dimension Total dimension\n * @property {Number} length Phrase length (number of frames)\n * @property {String} label Phrase label\n * @property {Array<String>} columnNames Columns names\n */\nexport default function Phrase({\n  inputDimension = 1,\n  outputDimension = 0,\n  columnNames = null,\n  label = '',\n} = {}) {\n  const dimension = inputDimension + outputDimension;\n  return Object.assign(\n    Object.create(phrasePrototype),\n    {\n      bimodal: outputDimension > 0,\n      inputDimension,\n      outputDimension,\n      dimension,\n      length: 0,\n      label,\n      inputData: [],\n      outputData: [],\n      columnNames: columnNames || Array(dimension).fill(''),\n    },\n  );\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/training_set/phrase.js","import ModelBase from '../core/model_base_mixin';\nimport withEMTraining from '../core/em_training_mixin';\nimport withGMMBase from './gmm_base_mixin';\nimport withGMMTraining from './gmm_training_mixin';\nimport MulticlassModelBase from '../core/multiclass_mixin';\nimport withMulticlassTraining from '../core/multiclass_training_mixin';\nimport withAbtractPrediction from '../core/prediction_mixin';\nimport withGMMPrediction from './gmm_prediction_mixin';\nimport withMulticlassPrediction from '../core/multiclass_prediction_mixin';\n\n/**\n * @typedef {Object} GMMParameters\n * @property {Boolean} bimodal Specifies if the model is bimodal\n * @property {Number} inputDimension Dimension of the input modality\n * @property {Number} outputDimension Dimension of the output modality\n * @property {Number} dimension Total dimension\n * @property {Number} gaussians Number of gaussian components in the mixture\n * @property {String} covarianceMode Covariance mode ('full' or 'diagonal')\n * @property {Array<Number>} mixtureCoeffs mixture coefficients ('weight' of\n * each gaussian component)\n * @property {Array<GaussianDistribution>} components Gaussian components\n */\n\n/**\n * Train a single-class GMM Model.\n *\n * @todo GMM details\n *\n * @param  {TrainingSet} trainingSet                training set\n * @param  {Object} configuration                   Training configuration\n * @param  {Object} [convergenceCriteria=undefined] Convergence criteria of the\n * EM algorithm\n * @return {GMMParameters} Parameters of the trained GMM\n */\nexport function trainGMM(\n  trainingSet,\n  configuration,\n  convergenceCriteria = undefined,\n) {\n  const { inputDimension, outputDimension } = trainingSet;\n  const { gaussians, regularization, covarianceMode } = configuration;\n  const model = withGMMTraining(\n    withEMTraining(\n      withGMMBase(ModelBase({\n        inputDimension,\n        outputDimension,\n        ...configuration,\n      })),\n      convergenceCriteria,\n    ),\n    gaussians,\n    regularization,\n    covarianceMode,\n  );\n  return model.train(trainingSet);\n}\n\n/**\n * Train a multi-class GMM Model.\n *\n * @todo GMM details\n *\n * @param  {TrainingSet} trainingSet                training set\n * @param  {Object} configuration                   Training configuration\n * @param  {Object} [convergenceCriteria=undefined] Convergence criteria of the\n * EM algorithm\n * @return {Object} Parameters of the trained GMM\n */\nexport function trainMulticlassGMM(\n  trainingSet,\n  configuration,\n  convergenceCriteria = undefined,\n) {\n  const { inputDimension, outputDimension } = trainingSet;\n  const model = withMulticlassTraining(\n    MulticlassModelBase({ inputDimension, outputDimension, ...configuration }),\n    ts => trainGMM(ts, configuration, convergenceCriteria),\n  );\n  return model.train(trainingSet);\n}\n\n/**\n * Create a GMM Predictor from a full set of parameters (generated by trainGMM).\n * @param       {Object} params                       Model parameters\n * @param       {number} [likelihoodWindow=undefined] Likelihoow window size\n * @function\n */\nexport function GMMPredictor(\n  params,\n  likelihoodWindow = undefined,\n) {\n  const model = withGMMPrediction(withAbtractPrediction(\n    withGMMBase(ModelBase(params)),\n    likelihoodWindow,\n  ));\n  model.reset();\n  return model;\n}\n\n/**\n * Create a Multiclass GMM Predictor from a full set of parameters\n * (generated by trainMulticlassGMM).\n * @param       {Object} params                       Model parameters\n * @param       {number} [likelihoodWindow=undefined] Likelihoow window size\n * @function\n */\nexport function MulticlassGMMPredictor(\n  params,\n  likelihoodWindow = undefined,\n) {\n  const model = withMulticlassPrediction(MulticlassModelBase(params));\n  model.models = {};\n  Object.keys(params.classes).forEach((label) => {\n    model.models[label] = GMMPredictor(params.classes[label], likelihoodWindow);\n  });\n  model.reset();\n  return model;\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/gmm/index.js","const trainerPrototype = /** @lends withEMTraining */ {\n  /**\n   * Train the model from the given training set, using the\n   * Expectation-Maximisation algorithm.\n   *\n   * @param  {TrainingSet} trainingSet Training Set\n   * @return {Object} Parameters of the trained model\n   */\n  train(trainingSet) {\n    if (!trainingSet || trainingSet.empty()) {\n      throw new Error('The training set is empty');\n    }\n\n    this.initTraining(trainingSet);\n\n    let logLikelihood = -Infinity;\n    let iterations = 0;\n    let previousLogLikelihood = logLikelihood;\n\n    while (!this.converged(iterations, logLikelihood, previousLogLikelihood)) {\n      previousLogLikelihood = logLikelihood;\n      logLikelihood = this.updateTraining(trainingSet);\n\n      const pctChg =\n        100 * Math.abs((logLikelihood - previousLogLikelihood) / previousLogLikelihood);\n      if (Number.isNaN(pctChg) && iterations > 1) {\n        throw new Error('An error occured during training');\n      }\n\n      iterations += 1;\n    }\n\n    this.terminateTraining();\n    return this.params;\n  },\n\n  /**\n   * Return `true` if the training has converged according to the criteria\n   * specified at the creation\n   *\n   * @param  {number} iteration       Current iteration\n   * @param  {number} logProb         Current log-likelihood of the training set\n   * @param  {number} previousLogProb Previous log-likelihood of the training\n   * set\n   * @return {boolean}\n   *\n   * @private\n   */\n  converged(iteration, logProb, previousLogProb) {\n    if (iteration >= this.convergenceCriteria.maxIterations) return true;\n    if (this.convergenceCriteria.maxIterations >= this.convergenceCriteria.minIterations) {\n      return iteration >= this.convergenceCriteria.maxIterations;\n    }\n    if (iteration < this.convergenceCriteria.minIterations) return false;\n    const percentChange = 100 * Math.abs((logProb - previousLogProb) / logProb);\n    return percentChange <= this.convergenceCriteria.percentChange;\n  },\n};\n\n/**\n * Add ABSTRACT training capabilities to a model for which the training process\n * use the Expectation-Maximisation (EM) algorithm. This is used in particular\n * for training GMMs and HMMs.\n *\n * The final instance needs to implement `initTraining`, `updateTraining` and\n * `terminateTraining` methods. `updateTraining` will be called until the\n * convergence criteria are met. Convergence depends on\n * - A minimum number of iterations\n * - A maximum number of iterations\n * - A threshold on the relative change of the log-likelihood of the training\n * data between successive iterations.\n *\n * @todo details\n *\n * @param  {Object} [o]                   Source object\n * @param  {Object} [convergenceCriteria] Set of convergence criteria\n * @param  {number} [convergenceCriteria.percentChange=1e-3] Threshold in % of\n * the relative change of the log-likelihood, under which the training stops.\n * @param  {number} [convergenceCriteria.minIterations=5]    minimum number of iterations\n * @param  {number} [convergenceCriteria.maxIterations=100]  maximum number of iterations\n * @return {Object}\n */\nexport default function withEMTraining(\n  o,\n  convergenceCriteria = {\n    percentChange: 1e-3,\n    minIterations: 5,\n    maxIterations: 100,\n  },\n) {\n  return Object.assign(o, trainerPrototype, { convergenceCriteria });\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/core/em_training_mixin.js","import { isBaseModel } from '../core/model_base_mixin';\nimport GaussianDistribution from '../common/gaussian_distribution';\n\n/**\n * GMM Base prototype\n * @type {Object}\n * @ignore\n */\nconst gmmBasePrototype = /** @lends withGMMBase */ {\n  /**\n   * Allocate the training variables\n   * @private\n   */\n  allocate() {\n    this.params.components = Array.from(\n      Array(this.params.gaussians),\n      () => new GaussianDistribution(\n        this.params.inputDimension,\n        this.params.outputDimension,\n        this.params.covarianceMode,\n      ),\n    );\n    this.params.mixtureCoeffs = Array(this.params.gaussians).fill(0);\n    this.beta = new Array(this.params.gaussians).fill(0);\n  },\n\n  /**\n   * Compute the likelihood of an observation given the GMM's parameters\n   * @param  {Array<Number>} observation Observation vector\n   * @return {Number}\n   */\n  likelihood(observation) {\n    let likelihood = 0;\n    for (let c = 0; c < this.params.gaussians; c += 1) {\n      this.beta[c] = this.componentLikelihood(observation, c);\n      likelihood += this.beta[c];\n    }\n    for (let c = 0; c < this.params.gaussians; c += 1) {\n      this.beta[c] /= likelihood;\n    }\n\n    return likelihood;\n  },\n\n  /**\n   * Compute the likelihood of an observation for a single component\n   * @param  {Array<Number>} observation Observation vector\n   * @param  {Number} mixtureComponent Component index\n   * @return {Number}\n   * @private\n   */\n  componentLikelihood(observation, mixtureComponent) {\n    if (mixtureComponent >= this.params.gaussians) {\n      throw new Error('The index of the Gaussian Mixture Component is out of bounds');\n    }\n    return this.params.mixtureCoeffs[mixtureComponent] *\n        this.params.components[mixtureComponent].likelihood(observation);\n  },\n\n  /**\n   * Update the inverse covariance of each Gaussian component\n   * @private\n   */\n  updateInverseCovariances() {\n    this.params.components.forEach((c) => {\n      c.updateInverseCovariance();\n    });\n    try {\n      this.params.components.forEach((c) => {\n        c.updateInverseCovariance();\n      });\n    } catch (e) {\n      throw new Error('Matrix inversion error: varianceoffset must be too small');\n    }\n  },\n\n  /**\n   * Normalize the mixing coefficients of the Gaussian mixture\n   * @private\n   */\n  normalizeMixtureCoeffs() {\n    let normConst = 0;\n    for (let c = 0; c < this.params.gaussians; c += 1) {\n      normConst += this.params.mixtureCoeffs[c];\n    }\n    if (normConst > 0) {\n      for (let c = 0; c < this.params.gaussians; c += 1) {\n        this.params.mixtureCoeffs[c] /= normConst;\n      }\n    } else {\n      for (let c = 0; c < this.params.gaussians; c += 1) {\n        this.params.mixtureCoeffs[c] = 1 / this.params.gaussians;\n      }\n    }\n  },\n\n  /**\n   * Regularize the covariances\n   * @private\n   */\n  regularize() {\n    this.params.components.forEach((c) => {\n      c.regularize(this.currentRegularization);\n    });\n  },\n};\n\n/**\n * Bimodal (regression) GMM Prototype\n * @type {Object}\n * @ignore\n */\nconst gmmBimodalPrototype = /** @lends withGMMBase */ {\n  /**\n   * Estimate the output values corresponding to the input observation, by\n   * regression given the GMM's parameters. This method is called Gaussian\n   * Mixture Regression (GMR).\n   *\n   * @param  {Array<Number>} inputObservation Observation on the input modality\n   * @return {Array<Number>} Output values (length = outputDimension)\n   */\n  regression(inputObservation) {\n    this.results.outputValues = Array(this.params.outputDimension).fill(0);\n    this.results.outputCovariance = Array(this.params.covarianceMode === 'full' ? this.params.outputDimension ** 2 : this.params.outputDimension).fill(0);\n    let tmpOutputValues;\n\n    for (let c = 0; c < this.params.gaussians; c += 1) {\n      tmpOutputValues = this.params.components[c].regression(inputObservation);\n      for (let d = 0; d < this.params.outputDimension; d += 1) {\n        this.results.outputValues[d] += this.beta[c] * tmpOutputValues[d];\n        if (this.params.covarianceMode === 'full') {\n          for (let d2 = 0; d2 < this.params.outputDimension; d2 += 1) {\n            this.results.outputCovariance[(d * this.params.outputDimension) + d2] +=\n              (this.beta[c] ** 2) *\n              this.params.components[c].outputCovariance[(d * this.params.outputDimension) + d2];\n          }\n        } else {\n          this.results.outputCovariance[d] +=\n            (this.beta[c] ** 2) * this.params.components[c].outputCovariance[d];\n        }\n      }\n    }\n    return this.results.outputValues;\n  },\n};\n\n/**\n * Add basic GMM capabilities to a single-class model. This enables the\n * computation of the likelihoods and regression operations common to\n * training and prediction\n *\n * @see withGMMTraining\n * @see withGMMPrediction\n *\n * @param  {ModelBase} o Source Model\n * @return {GMMBaseModel}\n *\n * @throws {Error} is o is not a ModelBase\n */\nexport default function withGMMBase(o) {\n  if (!isBaseModel(o)) {\n    throw new Error('The base object must include a standard set of parameters (`params` key), @see `ModelBase`.');\n  }\n  return Object.assign(\n    o,\n    gmmBasePrototype,\n    o.params.bimodal ? gmmBimodalPrototype : {},\n  );\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/gmm/gmm_base_mixin.js","import Matrix from './matrix';\n\n/**\n * Gaussian Distribution Prototype\n *\n * @type {Object}\n * @property {boolean} bimodal           Specifies if the distribution is\n * bimodal (for regression use)\n * @property {number}  inputDimension    input dimension\n * @property {number}  outputDimension   output dimension\n * @property {number}  dimension         Total dimension\n * @property {Array}   mean              Distribution mean\n * @property {Array}   covariance        Distribution covariance\n * @property {Array}   inverseCovariance Inverse covariance\n *\n * @ignore\n */\nconst baseGaussianPrototype = /** @lends GaussianDistribution */ {\n  /**\n   * Allocate the distribution\n   * @private\n   */\n  allocate() {\n    this.mean = new Array(this.dimension).fill(0);\n    if (this.covarianceMode === 'full') {\n      this.covariance = new Array(this.dimension ** 2).fill(0);\n      this.inverseCovariance = new Array(this.dimension ** 2).fill(0);\n    } else {\n      this.covariance = new Array(this.dimension).fill(0);\n      this.inverseCovariance = new Array(this.dimension).fill(0);\n    }\n    if (this.bimodal) {\n      this.allocateBimodal();\n    }\n  },\n\n  /**\n   * @brief Estimate the likelihood of an observation vector.\n   *\n   * If the distribution is bimodal an the observation is a vector of the size\n   * of the input modality, the likelihood is computed only on the\n   * distribution for the input modality\n   *\n   * @param  {array} observation data observation\n   * @return {number}\n   */\n  likelihood(observation) {\n    if (this.covarianceDeterminant === 0) {\n      throw new Error('Covariance Matrix is not invertible');\n    }\n    if (this.bimodal && observation.length === this.inputDimension) {\n      return this.inputLikelihood(observation);\n    }\n    if (observation.length !== this.dimension) {\n      throw new Error(`GaussianDistribution: observation has wrong dimension. Expected \\`${this.dimension}\\`, got \\`${observation.length}\\``);\n    }\n\n    let euclideanDistance = 0;\n    if (this.covarianceMode === 'full') {\n      for (let l = 0; l < this.dimension; l += 1) {\n        let tmp = 0;\n        for (let k = 0; k < this.dimension; k += 1) {\n          tmp += this.inverseCovariance[(l * this.dimension) + k] *\n            (observation[k] - this.mean[k]);\n        }\n        euclideanDistance += (observation[l] - this.mean[l]) * tmp;\n      }\n    } else {\n      for (let l = 0; l < this.dimension; l += 1) {\n        euclideanDistance += this.inverseCovariance[l] *\n          (observation[l] - this.mean[l]) *\n          (observation[l] - this.mean[l]);\n      }\n    }\n\n    let p = Math.exp(-0.5 * euclideanDistance) /\n      Math.sqrt(this.covarianceDeterminant * ((2 * Math.PI) ** this.dimension));\n\n    if (p < 1e-180 || Number.isNaN(p) || Math.abs(p) === +Infinity) {\n      p = 1e-180;\n    }\n\n    return p;\n  },\n\n  /**\n   * Regularize the distribution, given a regularization vector of the same\n   * dimension. Regularization adds the vector to the variance of the\n   * distribution.\n   *\n   * @param  {Array} regularization regularization vector\n   */\n  regularize(regularization) {\n    if (this.covarianceMode === 'full') {\n      for (let d = 0; d < this.dimension; d += 1) {\n        this.covariance[(d * this.dimension) + d] += regularization[d];\n      }\n    } else {\n      for (let d = 0; d < this.dimension; d += 1) {\n        this.covariance[d] += regularization[d];\n      }\n    }\n  },\n\n  /**\n   * Update the inverse covariance of the distribution\n   * @private\n   */\n  updateInverseCovariance() {\n    if (this.covarianceMode === 'full') {\n      const covMatrix = Matrix(this.dimension, this.dimension);\n\n      covMatrix.data = this.covariance.slice();\n      const inv = covMatrix.pinv();\n      this.covarianceDeterminant = inv.determinant;\n      this.inverseCovariance = inv.matrix.data;\n    } else { // DIAGONAL COVARIANCE\n      this.covarianceDeterminant = 1;\n      for (let d = 0; d < this.dimension; d += 1) {\n        if (this.covariance[d] <= 0) {\n          throw new Error('Non-invertible matrix');\n        }\n        this.inverseCovariance[d] = 1 / this.covariance[d];\n        this.covarianceDeterminant *= this.covariance[d];\n      }\n    }\n    if (this.bimodal) {\n      this.updateInverseCovarianceBimodal();\n    }\n  },\n\n  /**\n   * Convert to an ellipse allong two dimensions\n   *\n   * @param  {number} dimension1 first dimension\n   * @param  {number} dimension2 second dimension\n   * @return {Ellipse}\n   */\n  toEllipse(dimension1, dimension2) {\n    if (dimension1 >= this.dimension || dimension2 >= this.dimension) {\n      throw new Error('dimensions out of range');\n    }\n\n    const gaussianEllipse = {\n      x: 0,\n      y: 0,\n      width: 0,\n      height: 0,\n      angle: 0,\n    };\n    gaussianEllipse.x = this.mean[dimension1];\n    gaussianEllipse.y = this.mean[dimension2];\n\n    // Represent 2D covariance with square matrix\n    // |a b|\n    // |b c|\n    let a;\n    let b;\n    let c;\n    if (this.covarianceMode === 'full') {\n      a = this.covariance[(dimension1 * this.dimension) + dimension1];\n      b = this.covariance[(dimension1 * this.dimension) + dimension2];\n      c = this.covariance[(dimension2 * this.dimension) + dimension2];\n    } else {\n      a = this.covariance[dimension1];\n      b = 0;\n      c = this.covariance[dimension2];\n    }\n\n    // Compute Eigen Values to get width, height and angle\n    const trace = a + c;\n    const determinant = (a * c) - (b * b);\n    const eigenVal1 = 0.5 * (trace + Math.sqrt((trace ** 2) - (4 * determinant)));\n    const eigenVal2 = 0.5 * (trace - Math.sqrt((trace ** 2) - (4 * determinant)));\n    gaussianEllipse.width = Math.sqrt(5.991 * eigenVal1);\n    gaussianEllipse.height = Math.sqrt(5.991 * eigenVal2);\n    gaussianEllipse.angle = Math.atan(b / (eigenVal1 - c));\n    if (Number.isNaN(gaussianEllipse.angle)) {\n      gaussianEllipse.angle = Math.PI / 2;\n    }\n\n    return gaussianEllipse;\n  },\n\n  /**\n   * Modify the distribution along two dimensions given the equivalent values\n   * as an Ellipse representation.\n   *\n   * @param  {Ellipse} gaussianEllipse The Ellipse corresponding to the 2D\n   * covariance along the two target dimensions\n   * @param  {number} dimension1      first dimension\n   * @param  {number} dimension2      second dimension\n   */\n  fromEllipse(gaussianEllipse, dimension1, dimension2) {\n    if (dimension1 >= this.dimension || dimension2 >= this.dimension) {\n      throw new Error('dimensions out of range');\n    }\n\n    this.mean[dimension1] = gaussianEllipse.x;\n    this.mean[dimension2] = gaussianEllipse.y;\n\n    const eigenVal1 = (gaussianEllipse.width * gaussianEllipse.width) / 5.991;\n    const eigenVal2 = (gaussianEllipse.height * gaussianEllipse.height) / 5.991;\n    const tantheta = Math.tan(gaussianEllipse.angle);\n    const b = ((eigenVal1 - eigenVal2) * tantheta) / ((tantheta ** 2) + 1);\n    const c = eigenVal1 - (b / tantheta);\n    const a = eigenVal2 + (b / tantheta);\n\n    if (this.covarianceMode === 'full') {\n      this.covariance[(dimension1 * this.dimension) + dimension1] = a;\n      this.covariance[(dimension1 * this.dimension) + dimension2] = b;\n      this.covariance[(dimension2 * this.dimension) + dimension1] = b;\n      this.covariance[(dimension2 * this.dimension) + dimension2] = c;\n    } else {\n      this.covariance[dimension1] = a;\n      this.covariance[dimension2] = c;\n    }\n    this.updateInverseCovariance();\n  },\n};\n\n/**\n * Bimodal Gaussian Distribution Prototype, for Regression purposes\n *\n * @type {Object}\n * @property {boolean} bimodal           Specifies if the distribution is\n * bimodal (for regression use)\n * @property {number}  inputDimension    input dimension\n * @property {number}  outputDimension   output dimension\n * @property {number}  dimension         Total dimension\n * @property {Array}   mean              Distribution mean\n * @property {Array}   covariance        Distribution covariance\n * @property {Array}   inverseCovariance Inverse covariance\n * @property {Array}   inverseCovarianceInput Inverse covariance of the input\n * modality\n *\n * @ignore\n */\nconst bimodalGaussianPrototype = /** @lends GaussianDistribution */ {\n  /**\n   * Allocate the distribution\n   * @private\n   */\n  allocateBimodal() {\n    if (this.covarianceMode === 'full') {\n      this.inverseCovarianceInput = new Array(this.inputDimension ** 2).fill(0);\n    } else {\n      this.inverseCovarianceInput = new Array(this.inputDimension).fill(0);\n    }\n  },\n\n  /**\n   * Estimate the likelihood of an observation for the input modality only.\n   * Called by `likelihood` when relevant.\n   * @param  {Array} inputObservation observation (input modality only)\n   * @return {number}\n   * @private\n   */\n  inputLikelihood(inputObservation) {\n    if (this.covarianceDeterminantInput === 0) {\n      throw new Error('Covariance Matrix of input modality is not invertible');\n    }\n\n    let euclideanDistance = 0;\n    if (this.covarianceMode === 'full') {\n      for (let l = 0; l < this.inputDimension; l += 1) {\n        let tmp = 0;\n        for (let k = 0; k < this.inputDimension; k += 1) {\n          tmp += this.inverseCovarianceInput[(l * this.inputDimension) + k] *\n            (inputObservation[k] - this.mean[k]);\n        }\n        euclideanDistance += (inputObservation[l] - this.mean[l]) * tmp;\n      }\n    } else {\n      for (let l = 0; l < this.inputDimension; l += 1) {\n        euclideanDistance += this.inverseCovariance[l] *\n          (inputObservation[l] - this.mean[l]) *\n          (inputObservation[l] - this.mean[l]);\n      }\n    }\n\n    let p = Math.exp(-0.5 * euclideanDistance) /\n               Math.sqrt(this.covarianceDeterminantInput *\n                    ((2 * Math.PI) ** this.inputDimension));\n\n    if (p < 1e-180 || Number.isNaN(p) || Math.abs(p) === +Infinity) p = 1e-180;\n\n    return p;\n  },\n\n  /**\n   * Estimate the output values associated with an input observation by\n   * regression, given the distribution parameters.\n   *\n   * @todo Clarify the maths here.\n   *\n   * @param  {Array} inputObservation observation (input modality only)\n   * @return {Array} Output values\n   */\n  regression(inputObservation) {\n    const outputDimension = this.dimension - this.inputDimension;\n    const prediction = Array(outputDimension).fill(0);\n\n    if (this.covarianceMode === 'full') {\n      for (let d = 0; d < outputDimension; d += 1) {\n        prediction[d] = this.mean[this.inputDimension + d];\n        for (let e = 0; e < this.inputDimension; e += 1) {\n          let tmp = 0;\n          for (let f = 0; f < this.inputDimension; f += 1) {\n            tmp += this.inverseCovarianceInput[(e * this.inputDimension) + f] *\n              (inputObservation[f] - this.mean[f]);\n          }\n          prediction[d] += tmp *\n            this.covariance[((d + this.inputDimension) * this.dimension) + e];\n        }\n      }\n    } else {\n      for (let d = 0; d < outputDimension; d += 1) {\n        prediction[d] = this.mean[this.inputDimension + d];\n      }\n    }\n    return prediction;\n  },\n\n  /**\n   * Update the inverse covariance\n   * @private\n   */\n  updateInverseCovarianceBimodal() {\n    if (this.covarianceMode === 'full') {\n      const covMatrixInput = Matrix(this.inputDimension, this.inputDimension);\n      for (let d1 = 0; d1 < this.inputDimension; d1 += 1) {\n        for (let d2 = 0; d2 < this.inputDimension; d2 += 1) {\n          covMatrixInput.data[(d1 * this.inputDimension) + d2] =\n            this.covariance[(d1 * this.dimension) + d2];\n        }\n      }\n      const invInput = covMatrixInput.pinv();\n      this.covarianceDeterminantInput = invInput.determinant;\n      this.inverseCovarianceInput = invInput.matrix.data;\n    } else { // DIAGONAL COVARIANCE\n      this.covarianceDeterminantInput = 1;\n      for (let d = 0; d < this.inputDimension; d += 1) {\n        if (this.covariance[d] <= 0) {\n          throw new Error('Non-invertible matrix');\n        }\n        this.inverseCovarianceInput[d] = 1 / this.covariance[d];\n        this.covarianceDeterminantInput *= this.covariance[d];\n      }\n    }\n    this.updateOutputCovariance();\n  },\n\n  /**\n   * Update the output covariance\n   * @private\n   */\n  updateOutputCovariance() {\n    if (this.covarianceMode === 'diagonal') {\n      this.outputCovariance = this.covariance.slice(0, this.inputDimension);\n      return;\n    }\n\n    // CASE: FULL COVARIANCE\n    const covMatrixInput = Matrix(this.inputDimension, this.inputDimension);\n    for (let d1 = 0; d1 < this.inputDimension; d1 += 1) {\n      for (let d2 = 0; d2 < this.inputDimension; d2 += 1) {\n        covMatrixInput.data[(d1 * this.inputDimension) + d2] =\n          this.covariance[(d1 * this.dimension) + d2];\n      }\n    }\n    const inv = covMatrixInput.pinv();\n    const covarianceGS = Matrix(this.inputDimension, this.outputDimension);\n    for (let d1 = 0; d1 < this.inputDimension; d1 += 1) {\n      for (let d2 = 0; d2 < this.outputDimension; d2 += 1) {\n        covarianceGS.data[(d1 * this.outputDimension) + d2] =\n          this.covariance[(d1 * this.dimension) + this.inputDimension + d2];\n      }\n    }\n    const covarianceSG = Matrix(this.outputDimension, this.inputDimension);\n    for (let d1 = 0; d1 < this.outputDimension; d1 += 1) {\n      for (let d2 = 0; d2 < this.inputDimension; d2 += 1) {\n        covarianceSG.data[(d1 * this.inputDimension) + d2] =\n          this.covariance[((this.inputDimension + d1) * this.dimension) + d2];\n      }\n    }\n    const tmptmptmp = inv.matrix.product(covarianceGS);\n    const covarianceMod = covarianceSG.product(tmptmptmp);\n    this.outputCovariance = Array(this.outputDimension ** 2).fill(0);\n    for (let d1 = 0; d1 < this.outputDimension; d1 += 1) {\n      for (let d2 = 0; d2 < this.outputDimension; d2 += 1) {\n        this.outputCovariance[(d1 * this.outputDimension) + d2] =\n          this.covariance[((this.inputDimension + d1) * this.dimension) +\n            this.inputDimension + d2] -\n            covarianceMod.data[(d1 * this.outputDimension) + d2];\n      }\n    }\n  },\n};\n\n/**\n * Multivariate Gaussian Distribution factory function.\n * Full covariance, optionally multimodal with support for regression.\n *\n * @function\n * @param {Number} [inputDimension=1]      Dimension of the input modality\n * @param {Number} [outputDimension=0]     Dimension of the output\n * modality (positive for regression, otherwise 0 for recognition).\n * @param {String} [covarianceMode='full'] covariance mode (full vs\n * diagonal)\n * @return {baseGaussianPrototype|bimodalGaussianPrototype}\n *\n * @property {boolean} bimodal           Specifies if the distribution is\n * bimodal (for regression use)\n * @property {number}  inputDimension    input dimension\n * @property {number}  outputDimension   output dimension\n * @property {number}  dimension         Total dimension\n * @property {Array}   mean              Distribution mean\n * @property {Array}   covariance        Distribution covariance\n * @property {Array}   inverseCovariance Inverse covariance\n */\nexport default function GaussianDistribution(\n  inputDimension = 1,\n  outputDimension = 0,\n  covarianceMode = 'full',\n) {\n  const bimodal = outputDimension > 0;\n  const dimension = inputDimension + outputDimension;\n  const proto = bimodal ?\n    Object.assign({}, baseGaussianPrototype, bimodalGaussianPrototype) :\n    baseGaussianPrototype;\n  const data = Object.assign(\n    {\n      bimodal,\n      dimension,\n      inputDimension,\n      outputDimension,\n      covarianceMode,\n      covarianceDeterminant: 0,\n    },\n    bimodal ? { covarianceDeterminantInput: 0 } : {},\n  );\n  const dist = Object.assign(\n    Object.create(proto),\n    data,\n  );\n  dist.allocate();\n  return dist;\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/common/gaussian_distribution.js","/* eslint-disable no-use-before-define */\nconst kEpsilonPseudoInverse = 1.0e-9;\n\n/**\n * Matrix Prototype\n * @type {Object}\n * @property {Array} data Matrix data\n * @property {Number} ncols Number of columns\n * @property {Number} nrows Number of rows\n *\n * @ignore\n */\nconst matrixPrototype = /** @lends Matrix */ {\n  /**\n   * Compute the Sum of the matrix\n   * @return {Number} Sum of all elements in the matrix\n   */\n  sum() {\n    return this.data.reduce((a, b) => a + b, 0);\n  },\n\n  /**\n   * Compute the transpose matrix\n   * @return {Matrix}\n   */\n  transpose() {\n    const out = Matrix(this.ncols, this.nrows);\n    for (let i = 0; i < this.ncols; i += 1) {\n      for (let j = 0; j < this.nrows; j += 1) {\n        out.data[(i * this.nrows) + j] = this.data[(j * this.ncols) + i];\n      }\n    }\n    return out;\n  },\n\n  /**\n   * Compute the product of matrices\n   * @param  {Matrix} mat Second matrix\n   * @return {Matrix}     Product of the current matrix by `mat`\n   */\n  product(mat) {\n    if (this.ncols !== mat.nrows) {\n      throw new Error('Wrong dimensions for matrix product');\n    }\n    const out = Matrix(this.nrows, mat.ncols);\n    for (let i = 0; i < this.nrows; i += 1) {\n      for (let j = 0; j < mat.ncols; j += 1) {\n        out.data[(i * mat.ncols) + j] = 0;\n        for (let k = 0; k < this.ncols; k += 1) {\n          out.data[(i * mat.ncols) + j] +=\n            this.data[(i * this.ncols) + k] * mat.data[(k * mat.ncols) + j];\n        }\n      }\n    }\n    return out;\n  },\n\n  /**\n   * Compute the Pseudo-Inverse of a Matrix\n   * @param  {Number} determinant Determinant (computed with the inversion)\n   * @return {Matrix}             Pseudo-inverse of the matrix\n   */\n  pinv() {\n    if (this.nrows === this.ncols) {\n      return this.gaussJordanInverse();\n    }\n\n    const transp = this.transpose();\n    if (this.nrows >= this.ncols) {\n      const prod = transp.product(this);\n      const { determinant, matrix: dst } = prod.gaussJordanInverse();\n      return { determinant, matrix: dst.product(transp) };\n    }\n    const prod = this.product(transp);\n    const { determinant, matrix: dst } = prod.gaussJordanInverse();\n    return { determinant, matrix: transp.product(dst) };\n  },\n\n  /**\n   * Compute the Gauss-Jordan Inverse of a Square Matrix\n   * !!! Determinant (computed with the inversion\n   * @private\n   */\n  gaussJordanInverse() {\n    if (this.nrows !== this.ncols) {\n      throw new Error('Gauss-Jordan inversion: Cannot invert Non-square matrix');\n    }\n    let determinant = 1;\n    const mat = Matrix(this.nrows, this.ncols * 2);\n    const newMat = Matrix(this.nrows, this.ncols * 2);\n    const n = this.nrows;\n\n    // Create matrix\n    for (let i = 0; i < n; i += 1) {\n      for (let j = 0; j < n; j += 1) {\n        mat.data[(i * 2 * n) + j] = this.data[(i * n) + j];\n      }\n      mat.data[(i * 2 * n) + n + i] = 1;\n    }\n\n    for (let k = 0; k < n; k += 1) {\n      let i = k;\n      while (Math.abs(mat.data[(i * 2 * n) + k]) < kEpsilonPseudoInverse) {\n        i += 1;\n        if (i === n) {\n          throw new Error('Non-invertible matrix');\n        }\n      }\n      determinant *= mat.data[(i * 2 * n) + k];\n\n      // if found > Exchange lines\n      if (i !== k) {\n        mat.swapLines(i, k);\n      }\n\n      newMat.data = mat.data.slice();\n\n      for (let j = 0; j < 2 * n; j += 1) {\n        newMat.data[(k * 2 * n) + j] /= mat.data[(k * 2 * n) + k];\n      }\n      for (let ii = 0; ii < n; ii += 1) {\n        if (ii !== k) {\n          for (let j = 0; j < 2 * n; j += 1) {\n            newMat.data[(ii * 2 * n) + j] -=\n                mat.data[(ii * 2 * n) + k] *\n                newMat.data[(k * 2 * n) + j];\n          }\n        }\n      }\n      mat.data = newMat.data.slice();\n    }\n\n    const dst = Matrix(this.nrows, this.ncols);\n    for (let i = 0; i < n; i += 1) {\n      for (let j = 0; j < n; j += 1) {\n        dst.data[(i * n) + j] = mat.data[(i * 2 * n) + n + j];\n      }\n    }\n    return { determinant, matrix: dst };\n  },\n\n  /**\n   * Swap 2 lines of the matrix\n   * @param  {[type]} i index of the first line\n   * @param  {[type]} j index of the second line\n   * @private\n   */\n  swapLines(i, j) {\n    for (let k = 0; k < this.ncols; k += 1) {\n      const tmp = this.data[(i * this.ncols) + k];\n      this.data[(i * this.ncols) + k] = this.data[(j * this.ncols) + k];\n      this.data[(j * this.ncols) + k] = tmp;\n    }\n  },\n\n  /**\n   * Swap 2 columns of the matrix\n   * @param  {[type]} i index of the first column\n   * @param  {[type]} j index of the second column\n   * @private\n   */\n  swapColumns(i, j) {\n    for (let k = 0; k < this.nrows; k += 1) {\n      const tmp = this.data[(k * this.ncols) + i];\n      this.data[(k * this.ncols) + i] = this.data[(k * this.ncols) + j];\n      this.data[(k * this.ncols) + j] = tmp;\n    }\n  },\n};\n\n/**\n * Create a matrix\n *\n * @function\n * @param       {Number} [nrows=0]  Number of rows\n * @param       {Number} [ncols=-1] Number of columns\n * @return {matrixPrototype}\n *\n * @property {Array} data Matrix data\n * @property {Number} ncols Number of columns\n * @property {Number} nrows Number of rows\n */\nexport default function Matrix(nrows = 0, ncols = -1) {\n  const nc = ncols < 0 ? nrows : ncols;\n  return Object.assign(\n    Object.create(matrixPrototype), //\n    {\n      nrows,\n      ncols: nc,\n      data: Array(nrows * nc).fill(0),\n    },\n  );\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/common/matrix.js","import ModelBase from '../core/model_base_mixin';\nimport withKMeansTraining from '../kmeans/kmeans_training_mixin';\n\n/**\n * GMM Training Prototype\n * @type {Object}\n * @ignore\n */\nconst gmmTrainerPrototype = /** @lends withGMMTraining */ {\n  /**\n   * Initialize the EM Training process\n   * @param  {TrainingSet} trainingSet Training set\n   */\n  initTraining(trainingSet) {\n    this.allocate();\n    this.initParametersToDefault(trainingSet.standardDeviation());\n    this.initMeansWithKMeans(trainingSet);\n    this.initCovariances(trainingSet);\n    this.regularize();\n    this.updateInverseCovariances();\n  },\n\n  /**\n   * Initialize the model parameters to their default values\n   * @param  {Array<Number>} dataStddev Standard deviation of the training data\n   * @private\n   */\n  initParametersToDefault(dataStddev) {\n    let normCoeffs = 0;\n    this.currentRegularization = dataStddev.map(std => Math.max(\n      this.params.regularization.absolute,\n      this.params.regularization.relative * std,\n    ));\n    for (let c = 0; c < this.params.gaussians; c += 1) {\n      if (this.params.covarianceMode === 'full') {\n        this.params.components[c].covariance = Array(this.params.dimension ** 2)\n          .fill(this.params.regularization.absolute / 2);\n      } else {\n        this.params.components[c].covariance = Array(this.params.dimension).fill(0);\n      }\n      this.params.components[c].regularize(this.currentRegularization);\n      this.params.mixtureCoeffs[c] = 1 / this.params.gaussians;\n      normCoeffs += this.params.mixtureCoeffs[c];\n    }\n    for (let c = 0; c < this.params.gaussians; c += 1) {\n      this.params.mixtureCoeffs[c] /= normCoeffs;\n    }\n  },\n\n  /**\n   * Initialize the means of the model using a K-Means algorithm\n   *\n   * @see withKMeansTraining\n   *\n   * @param  {TrainingSet} trainingSet training set\n   * @private\n   */\n  initMeansWithKMeans(trainingSet) {\n    if (!trainingSet || trainingSet.empty()) return;\n    const kmeans = withKMeansTraining(\n      ModelBase({\n        inputDimension: this.params.inputDimension,\n        outputDimension: this.params.outputDimension,\n      }),\n      this.params.gaussians,\n      { initialization: 'data' },\n    );\n    const kmeansParams = kmeans.train(trainingSet);\n    for (let c = 0; c < this.params.gaussians; c += 1) {\n      this.params.components[c].mean = kmeansParams.centers[c];\n    }\n  },\n\n  /**\n   * Initialize the covariances of the model from the training set\n   *\n   * @param  {TrainingSet} trainingSet training set\n   * @private\n   */\n  initCovariances(trainingSet) {\n    // TODO: simplify with covariance symmetricity\n    // TODO: If Kmeans, covariances from cluster members\n    if (!trainingSet || trainingSet.empty()) return;\n\n    for (let n = 0; n < this.params.gaussians; n += 1) {\n      this.params.components[n].covariance = Array((this.params.covarianceMode === 'full') ? this.params.dimension ** 2 : this.params.dimension).fill(0);\n    }\n\n    const gmeans = Array(this.params.gaussians * this.params.dimension).fill(0);\n    const factor = Array(this.params.gaussians).fill(0);\n    trainingSet.forEach((phrase) => {\n      const step = Math.floor(phrase.length / this.params.gaussians);\n      let offset = 0;\n      for (let n = 0; n < this.params.gaussians; n += 1) {\n        for (let t = 0; t < step; t += 1) {\n          for (let d1 = 0; d1 < this.params.dimension; d1 += 1) {\n            gmeans[(n * this.params.dimension) + d1] += phrase.get(offset + t, d1);\n            if (this.params.covarianceMode === 'full') {\n              for (let d2 = 0; d2 < this.params.dimension; d2 += 1) {\n                this.params.components[n]\n                  .covariance[(d1 * this.params.dimension) + d2] +=\n                  phrase.get(offset + t, d1) * phrase.get(offset + t, d2);\n              }\n            } else {\n              this.params.components[n].covariance[d1] +=\n                phrase.get(offset + t, d1) ** 2;\n            }\n          }\n        }\n        offset += step;\n        factor[n] += step;\n      }\n    });\n\n    for (let n = 0; n < this.params.gaussians; n += 1) {\n      for (let d1 = 0; d1 < this.params.dimension; d1 += 1) {\n        gmeans[(n * this.params.dimension) + d1] /= factor[n];\n        if (this.params.covarianceMode === 'full') {\n          for (let d2 = 0; d2 < this.params.dimension; d2 += 1) {\n            this.params.components[n].covariance[(d1 * this.params.dimension) + d2] /= factor[n];\n          }\n        } else {\n          this.params.components[n].covariance[d1] /= factor[n];\n        }\n      }\n    }\n\n    for (let n = 0; n < this.params.gaussians; n += 1) {\n      for (let d1 = 0; d1 < this.params.dimension; d1 += 1) {\n        if (this.params.covarianceMode === 'full') {\n          for (let d2 = 0; d2 < this.params.dimension; d2 += 1) {\n            this.params.components[n].covariance[(d1 * this.params.dimension) + d2] -=\n              gmeans[(n * this.params.dimension) + d1] *\n              gmeans[(n * this.params.dimension) + d2];\n          }\n        } else {\n          this.params.components[n].covariance[d1] -=\n            gmeans[(n * this.params.dimension) + d1] ** 2;\n        }\n      }\n    }\n  },\n\n  /**\n   * Update the EM Training process (1 EM iteration).\n   * @param  TrainingSet trainingSet training set\n   */\n  updateTraining(trainingSet) {\n    let logProb = 0;\n    let totalLength = 0;\n    trainingSet.forEach((phrase) => {\n      totalLength += phrase.length;\n    });\n    const phraseIndices = Object.keys(trainingSet.phrases);\n\n    const p = Array.from(\n      Array(this.params.gaussians),\n      () => new Array(totalLength).fill(0),\n    );\n    const E = Array(this.params.gaussians).fill(0);\n    let tbase = 0;\n\n    trainingSet.forEach((phrase) => {\n      for (let t = 0; t < phrase.length; t += 1) {\n        let normConst = 0;\n        for (let c = 0; c < this.params.gaussians; c += 1) {\n          p[c][tbase + t] = this.componentLikelihood(phrase.getFrame(t), c);\n\n          if (p[c][tbase + t] === 0 ||\n            Number.isNaN(p[c][tbase + t]) ||\n            p[c][tbase + t] === +Infinity) {\n            p[c][tbase + t] = 1e-100;\n          }\n          normConst += p[c][tbase + t];\n        }\n        for (let c = 0; c < this.params.gaussians; c += 1) {\n          p[c][tbase + t] /= normConst;\n          E[c] += p[c][tbase + t];\n        }\n        logProb += Math.log(normConst);\n      }\n      tbase += phrase.length;\n    });\n\n    // Estimate Mixture coefficients\n    for (let c = 0; c < this.params.gaussians; c += 1) {\n      this.params.mixtureCoeffs[c] = E[c] / totalLength;\n    }\n\n    // Estimate means\n    for (let c = 0; c < this.params.gaussians; c += 1) {\n      for (let d = 0; d < this.params.dimension; d += 1) {\n        this.params.components[c].mean[d] = 0;\n        tbase = 0;\n        for (let pix = 0; pix < phraseIndices.length; pix += 1) {\n          const phrase = trainingSet.phrases[phraseIndices[pix]];\n          for (let t = 0; t < phrase.length; t += 1) {\n            this.params.components[c].mean[d] +=\n              p[c][tbase + t] * phrase.get(t, d);\n          }\n          tbase += phrase.length;\n        }\n        this.params.components[c].mean[d] /= E[c];\n      }\n    }\n\n    // estimate covariances\n    if (this.params.covarianceMode === 'full') {\n      for (let c = 0; c < this.params.gaussians; c += 1) {\n        for (let d1 = 0; d1 < this.params.dimension; d1 += 1) {\n          for (let d2 = d1; d2 < this.params.dimension; d2 += 1) {\n            this.params.components[c].covariance[(d1 * this.params.dimension) + d2] = 0;\n            tbase = 0;\n            for (let pix = 0; pix < phraseIndices.length; pix += 1) {\n              const phrase = trainingSet.phrases[phraseIndices[pix]];\n              for (let t = 0; t < phrase.length; t += 1) {\n                this.params.components[c].covariance[(d1 * this.params.dimension) + d2] +=\n                  p[c][tbase + t] *\n                  (phrase.get(t, d1) - this.params.components[c].mean[d1]) *\n                  (phrase.get(t, d2) - this.params.components[c].mean[d2]);\n              }\n              tbase += phrase.length;\n            }\n            this.params.components[c].covariance[(d1 * this.params.dimension) + d2] /= E[c];\n            if (d1 !== d2) {\n              this.params.components[c].covariance[(d2 * this.params.dimension) + d1] =\n                this.params.components[c].covariance[(d1 * this.params.dimension) + d2];\n            }\n          }\n        }\n      }\n    } else {\n      for (let c = 0; c < this.params.gaussians; c += 1) {\n        for (let d1 = 0; d1 < this.params.dimension; d1 += 1) {\n          this.params.components[c].covariance[d1] = 0;\n          tbase = 0;\n          for (let pix = 0; pix < phraseIndices.length; pix += 1) {\n            const phrase = trainingSet.phrases[phraseIndices[pix]];\n            for (let t = 0; t < phrase.length; t += 1) {\n              const value = (phrase.get(t, d1) - this.params.components[c].mean[d1]);\n              this.params.components[c].covariance[d1] +=\n                    p[c][tbase + t] * value * value;\n            }\n            tbase += phrase.length;\n          }\n          this.params.components[c].covariance[d1] /= E[c];\n        }\n      }\n    }\n\n    this.regularize();\n    this.updateInverseCovariances();\n\n    return logProb;\n  },\n\n  /**\n   * Terminate the EM Training process\n   */\n  terminateTraining() {},\n};\n\n/**\n * Add GMM Training capabilities to a GMM Model\n * @param  {GMMBase} o               Source GMM Model\n * @param  {Number} [gaussians=1]    Number of Gaussian components\n * @param  {Object} [regularization] Regularization parameters\n * @param  {Number} [regularization.absolute=1e-3] Absolute regularization\n * @param  {Number} [regularization.relative=1e-2] Relative Regularization\n (relative to the training set's variance along each dimension)\n * @param  {String} [covarianceMode='full'] Covariance mode ('full' or diagonal)\n * @return {BMMBase}\n */\nexport default function withGMMTraining(\n  o,\n  gaussians = 1,\n  regularization = { absolute: 1e-3, relative: 1e-2 },\n  covarianceMode = 'full',\n) {\n  if (!Object.keys(o).includes('params')) {\n    throw new Error('The base object must include a standard set of parameters (`params` key), @see `ModelBase`.');\n  }\n  return Object.assign(\n    o,\n    gmmTrainerPrototype,\n    {\n      params: {\n        ...o.params,\n        gaussians,\n        regularization,\n        covarianceMode,\n      },\n    },\n  );\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/gmm/gmm_training_mixin.js","/**\n * Compute the euclidean distance between to vectors\n * @param  {Array} v1\n * @param  {Array} v2\n * @return {number}\n */\nexport default function euclidean(v1, v2) {\n  return Math.sqrt(v1\n    .map((x1, i) => (x1 - v2[i]) ** 2)\n    .reduce((a, x) => (a + x), 0));\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/common/euclidean.js","import ModelBase from './model_base_mixin';\n\n/**\n * Multiclass Models Mixin\n * @type {Object}\n * @ignore\n */\nconst MulticlassBasePrototype = /** @lends MulticlassModelBase */{\n  /**\n   * Get the number of classes in the model\n   * @return {number} number of classes\n   */\n  size() {\n    return this.models.size;\n  },\n\n  /**\n   * Check if a class with the given label exists\n   * @param  {string} label Class label\n   * @return {boolean}\n   */\n  includes(label) {\n    return Object.keys(this.models).includes(label);\n  },\n\n  /**\n   * Remove a class by label\n   * @param  {string} label Class label\n   */\n  remove(label) {\n    if (this.includes(label)) {\n      delete this.models[label];\n    }\n  },\n};\n\n/**\n * Create an abstract Multiclass Model\n * @param       {number]} inputDimension  input dimension\n * @param       {number]} outputDimension output dimension\n * @param       {Object} parameters       additional parameters to copy\n * @function\n */\nexport default function MulticlassModelBase({\n  inputDimension,\n  outputDimension,\n  ...parameters\n}) {\n  return Object.assign(\n    ModelBase({ inputDimension, outputDimension, ...parameters }),\n    MulticlassBasePrototype,\n  );\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/core/multiclass_mixin.js","/**\n * Add multiclass training capabilities to a model. It takes as argument\n * the training function called to train each class of the training set.\n *\n * @param  {MulticlassModelBase} o Source model\n * @param  {Function}  trainingFunction Training function for a single class\n * @return {MulticlassModelBase}\n */\nexport default function withMulticlassTraining(\n  o,\n  trainingFunction,\n) {\n  return Object.assign(\n    o,\n    /** @lends withMulticlassTraining */ {\n      /**\n       * Train the model, optionally specifying a set of classes to train\n       *\n       * @param  {TrainingSet} trainingSet   Training data set\n       * @param  {undefined|Array<String>} [labels=undefined] Labels\n       * corresponding to the classes to be trained (all if unspecified)\n       * @return {Object} the parameters of the trained model\n       *\n       * @throws {Error} if the training set is empty\n       * @throws {Error} if one of the specified class does not exist\n       */\n      train(trainingSet, labels = undefined) {\n        if (!trainingSet || trainingSet.empty()) {\n          throw new Error('The training set is empty');\n        }\n        if (labels) {\n          labels.forEach((l) => {\n            if (!this.includes(l)) {\n              throw new Error(`Class labeled ${l} does not exist`);\n            }\n          });\n        }\n\n        this.params.classes = {};\n        const labs = labels || trainingSet.labels();\n        labs.forEach((label) => {\n          const ts = trainingSet.getPhrasesOfClass(label);\n          // console.log(ts);\n          this.params.classes[label] = trainingFunction(ts);\n        });\n        return this.params;\n      },\n    },\n  );\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/core/multiclass_training_mixin.js","import { isBaseModel } from './model_base_mixin';\nimport CircularBuffer from '../common/circular_buffer';\n\n/**\n * Prototype for models with prediction capabilities\n * @param  {Boolean} bimodal Specifies whether the model is bimodal\n * @return {Object}\n * @ignore\n */\nconst predictionBasePrototype = bimodal => (/** @lends withAbtractPrediction */{\n  /**\n   * Likelihood Buffer\n   * @type {CircularBuffer}\n   * @private\n   */\n  likelihoodBuffer: CircularBuffer(1),\n\n  /**\n   * Likelihood Window (used to smooth the log-likelihoods over several frames)\n   * @return {Number}\n   */\n  get likelihoodWindow() {\n    return this.likelihoodBuffer.capacity;\n  },\n\n  /**\n   * Likelihood Window (used to smooth the log-likelihoods over several frames)\n   * @param {Number} [lw] Size (in frames) of the likelihood smoothing window\n   */\n  set likelihoodWindow(lw) {\n    this.likelihoodBuffer = CircularBuffer(lw);\n  },\n\n  /**\n   * Reset the prediction process\n   * @return {Modelbase} the model\n   */\n  reset() {\n    this.likelihoodBuffer.clear();\n    return this;\n  },\n\n  /**\n   * Update the predictions with a new observation\n   * @param  {Array<Number>} observation Observation vector\n   * @return {Object} Prediction results\n   *\n   * @todo document results data structure\n   */\n  predict(observation) {\n    const likelihood = this.likelihood(observation);\n    if (bimodal) {\n      this.regression(observation);\n    }\n    this.updateResults(likelihood);\n    return this.results;\n  },\n\n  /**\n   * Update the prediction results\n   * @param  {Number} instantLikelihood Instantaneous likelihood\n   * @private\n   */\n  updateResults(instantLikelihood) {\n    this.results.instantLikelihood = instantLikelihood;\n    this.likelihoodBuffer.push(Math.log(instantLikelihood));\n    this.results.logLikelihood = 0;\n    const bufSize = this.likelihoodBuffer.length;\n    for (let i = 0; i < bufSize; i += 1) {\n      this.results.logLikelihood += this.likelihoodBuffer.get(i);\n    }\n    this.results.logLikelihood /= bufSize;\n  },\n});\n\n/**\n * Add ABSTRACT prediction capabilities to an existing model\n * @param  {Modelbase} o                 Source model\n * @param  {Number} [likelihoodWindow=1] Size of the likelihood smoothing window\n * @return {Modelbase}\n */\nexport default function withAbtractPrediction(o, likelihoodWindow = 1) {\n  if (!isBaseModel(o)) {\n    throw new Error('The base object must include a standard set of parameters (`params` key), @see `ModelBase`.');\n  }\n  const results = Object.assign(\n    { instantLikelihood: 0, logLikelihood: 0 },\n    o.params.bimodal ? { outputValues: [], outputCovariance: [] } : {},\n  );\n  return Object.assign(\n    o,\n    predictionBasePrototype(o.params.bimodal),\n    { results, likelihoodBuffer: CircularBuffer(likelihoodWindow) },\n  );\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/core/prediction_mixin.js","/**\n * Circular Buffer prototype\n *\n * @property {number}  capacity Buffer capacity\n * @property {number}  length Current buffer length\n * @property {boolean} full Specifies if the buffer is full\n *\n * @ignore\n */\nconst circularBufferPrototype = /** @lends CircularBuffer */ {\n  /**\n   * Clear the buffer contents\n   */\n  clear() {\n    this.length = 0;\n    this.index = 0;\n    this.full = false;\n    this.buffer = [];\n  },\n\n  /**\n   * Push a value to the buffer\n   * @param  {*} value data value (any type)\n   */\n  push(value) {\n    if (this.full) {\n      this.buffer[this.index] = value;\n      this.index = (this.index + 1) % this.capacity;\n    } else {\n      this.buffer.push(value);\n      this.length += 1;\n      this.full = (this.length === this.capacity);\n    }\n  },\n\n  /**\n   * Get the value at a given index\n   * @param  {number} idx data index\n   * @return {anything}   value at index\n   */\n  get(idx) {\n    return this.buffer[(idx + this.index) % this.capacity];\n  },\n\n  /**\n   * Fill the buffer with a constant value\n   * @param  {*} value data value (any type)\n   */\n  fill(value) {\n    this.length = this.capacity;\n    this.index = 0;\n    this.full = true;\n    this.buffer = Array(this.capacity).fill(value);\n  },\n\n  /**\n   * Iterate over the buffer's data\n   * @param  {Function} callback Callback function\n   * (@see Array.prototype.forEach).\n   */\n  forEach(callback) {\n    for (let i = 0; i < this.length; i += 1) {\n      callback(this.buffer[(i + this.index) % this.capacity], i);\n    }\n  },\n\n  /**\n   * Get an array of the buffer current values (ordered)\n   * @return {Array} Buffer contents\n   */\n  values() {\n    return this.buffer.slice(this.index)\n      .concat(this.buffer.slice(0, this.index));\n  },\n};\n\n/**\n * Circular Buffer Data Structure (any data type)\n * @param  {number} capacity Buffer capacity\n * @return {circularBufferPrototype}\n * @function\n *\n * @property {number}  capacity Buffer capacity\n * @property {number}  length Current buffer length\n * @property {boolean} full Specifies if the buffer is full\n */\nexport default function CircularBuffer(capacity) {\n  const buffer = Object.create(circularBufferPrototype);\n  buffer.capacity = capacity;\n  buffer.clear();\n  return buffer;\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/common/circular_buffer.js","import validateParameters from '../common/validation';\nimport { isBaseModel } from '../core/model_base_mixin';\n\nconst gmmParameterSpec = gaussians => ({\n  gaussians: {\n    required: true,\n    check: { min: 1 },\n  },\n  regularization: {\n    required: true,\n    check: ({ absolute, relative }) =>\n      (absolute && relative && absolute > 0 && relative > 0),\n  },\n  covarianceMode: {\n    required: true,\n    check: ['full', 'diagonal'],\n  },\n  mixtureCoeffs: {\n    required: true,\n    check: m => m.length === gaussians,\n  },\n  components: {\n    required: true,\n    check: c => c.length === gaussians,\n  },\n});\n\n/**\n * Add GMM prediction capabilities to a single-class model. Mostly, this checks\n * the validity of the model parameters\n *\n * @todo validate gaussian components\n *\n * @param  {GMMBaseModel} o Source Model\n * @return {GMMBaseModel}\n *\n * @throws {Error} is o is not a ModelBase\n */\nexport default function withGMMPrediction(o) {\n  if (!isBaseModel(o)) {\n    throw new Error('The base object must include a standard set of parameters (`params` key), @see `ModelBase`.');\n  }\n  validateParameters('GMM', gmmParameterSpec(o.params.gaussians), o.params);\n  return Object.assign(\n    o,\n    { beta: new Array(o.params.gaussians).fill(0) },\n  );\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/gmm/gmm_prediction_mixin.js","/**\n * Check if the specification is respected for a given parameter and value,\n * and clip if relevant.\n *\n * @ignore\n *\n * @param  {String}        model      Stream Operator Name (for logging)\n * @param  {String}        parameter     Attribute name\n * @param  {Specification} specification Attribute specification\n * @param  {*}             value         Attribute value\n * @return {*}                           Type-checked parameter value\n */\nfunction checkSpec(model, parameter, specification, value) {\n  if (!specification) return;\n  if (specification.constructor === Array && !specification.includes(value)) {\n    throw new Error(`Attribute '${parameter}' (value: '${value}') is not allowed for model '${model}' (options: [${specification}]).`);\n  } else if (specification.constructor === Object) {\n    if (Object.keys(specification).includes('min') && value < specification.min) {\n      throw new Error(`Attribute '${parameter}' (value: ${value}) is inferior to the minimum required value of ${specification.min} for model '${model}'.`);\n    }\n    if (Object.keys(specification).includes('max') && value > specification.max) {\n      throw new Error(`Attribute '${parameter}' (value: ${value}) is superior to the maximum required value of ${specification.min} for model '${model}'.`);\n    }\n  } else if (typeof specification === 'function') {\n    if (!specification(value)) {\n      throw new Error(`Attribute '${parameter}' (value: ${value}) is incompatible with model '${model}'.`);\n    }\n  }\n}\n\n/**\n * Check the parameters of a model and return the parameters of the\n * output stream.\n *\n * The specification should be a structure of the form:\n * ```\n * const streamSpecification = {\n *   <parameter name>: {\n *     required: <boolean>,\n *     check: <null || Array || { min: <minimum value>, max: <maximum value>} || Function >,\n *     transform: Function,\n *   },\n * };\n * ```\n *\n * @param  {String} model      Name of the model for logging\n * @param  {Object} specification I/O Stream Specification\n * @param  {Object} values        Attributes of the input stream\n * @return {Object}               Attributes of the output stream\n *\n * @example\n * import setupStreamAttributes from 'stream';\n *\n * const specification = {\n *   type: {\n *     required: false,\n *     check: null,\n *     transform: x => x || null,\n *   },\n *   format: {\n *     required: true,\n *     check: ['scalar', 'vector'],\n *     transform: x => x,\n *   },\n *   size: {\n *     required: true,\n *     check: { min: 1 },\n *     transform: x => 2 * x,\n *   },\n *   stuff: {\n *     required: true,\n *     check: x => Math.log2(x) === Math.floor(Math.log2(x)),\n *     transform: x => Math.log2(x),\n *   },\n * };\n *\n * const values = {\n *   type: 'anything',\n *   format: 'vector',\n *   size: 3,\n *   stuff: 8,\n *   another: 'one',\n * };\n *\n * setupStreamAttributes('module name', specification, values);\n * // Returns:\n * // {\n * //   type: 'anything',\n * //   format: 'vector',\n * //   size: 6,\n * //   stuff: 3,\n * //   another: 'one',\n * // }\n */\nexport default function validateParameters(model, specification, values) {\n  const parameters = Object.assign({}, values);\n  Object.keys(specification).forEach((attr) => {\n    const spec = specification[attr];\n\n    // Check for required parameters\n    if (spec.required && !Object.keys(values).includes(attr)) {\n      throw new Error(`Stream parameter '${attr}' is required for model '${model}'.`);\n    }\n\n    // Check the validity of the input parameters\n    checkSpec(model, attr, spec.check, values[attr]);\n\n    parameters[attr] = spec.transform ?\n      spec.transform(values[attr]) :\n      values[attr];\n  });\n  return parameters;\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/common/validation.js","import { isBaseModel } from './model_base_mixin';\n\n/**\n * Multiclass prediction mixin\n * @type {Object}\n * @ignore\n */\nconst MulticlassPredictionBasePrototype =\n/** @lends withMulticlassPrediction */\n{\n  reset() {\n    Object.values(this.models).forEach(m => m.reset());\n    this.results = {\n      labels: [],\n      instantLikelihoods: [],\n      smoothedLikelihoods: [],\n      smoothedLogLikelihoods: [],\n      smoothedNormalizedLikelihoods: [],\n      likeliest: null,\n      classes: {},\n    };\n    if (this.params.bimodal) {\n      this.resetBimodal();\n    }\n  },\n\n  predict(observation) {\n    Object.values(this.models).forEach(m => m.predict(observation));\n    this.updateResults();\n  },\n\n  updateResults() {\n    const labs = Object.keys(this.models).sort();\n    this.results.labels = labs;\n    let normInstant = 0;\n    let normSmoothed = 0;\n    let maxLogLikelihood = -Infinity;\n    this.results.classes = labs\n      .map((lab, i) => {\n        this.results.instantLikelihoods[i] =\n          this.models[lab].results.instantLikelihood;\n        this.results.smoothedLogLikelihoods[i] =\n          this.models[lab].results.logLikelihood;\n        this.results.smoothedLikelihoods[i] =\n          Math.exp(this.results.smoothedLogLikelihoods[i]);\n        normInstant += this.results.instantLikelihoods[i];\n        normSmoothed += this.results.smoothedLikelihoods[i];\n        if (this.results.smoothedLogLikelihoods[i] > maxLogLikelihood) {\n          maxLogLikelihood = this.results.smoothedLogLikelihoods[i];\n          this.results.likeliest = lab;\n        }\n        return { [lab]: this.models[lab].results };\n      })\n      .reduce((o, x) => ({ ...o, ...x }), {});\n    this.results.smoothedNormalizedLikelihoods =\n      this.results.smoothedLikelihoods.map(x => x / normSmoothed);\n    this.results.instantNormalizedLikelihoods =\n      this.results.instantLikelihoods.map(x => x / normInstant);\n    if (this.params.bimodal) {\n      this.updateRegressionResults();\n    }\n  },\n};\n\nconst MulticlassPredictionBimodalPrototype = {\n  resetBimodal() {\n    this.results.outputValues = [];\n    this.results.outputCovariance = [];\n  },\n\n  updateRegressionResults() {\n    if (this.params.multiClassRegressionEstimator === 'likeliest') {\n      this.results.outputValues =\n        this.models[this.results.likeliest].results.outputValues;\n      this.results.outputCovariance =\n        this.models[this.results.likeliest].results.outputCovariance;\n    } else if (this.params.multiClassRegressionEstimator === 'mixture') {\n      this.results.outputValues = Array(this.outputDimension).fill(0);\n      this.results.outputCovariance = Array(this.outputDimension ** (this.configuration.covarianceMode === 'full' ? 2 : 1)).fill(0);\n      this.results.labels.forEach((lab) => {\n        this.results.outputValues.map((x, i) => x + (\n          this.results.smoothedNormalizedLikelihoods[i] *\n          this.models[lab].results.outputValues[i]\n        ));\n        this.results.outputCovariance.map((x, i) => x + (\n          this.results.smoothedNormalizedLikelihoods[i] *\n          this.models[lab].results.outputCovariance[i]\n        ));\n      });\n    } else {\n      throw new Error('Unknown regression estimator, use `likeliest` or `mixture`');\n    }\n  },\n};\n\n/**\n * Add multiclass prediction capabilities to a multiclass model\n * @param  {MulticlassModelBase} o Source model\n * @param  {String} [multiClassRegressionEstimator='likeliest'] Type of\n * regression estimator:\n * - `likeliest` selects the output values from the likeliest class\n * - `mixture` computes the output values as the weighted sum of the\n * contributions of each class, weighed by their normalized likelihood\n * @return {MulticlassPredictionBasePrototype}\n * @function\n */\nexport default function withMulticlassPrediction(o, multiClassRegressionEstimator = 'likeliest') {\n  if (!isBaseModel(o)) {\n    throw new Error('The base object must include a standard set of parameters (`params` key), @see `ModelBase`.');\n  }\n  const m = Object.assign(\n    o,\n    MulticlassPredictionBasePrototype,\n    o.params.bimodal ? MulticlassPredictionBimodalPrototype : {},\n  );\n  m.params.multiClassRegressionEstimator = multiClassRegressionEstimator;\n  return m;\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/core/multiclass_prediction_mixin.js","import ModelBase from '../core/model_base_mixin';\nimport withKMeansTraining from './kmeans_training_mixin';\n\n/**\n * Train a K-Means model.\n *\n * @todo K-Means details\n *\n * @param  {TrainingSet} trainingSet           training set\n * @param  {number} clusters                   Number of clusters\n * @param  {Object} [trainingConfig=undefined] Training configuration\n * @return {Object}                            K-Means parameters\n */\nexport default function trainKmeans(\n  trainingSet,\n  clusters,\n  trainingConfig = undefined,\n) {\n  const { inputDimension, outputDimension } = trainingSet;\n  const model = withKMeansTraining(\n    ModelBase({\n      inputDimension,\n      outputDimension,\n    }),\n    clusters,\n    trainingConfig,\n  );\n  return model.train(trainingSet);\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/kmeans/index.js"],"sourceRoot":""}