{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///webpack/bootstrap 021d710422f92952db1e","webpack:///./src/core/model_base_mixin.js","webpack:///./src/gmm/index.js","webpack:///./src/training_set/index.js","webpack:///./src/kmeans/kmeans_training_mixin.js","webpack:///./src/common/gaussian_distribution.js","webpack:///./src/core/em_training_mixin.js","webpack:///./src/gmm/gmm_base_mixin.js","webpack:///./src/core/multiclass_mixin.js","webpack:///./src/core/multiclass_training_mixin.js","webpack:///./src/core/prediction_mixin.js","webpack:///./src/common/validation.js","webpack:///./src/core/multiclass_prediction_mixin.js","webpack:///./src/training_set/phrase.js","webpack:///./src/kmeans/index.js","webpack:///./src/common/euclidean.js","webpack:///./src/common/matrix.js","webpack:///./src/gmm/gmm_training_mixin.js","webpack:///./src/common/circular_buffer.js","webpack:///./src/gmm/gmm_prediction_mixin.js","webpack:///./src/hmm/index.js","webpack:///./src/hmm/hmm_base_mixin.js","webpack:///./src/hmm/hmm_training_mixin.js","webpack:///./src/hmm/hmm_prediction_mixin.js","webpack:///./src/hmm/hierarchical_hmm_prediction_mixin.js"],"names":["root","factory","exports","module","define","amd","self","this","installedModules","__webpack_require__","moduleId","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","configurable","enumerable","get","n","__esModule","object","property","prototype","hasOwnProperty","p","s","_ref","inputDimension","outputDimension","_objectWithoutProperties","bimodal","dimension","params","keys","includes","map","key","reduce","a","b","trainingSet","configuration","convergenceCriteria","__WEBPACK_IMPORTED_MODULE_6__core_multiclass_training_mixin__","__WEBPACK_IMPORTED_MODULE_5__core_multiclass_mixin__","MulticlassModelBase","ts","trainGMM","train","likelihoodWindow","model","__WEBPACK_IMPORTED_MODULE_9__core_multiclass_prediction_mixin__","models","classes","forEach","label","GMMPredictor","reset","gaussians","regularization","covarianceMode","__WEBPACK_IMPORTED_MODULE_4__gmm_training_mixin__","__WEBPACK_IMPORTED_MODULE_2__core_em_training_mixin__","__WEBPACK_IMPORTED_MODULE_3__gmm_base_mixin__","__WEBPACK_IMPORTED_MODULE_1__core_model_base_mixin__","ModelBase","__WEBPACK_IMPORTED_MODULE_8__gmm_prediction_mixin__","__WEBPACK_IMPORTED_MODULE_7__core_prediction_mixin__","components","assign","__WEBPACK_IMPORTED_MODULE_0__common_gaussian_distribution__","trainingSetPrototype","size","phrases","length","empty","getPhrase","phraseIndex","toString","callback","push","phrase","undefined","__WEBPACK_IMPORTED_MODULE_0__phrase__","columnNames","remove","removeClass","filter","x","_extends","clear","getPhrasesOfClass","TrainingSet","labels","ll","concat","indices","mean","sum","Array","fill","totalLength","t","standardDeviation","stddev","Math","sqrt","minmax","from","min","Infinity","max","create","clusters","trainingConfiguration","__WEBPACK_IMPORTED_MODULE_0__core_model_base_mixin__","Error","trainingConfig","initialization","relativeDistanceThreshold","minIterations","maxIterations","kMeansTrainingPrototype","centers","initializeClustersRandom","initializeClustersForgy","initClustersWithFirstPhrase","trainingNbIterations","previousCenters","updateCenters","meanClusterDistance","maxRelativeCenterVariation","k","__WEBPACK_IMPORTED_MODULE_1__common_euclidean__","step","floor","offset","random","pointsPerCluster","ppc","clustIdx","_","getFrame","numFramesPerCluster","frame","minDistance","clusterMembership","distance","proto","baseGaussianPrototype","bimodalGaussianPrototype","data","covarianceDeterminant","covarianceDeterminantInput","dist","allocate","covariance","inverseCovariance","allocateBimodal","likelihood","observation","inputLikelihood","euclideanDistance","tmp","exp","PI","Number","isNaN","abs","regularize","updateInverseCovariance","covMatrix","__WEBPACK_IMPORTED_MODULE_0__matrix__","slice","inv","pinv","determinant","matrix","updateInverseCovarianceBimodal","toEllipse","dimension1","dimension2","gaussianEllipse","y","width","height","angle","trace","eigenVal1","eigenVal2","atan","fromEllipse","tantheta","tan","inverseCovarianceInput","inputObservation","regression","prediction","e","f","covMatrixInput","d1","d2","invInput","updateOutputCovariance","outputCovariance","covarianceGS","covarianceSG","tmptmptmp","product","covarianceMod","__webpack_exports__","percentChange","trainerPrototype","initTraining","logLikelihood","iterations","previousLogLikelihood","converged","updateTraining","pctChg","terminateTraining","iteration","logProb","previousLogProb","gmmBasePrototype","gmmBimodalPrototype","__WEBPACK_IMPORTED_MODULE_1__common_gaussian_distribution__","mixtureCoeffs","beta","componentLikelihood","mixtureComponent","updateInverseCovariances","normalizeMixtureCoeffs","normConst","currentRegularization","tmpOutputValues","results","outputValues","parameters","__WEBPACK_IMPORTED_MODULE_0__model_base_mixin__","MulticlassBasePrototype","trainingFunction","labs","instantLikelihood","predictionBasePrototype","likelihoodBuffer","__WEBPACK_IMPORTED_MODULE_1__common_circular_buffer__","setLikelihoodWindow","lw","predict","updateResults","log","bufSize","specification","values","attr","spec","required","parameter","value","constructor","checkSpec","check","transform","multiClassRegressionEstimator","MulticlassPredictionBasePrototype","MulticlassPredictionBimodalPrototype","getLikelihoodWindow","instantLikelihoods","smoothedLikelihoods","smoothedLogLikelihoods","smoothedNormalizedLikelihoods","likeliest","resetBimodal","sort","normInstant","normSmoothed","maxLogLikelihood","lab","[object Object]","instantNormalizedLikelihoods","updateRegressionResults","phrasePrototype","inputData","outputData","index","dim","pushInput","trim","pushOutput","clearInput","clearOutput","__WEBPACK_IMPORTED_MODULE_1__kmeans_training_mixin__","v1","v2","x1","Matrix","matrixPrototype","transpose","out","ncols","nrows","j","mat","gaussJordanInverse","transp","prod","dst","newMat","swapLines","ii","swapColumns","nc","absolute","relative","gmmTrainerPrototype","initParametersToDefault","initMeansWithKMeans","initCovariances","dataStddev","normCoeffs","std","kmeansParams","__WEBPACK_IMPORTED_MODULE_1__kmeans_kmeans_training_mixin__","gmeans","factor","phraseIndices","E","tbase","pix","capacity","buffer","circularBufferPrototype","full","idx","__WEBPACK_IMPORTED_MODULE_0__common_validation__","gmmParameterSpec","__WEBPACK_IMPORTED_MODULE_5__core_multiclass_training_mixin__","__WEBPACK_IMPORTED_MODULE_4__core_multiclass_mixin__","trainHMM","__WEBPACK_IMPORTED_MODULE_8__core_multiclass_prediction_mixin__","HMMPredictor","__WEBPACK_IMPORTED_MODULE_9__hierarchical_hmm_prediction_mixin__","states","transitionMode","__WEBPACK_IMPORTED_MODULE_3__hmm_training_mixin__","__WEBPACK_IMPORTED_MODULE_1__core_em_training_mixin__","__WEBPACK_IMPORTED_MODULE_2__hmm_base_mixin__","__WEBPACK_IMPORTED_MODULE_7__hmm_prediction_mixin__","__WEBPACK_IMPORTED_MODULE_6__core_prediction_mixin__","hmmBasePrototype","forwardInitialized","isHierarchical","initializeForwardAlgorithm","alpha","prior","xStates","updateForwardAlgorithm","previousAlpha","transition","hmmTrainerPrototype","initMeansCovariancesWithGMMEM","initMeansWithAllPhrases","initCovariancesFullyObserved","__WEBPACK_IMPORTED_MODULE_2__gmm_gmm_base_mixin__","previousBeta","nbPhrases","gammaSequence","epsilonSequence","gammaSequenceperMixture","maxT","T","gammaSum","gammaSumPerMixture","baumWelchForwardBackward","baumWelchGammaSum","baumWelchEstimateMixtureCoefficients","baumWelchEstimateMeans","baumWelchEstimateCovariances","baumWelchEstimatePrior","baumWelchEstimateTransitions","normalizeTransitions","alphaSeq","betaSeq","setErgodic","setLeftRight","initCovariance","othermeans","__WEBPACK_IMPORTED_MODULE_0__training_set__","gmmParams","__WEBPACK_IMPORTED_MODULE_3__gmm__","normPrior","transitionNorm","initializeBackwardAlgorithm","ct","updateBackwardAlgorithm","baumWelchForwardUpdate","observationLikelihoods","baumWelchBackwardUpdate","currentPhrase","observationProbabilities","reverse","oo","sumprior","hmmParameterSpec","hmmPredictionPrototype","hmmBimodalPredictionPrototype","previous_alpha_","setup","__WEBPACK_IMPORTED_MODULE_2__gmm__","updateAlphaWindow","updateProgress","progress","windowMinindex","windowMaxindex","alpha1","alpha2","windowNormalizationConstant","likeliestState","bestAlpha","regressionEstimator","clipMinState","clipMaxState","normalizationConstant","tmpPredictedOutput","hierarchicalHmmPredictionPrototype","numClasses","exitTransition","updateExitProbabilities","exitProbabilities","exitProb","exitLikelihood","modelIndex","second","N","frontierV1","frontierV2","likelihoodAlpha","dstModelIndex","dstModel","front","srcModelIndex","exitRatio","exitNum","likelihoodVector"],"mappings":"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","file":"xmm.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"xmm\"] = factory();\n\telse\n\t\troot[\"xmm\"] = factory();\n})(typeof self !== 'undefined' ? self : this, function() {\nreturn \n\n\n// WEBPACK FOOTER //\n// webpack/universalModuleDefinition"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 12);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 021d710422f92952db1e","/**\n * Create the skeleton of a model\n *\n * @function\n * @param       {Number} inputDimension  input dimension\n * @param       {Number} outputDimension output dimension\n * @param       {Object} parameters      additional parameters to be copied\n * @constructor\n */\nexport default function ModelBase({\n  inputDimension,\n  outputDimension,\n  ...parameters\n}) {\n  const p = parameters;\n  delete p.bimodal;\n  delete p.inputDimension;\n  delete p.outputDimension;\n  delete p.dimension;\n  return /** @lends ModelBase */{\n    params: {\n      ...p,\n      get bimodal() {\n        return outputDimension > 0;\n      },\n      get inputDimension() {\n        return inputDimension;\n      },\n      get outputDimension() {\n        return outputDimension;\n      },\n      get dimension() {\n        return inputDimension + outputDimension;\n      },\n    },\n  };\n}\n\n/**\n * Check if an object is a base model (check for attribute existence)\n * @param  {Object}  o Source object\n * @return {Boolean}\n */\nexport function isBaseModel(o) {\n  if (!Object.keys(o).includes('params')) return false;\n  const keys = ['bimodal', 'inputDimension', 'outputDimension', 'dimension'];\n  return keys.map(key => Object.keys(o.params).includes(key))\n    .reduce((a, b) => a && b, true);\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/core/model_base_mixin.js","import GaussianDistribution from '../common/gaussian_distribution';\nimport ModelBase from '../core/model_base_mixin';\nimport withEMTraining from '../core/em_training_mixin';\nimport withGMMBase from './gmm_base_mixin';\nimport withGMMTraining from './gmm_training_mixin';\nimport MulticlassModelBase from '../core/multiclass_mixin';\nimport withMulticlassTraining from '../core/multiclass_training_mixin';\nimport withAbtractPrediction from '../core/prediction_mixin';\nimport withGMMPrediction from './gmm_prediction_mixin';\nimport withMulticlassPrediction from '../core/multiclass_prediction_mixin';\n\n/**\n * @typedef {Object} GMMParameters\n * @property {Boolean} bimodal Specifies if the model is bimodal\n * @property {Number} inputDimension Dimension of the input modality\n * @property {Number} outputDimension Dimension of the output modality\n * @property {Number} dimension Total dimension\n * @property {Number} gaussians Number of gaussian components in the mixture\n * @property {String} covarianceMode Covariance mode ('full' or 'diagonal')\n * @property {Array<Number>} mixtureCoeffs mixture coefficients ('weight' of\n * each gaussian component)\n * @property {Array<GaussianDistribution>} components Gaussian components\n */\n\n/**\n * Train a single-class GMM Model.\n *\n * @todo GMM details\n *\n * @param  {TrainingSet} trainingSet                training set\n * @param  {Object} configuration                   Training configuration\n * @param  {Object} [convergenceCriteria=undefined] Convergence criteria of the\n * EM algorithm\n * @return {GMMParameters} Parameters of the trained GMM\n */\nexport function trainGMM(\n  trainingSet,\n  configuration,\n  convergenceCriteria = undefined,\n) {\n  const { inputDimension, outputDimension } = trainingSet;\n  const { gaussians, regularization, covarianceMode } = configuration;\n  const model = withGMMTraining(\n    withEMTraining(\n      withGMMBase(ModelBase({\n        inputDimension,\n        outputDimension,\n        ...configuration,\n      })),\n      convergenceCriteria,\n    ),\n    gaussians,\n    regularization,\n    covarianceMode,\n  );\n  return model.train(trainingSet);\n}\n\n/**\n * Train a multi-class GMM Model.\n *\n * @todo GMM details\n *\n * @param  {TrainingSet} trainingSet                training set\n * @param  {Object} configuration                   Training configuration\n * @param  {Object} [convergenceCriteria=undefined] Convergence criteria of the\n * EM algorithm\n * @return {Object} Parameters of the trained GMM\n */\nexport function trainMulticlassGMM(\n  trainingSet,\n  configuration,\n  convergenceCriteria = undefined,\n) {\n  const { inputDimension, outputDimension } = trainingSet;\n  const model = withMulticlassTraining(\n    MulticlassModelBase({ inputDimension, outputDimension, ...configuration }),\n    ts => trainGMM(ts, configuration, convergenceCriteria),\n  );\n  return model.train(trainingSet);\n}\n\n/**\n * Create a GMM Predictor from a full set of parameters (generated by trainGMM).\n * @param       {Object} params                       Model parameters\n * @param       {number} [likelihoodWindow=undefined] Likelihoow window size\n * @function\n */\nexport function GMMPredictor(\n  params,\n  likelihoodWindow = undefined,\n) {\n  const model = withGMMPrediction(withAbtractPrediction(\n    withGMMBase(ModelBase(params)),\n    likelihoodWindow,\n  ));\n  params.components.forEach((c, i) => {\n    model.params.components[i] = Object.assign(GaussianDistribution(\n      params.inputDimension,\n      params.outputDimension,\n      params.covarianceMode,\n    ), c);\n  });\n  model.reset();\n  return model;\n}\n\n/**\n * Create a Multiclass GMM Predictor from a full set of parameters\n * (generated by trainMulticlassGMM).\n * @param       {Object} params                       Model parameters\n * @param       {number} [likelihoodWindow=undefined] Likelihoow window size\n * @function\n */\nexport function MulticlassGMMPredictor(\n  params,\n  likelihoodWindow = undefined,\n) {\n  const model = withMulticlassPrediction(MulticlassModelBase(params));\n  model.models = {};\n  Object.keys(params.classes).forEach((label) => {\n    model.models[label] = GMMPredictor(params.classes[label], likelihoodWindow);\n  });\n  model.reset();\n  return model;\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/gmm/index.js","import Phrase from './phrase';\n\n/**\n * Training Set Prototype\n * @ignore\n */\nconst trainingSetPrototype = /** @lends TrainingSet */ {\n  /**\n   * Get the training set size (number of phrases)\n   * @return {number}\n   */\n  size() {\n    return Object.keys(this.phrases).length;\n  },\n\n  /**\n   * Checks if the training set is empty\n   * @return {boolean}\n   */\n  empty() {\n    return this.length === 0;\n  },\n\n  /**\n   * Get a reference to a phrase by index\n   * @param  {number} phraseIndex phrase index\n   * @return {Phrase}\n   */\n  getPhrase(phraseIndex) {\n    if (Object.keys(this.phrases).includes(phraseIndex.toString())) {\n      return this.phrases[phraseIndex.toString()];\n    }\n    return null;\n  },\n\n  /**\n   * Iterate over all phrases in the training set. The callback function\n   * should take 3 arguments: the phrase, its index in the training set,\n   * and the phrases structure.\n   *\n   * @param  {Function} callback Callback function\n   */\n  forEach(callback) {\n    Object.keys(this.phrases).forEach((phraseIndex) => {\n      callback(this.phrases[phraseIndex], phraseIndex, this.phrases);\n    });\n  },\n\n  /**\n   * Add a phrase to the training set and return it.\n   * @param  {number} phraseIndex        phrase index\n   * @param  {string} [label=undefined]  phrase label (its index if undefined)\n   * @param  {Phrase} [phrase=undefined] Phrase data. If unspecified, an empty\n   * phrase is created.\n   * @return {Phrase}\n   */\n  push(phraseIndex, label = undefined, phrase = undefined) {\n    const p = (phrase !== undefined) ? phrase : Phrase({\n      inputDimension: this.inputDimension,\n      outputDimension: this.outputDimension,\n      columnNames: this.columnNames,\n      label: (label !== undefined) ? label : phraseIndex.toString(),\n    });\n    this.phrases[phraseIndex] = p;\n    return p;\n  },\n\n  /**\n   * Remove a phrase\n   * @param  {number} phraseIndex phrase index\n   */\n  remove(phraseIndex) {\n    delete this.phrases[phraseIndex];\n  },\n\n  /**\n   * Remove all phrases with a given label\n   * @param  {string} label class label\n   */\n  removeClass(label) {\n    this.phrases = Object.keys(this.phrases)\n      .filter(i => this.phrases[i].label !== label)\n      .map(i => ({ i: this.phrases[i] }))\n      .reduce((x, p) => ({ ...x, ...p }), {});\n  },\n\n  /**\n   * Clear the training set (delete all phrases)\n   */\n  clear() {\n    this.phrases = {};\n  },\n\n  /**\n   * Get the sub-training set composed of all phrases of a given class\n   * @param  {string} label class label\n   * @return {TrainingSet}\n   */\n  getPhrasesOfClass(label) {\n    const ts = TrainingSet(this); // eslint-disable-line no-use-before-define\n    ts.phrases = Object.keys(this.phrases)\n      .filter(i => this.phrases[i].label === label)\n      .map(i => ({ i: this.phrases[i] }))\n      .reduce((x, p) => ({ ...x, ...p }), {});\n    return ts;\n  },\n\n  /**\n   * Get the list of unique labels in the training set\n   * @return {Array<string>}\n   */\n  labels() {\n    return Object.keys(this.phrases)\n      .map(i => this.phrases[i].label)\n      .reduce((ll, x) => (ll.includes(x) ? ll : ll.concat([x])), []);\n  },\n\n  /**\n   * Get the list of phrase indices\n   * @return {Array<number>}\n   */\n  indices() {\n    return Object.keys(this.phrases);\n  },\n\n  /**\n   * Get the mean of the training set over all phrases\n   * @return {Array<number>} mean (same dimension as the training set)\n   */\n  mean() {\n    const sum = Array(this.dimension).fill(0);\n    let totalLength = 0;\n    Object.keys(this.phrases).forEach((i) => {\n      for (let d = 0; d < this.dimension; d += 1) {\n        for (let t = 0; t < this.phrases[i].length; t += 1) {\n          sum[d] += this.phrases[i].get(t, d);\n        }\n      }\n      totalLength += this.phrases[i].length;\n    });\n\n    return sum.map(x => x / totalLength);\n  },\n\n  /**\n   * Get the standard deviation of the training set over all phrases\n   * @return {Array<number>} standard deviation (same dimension as the training set)\n   */\n  standardDeviation() {\n    const stddev = Array(this.dimension).fill(0);\n    const mean = this.mean();\n    let totalLength = 0;\n    Object.keys(this.phrases).forEach((i) => {\n      for (let d = 0; d < this.dimension; d += 1) {\n        for (let t = 0; t < this.phrases[i].length; t += 1) {\n          stddev[d] += (this.phrases[i].get(t, d) - mean[d]) ** 2;\n        }\n      }\n      totalLength += this.phrases[i].length;\n    });\n\n    return stddev.map(x => Math.sqrt(x / totalLength));\n  },\n\n  /**\n   * Get the min and max of the training set over all phrases\n   * @return {Array<{ min: number, max: number }>} min/max (same dimension as the training set)\n   */\n  minmax() {\n    const minmax = Array.from(\n      Array(this.dimension),\n      () => ({ min: +Infinity, max: -Infinity }),\n    );\n    Object.keys(this.phrases).forEach((i) => {\n      for (let d = 0; d < this.dimension; d += 1) {\n        for (let t = 0; t < this.phrases[i].length; t += 1) {\n          minmax[d].min += Math.min(minmax[d].min, this.phrases[i].get(t, d));\n          minmax[d].max += Math.max(minmax[d].max, this.phrases[i].get(t, d));\n        }\n      }\n    });\n    return minmax;\n  },\n};\n\n/**\n * Create a Training set, composed of a set of indexed data phrases\n * @param {Object} [params]                   Training set parameters\n * @param {Number} [params.inputDimension=1]  Dimension of the input modality\n * @param {Number} [params.outputDimension=0] Dimension of the output modality\n * (optional)\n * @param {Array<String>} [params.columnNames=null] Data column names, e.g.\n * \\['accX', 'accY', 'accZ'\\] (optional)\n * @return {TrainingSet}\n * @function\n *\n * @property {Boolean} bimodal Specifies if the training set is bimodal\n * @property {Number}  inputDimension Dimension of the input modality\n * @property {Number}  outputDimension Dimension of the output modality\n * @property {Number}  dimension Total dimension\n * @property {Array<String>} columnNames Columns names\n */\nexport default function TrainingSet({\n  inputDimension = 1,\n  outputDimension = 0,\n  columnNames = null,\n} = {}) {\n  const dimension = inputDimension + outputDimension;\n  return Object.assign(\n    Object.create(trainingSetPrototype),\n    {\n      bimodal: outputDimension > 0,\n      inputDimension,\n      outputDimension,\n      dimension,\n      columnNames: columnNames || Array(dimension).fill(''),\n      phrases: {},\n    },\n  );\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/training_set/index.js","import { isBaseModel } from '../core/model_base_mixin';\nimport euclidean from '../common/euclidean';\n\nconst kMeansTrainingPrototype = {\n  train(trainingSet) {\n    if (!trainingSet || trainingSet.empty()) {\n      throw new Error('The training set is empty');\n    }\n\n    this.params.centers = Array.from(\n      Array(this.params.clusters),\n      () => new Array(this.params.dimension).fill(0),\n    );\n\n    // TODO: improve initialization =>\n    // https://www.slideshare.net/djempol/kmeans-initialization-15041920\n    //\n    if (this.trainingConfig.initialization === 'random') {\n      this.initializeClustersRandom(trainingSet);\n    } else if (this.trainingConfig.initialization === 'forgy') {\n      this.initializeClustersForgy(trainingSet);\n    } else if (this.trainingConfig.initialization === 'data') {\n      this.initClustersWithFirstPhrase(trainingSet);\n    } else {\n      throw new Error('Unknown K-Means initialization, must be `random`, `forgy` or `data`');\n    }\n\n    for (\n      let trainingNbIterations = 0;\n      trainingNbIterations < this.trainingConfig.maxIterations;\n      trainingNbIterations += 1\n    ) {\n      const previousCenters = this.params.centers;\n\n      this.updateCenters(previousCenters, trainingSet);\n\n      let meanClusterDistance = 0;\n      let maxRelativeCenterVariation = 0;\n      for (let k = 0; k < this.params.clusters; k += 1) {\n        for (let l = 0; l < this.params.clusters; l += 1) {\n          if (k !== l) {\n            meanClusterDistance += euclidean(\n              this.params.centers[k],\n              this.params.centers[l],\n            );\n          }\n        }\n        maxRelativeCenterVariation = Math.max(\n          euclidean(\n            previousCenters[k],\n            this.params.centers[k],\n          ),\n          maxRelativeCenterVariation,\n        );\n      }\n      meanClusterDistance /= this.params.clusters * (this.params.clusters - 1);\n      maxRelativeCenterVariation /= this.params.clusters;\n      maxRelativeCenterVariation /= meanClusterDistance;\n      if (maxRelativeCenterVariation < this.trainingConfig.relativeDistanceThreshold) break;\n    }\n    return this.params;\n  },\n\n  initClustersWithFirstPhrase(trainingSet) {\n    const phrase = trainingSet.getPhrase(trainingSet.indices()[0]);\n    const step = Math.floor(phrase.length / this.params.clusters);\n\n    let offset = 0;\n    for (let c = 0; c < this.params.clusters; c += 1) {\n      this.params.centers[c] = new Array(this.params.dimension).fill(0);\n      for (let t = 0; t < step; t += 1) {\n        for (let d = 0; d < this.params.dimension; d += 1) {\n          this.params.centers[c][d] += phrase.get(offset + t, d) / step;\n        }\n      }\n      offset += step;\n    }\n  },\n\n  initializeClustersRandom(trainingSet) {\n    const phrase = trainingSet.getPhrase(trainingSet.indices()[0]);\n    const indices = Array.from(\n      Array(phrase.length),\n      () => Math.floor(Math.random() * this.params.clusters),\n    );\n    const pointsPerCluster = indices.reduce(\n      (ppc, i) => {\n        const p = ppc;\n        p[i] += 1;\n        return p;\n      },\n      Array(this.params.clusters).fill(0),\n    );\n    for (let i = 0; i < indices.length; i += 1) {\n      const clustIdx = indices[i];\n      for (let d = 0; d < this.params.dimension; d += 1) {\n        this.params.centers[clustIdx][d] += phrase.get(i, d);\n      }\n    }\n    this.params.centers.forEach((_, c) => {\n      this.params.centers[c] = this.params.centers[c]\n        .map(x => x / pointsPerCluster[c]);\n    });\n  },\n\n  initializeClustersForgy(trainingSet) {\n    const phrase = trainingSet.getPhrase(trainingSet.indices()[0]);\n    const indices = Array.from(\n      Array(this.params.clusters),\n      () => Math.floor(Math.random() * phrase.length),\n    );\n    this.params.centers = indices.map(i => phrase.getFrame(i));\n  },\n\n  updateCenters(previousCenters, trainingSet) {\n    this.params.centers = Array.from(Array(this.params.clusters), () =>\n      new Array(this.params.dimension).fill(0));\n    const numFramesPerCluster = Array(this.params.clusters).fill(0);\n    trainingSet.forEach((phrase) => {\n      for (let t = 0; t < phrase.length; t += 1) {\n        const frame = phrase.getFrame(t);\n        let minDistance = euclidean(frame, previousCenters[0]);\n        let clusterMembership = 0;\n        for (let k = 1; k < this.params.clusters; k += 1) {\n          const distance = euclidean(\n            frame,\n            previousCenters[k],\n            this.params.dimension,\n          );\n          if (distance < minDistance) {\n            clusterMembership = k;\n            minDistance = distance;\n          }\n        }\n        numFramesPerCluster[clusterMembership] += 1;\n        for (let d = 0; d < this.params.dimension; d += 1) {\n          this.params.centers[clusterMembership][d] += phrase.get(t, d);\n        }\n      }\n    });\n    for (let k = 0; k < this.params.clusters; k += 1) {\n      if (numFramesPerCluster[k] > 0) {\n        for (let d = 0; d < this.params.dimension; d += 1) {\n          this.params.centers[k][d] /= numFramesPerCluster[k];\n        }\n      }\n    }\n  },\n};\n\nexport default function withKMeansTraining(\n  o,\n  clusters,\n  trainingConfiguration = {},\n) {\n  if (!isBaseModel(o)) {\n    throw new Error('The base object must include a standard set of parameters (`params` key), @see `ModelBase`.');\n  }\n  const trainingConfig = Object.assign({\n    initialization: 'random',\n    relativeDistanceThreshold: 1e-3,\n    minIterations: 5,\n    maxIterations: 100,\n  }, trainingConfiguration);\n  const model = Object.assign(o, kMeansTrainingPrototype, {\n    trainingConfig,\n  });\n  model.params.clusters = clusters;\n  return model;\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/kmeans/kmeans_training_mixin.js","import Matrix from './matrix';\n\n/**\n * Gaussian Distribution Prototype\n *\n * @type {Object}\n * @property {boolean} bimodal           Specifies if the distribution is\n * bimodal (for regression use)\n * @property {number}  inputDimension    input dimension\n * @property {number}  outputDimension   output dimension\n * @property {number}  dimension         Total dimension\n * @property {Array}   mean              Distribution mean\n * @property {Array}   covariance        Distribution covariance\n * @property {Array}   inverseCovariance Inverse covariance\n *\n * @ignore\n */\nconst baseGaussianPrototype = /** @lends GaussianDistribution */ {\n  /**\n   * Allocate the distribution\n   * @private\n   */\n  allocate() {\n    this.mean = new Array(this.dimension).fill(0);\n    if (this.covarianceMode === 'full') {\n      this.covariance = new Array(this.dimension ** 2).fill(0);\n      this.inverseCovariance = new Array(this.dimension ** 2).fill(0);\n    } else {\n      this.covariance = new Array(this.dimension).fill(0);\n      this.inverseCovariance = new Array(this.dimension).fill(0);\n    }\n    if (this.bimodal) {\n      this.allocateBimodal();\n    }\n  },\n\n  /**\n   * @brief Estimate the likelihood of an observation vector.\n   *\n   * If the distribution is bimodal an the observation is a vector of the size\n   * of the input modality, the likelihood is computed only on the\n   * distribution for the input modality\n   *\n   * @param  {array} observation data observation\n   * @return {number}\n   */\n  likelihood(observation) {\n    if (this.covarianceDeterminant === 0) {\n      throw new Error('Covariance Matrix is not invertible');\n    }\n    if (this.bimodal && observation.length === this.inputDimension) {\n      return this.inputLikelihood(observation);\n    }\n    if (observation.length !== this.dimension) {\n      throw new Error(`GaussianDistribution: observation has wrong dimension. Expected \\`${this.dimension}\\`, got \\`${observation.length}\\``);\n    }\n\n    let euclideanDistance = 0;\n    if (this.covarianceMode === 'full') {\n      for (let l = 0; l < this.dimension; l += 1) {\n        let tmp = 0;\n        for (let k = 0; k < this.dimension; k += 1) {\n          tmp += this.inverseCovariance[(l * this.dimension) + k] *\n            (observation[k] - this.mean[k]);\n        }\n        euclideanDistance += (observation[l] - this.mean[l]) * tmp;\n      }\n    } else {\n      for (let l = 0; l < this.dimension; l += 1) {\n        euclideanDistance += this.inverseCovariance[l] *\n          (observation[l] - this.mean[l]) *\n          (observation[l] - this.mean[l]);\n      }\n    }\n\n    let p = Math.exp(-0.5 * euclideanDistance) /\n      Math.sqrt(this.covarianceDeterminant * ((2 * Math.PI) ** this.dimension));\n\n    if (p < 1e-180 || Number.isNaN(p) || Math.abs(p) === +Infinity) {\n      p = 1e-180;\n    }\n\n    return p;\n  },\n\n  /**\n   * Regularize the distribution, given a regularization vector of the same\n   * dimension. Regularization adds the vector to the variance of the\n   * distribution.\n   *\n   * @param  {Array} regularization regularization vector\n   */\n  regularize(regularization) {\n    if (this.covarianceMode === 'full') {\n      for (let d = 0; d < this.dimension; d += 1) {\n        this.covariance[(d * this.dimension) + d] += regularization[d];\n      }\n    } else {\n      for (let d = 0; d < this.dimension; d += 1) {\n        this.covariance[d] += regularization[d];\n      }\n    }\n  },\n\n  /**\n   * Update the inverse covariance of the distribution\n   * @private\n   */\n  updateInverseCovariance() {\n    if (this.covarianceMode === 'full') {\n      const covMatrix = Matrix(this.dimension, this.dimension);\n\n      covMatrix.data = this.covariance.slice();\n      const inv = covMatrix.pinv();\n      this.covarianceDeterminant = inv.determinant;\n      this.inverseCovariance = inv.matrix.data;\n    } else { // DIAGONAL COVARIANCE\n      this.covarianceDeterminant = 1;\n      for (let d = 0; d < this.dimension; d += 1) {\n        if (this.covariance[d] <= 0) {\n          throw new Error('Non-invertible matrix');\n        }\n        this.inverseCovariance[d] = 1 / this.covariance[d];\n        this.covarianceDeterminant *= this.covariance[d];\n      }\n    }\n    if (this.bimodal) {\n      this.updateInverseCovarianceBimodal();\n    }\n  },\n\n  /**\n   * Convert to an ellipse allong two dimensions\n   *\n   * @param  {number} dimension1 first dimension\n   * @param  {number} dimension2 second dimension\n   * @return {Ellipse}\n   */\n  toEllipse(dimension1, dimension2) {\n    if (dimension1 >= this.dimension || dimension2 >= this.dimension) {\n      throw new Error('dimensions out of range');\n    }\n\n    const gaussianEllipse = {\n      x: 0,\n      y: 0,\n      width: 0,\n      height: 0,\n      angle: 0,\n    };\n    gaussianEllipse.x = this.mean[dimension1];\n    gaussianEllipse.y = this.mean[dimension2];\n\n    // Represent 2D covariance with square matrix\n    // |a b|\n    // |b c|\n    let a;\n    let b;\n    let c;\n    if (this.covarianceMode === 'full') {\n      a = this.covariance[(dimension1 * this.dimension) + dimension1];\n      b = this.covariance[(dimension1 * this.dimension) + dimension2];\n      c = this.covariance[(dimension2 * this.dimension) + dimension2];\n    } else {\n      a = this.covariance[dimension1];\n      b = 0;\n      c = this.covariance[dimension2];\n    }\n\n    // Compute Eigen Values to get width, height and angle\n    const trace = a + c;\n    const determinant = (a * c) - (b * b);\n    const eigenVal1 = 0.5 * (trace + Math.sqrt((trace ** 2) - (4 * determinant)));\n    const eigenVal2 = 0.5 * (trace - Math.sqrt((trace ** 2) - (4 * determinant)));\n    gaussianEllipse.width = Math.sqrt(5.991 * eigenVal1);\n    gaussianEllipse.height = Math.sqrt(5.991 * eigenVal2);\n    gaussianEllipse.angle = Math.atan(b / (eigenVal1 - c));\n    if (Number.isNaN(gaussianEllipse.angle)) {\n      gaussianEllipse.angle = Math.PI / 2;\n    }\n\n    return gaussianEllipse;\n  },\n\n  /**\n   * Modify the distribution along two dimensions given the equivalent values\n   * as an Ellipse representation.\n   *\n   * @param  {Ellipse} gaussianEllipse The Ellipse corresponding to the 2D\n   * covariance along the two target dimensions\n   * @param  {number} dimension1      first dimension\n   * @param  {number} dimension2      second dimension\n   */\n  fromEllipse(gaussianEllipse, dimension1, dimension2) {\n    if (dimension1 >= this.dimension || dimension2 >= this.dimension) {\n      throw new Error('dimensions out of range');\n    }\n\n    this.mean[dimension1] = gaussianEllipse.x;\n    this.mean[dimension2] = gaussianEllipse.y;\n\n    const eigenVal1 = (gaussianEllipse.width * gaussianEllipse.width) / 5.991;\n    const eigenVal2 = (gaussianEllipse.height * gaussianEllipse.height) / 5.991;\n    const tantheta = Math.tan(gaussianEllipse.angle);\n    const b = ((eigenVal1 - eigenVal2) * tantheta) / ((tantheta ** 2) + 1);\n    const c = eigenVal1 - (b / tantheta);\n    const a = eigenVal2 + (b / tantheta);\n\n    if (this.covarianceMode === 'full') {\n      this.covariance[(dimension1 * this.dimension) + dimension1] = a;\n      this.covariance[(dimension1 * this.dimension) + dimension2] = b;\n      this.covariance[(dimension2 * this.dimension) + dimension1] = b;\n      this.covariance[(dimension2 * this.dimension) + dimension2] = c;\n    } else {\n      this.covariance[dimension1] = a;\n      this.covariance[dimension2] = c;\n    }\n    this.updateInverseCovariance();\n  },\n};\n\n/**\n * Bimodal Gaussian Distribution Prototype, for Regression purposes\n *\n * @type {Object}\n * @property {boolean} bimodal           Specifies if the distribution is\n * bimodal (for regression use)\n * @property {number}  inputDimension    input dimension\n * @property {number}  outputDimension   output dimension\n * @property {number}  dimension         Total dimension\n * @property {Array}   mean              Distribution mean\n * @property {Array}   covariance        Distribution covariance\n * @property {Array}   inverseCovariance Inverse covariance\n * @property {Array}   inverseCovarianceInput Inverse covariance of the input\n * modality\n *\n * @ignore\n */\nconst bimodalGaussianPrototype = /** @lends GaussianDistribution */ {\n  /**\n   * Allocate the distribution\n   * @private\n   */\n  allocateBimodal() {\n    if (this.covarianceMode === 'full') {\n      this.inverseCovarianceInput = new Array(this.inputDimension ** 2).fill(0);\n    } else {\n      this.inverseCovarianceInput = new Array(this.inputDimension).fill(0);\n    }\n  },\n\n  /**\n   * Estimate the likelihood of an observation for the input modality only.\n   * Called by `likelihood` when relevant.\n   * @param  {Array} inputObservation observation (input modality only)\n   * @return {number}\n   * @private\n   */\n  inputLikelihood(inputObservation) {\n    if (this.covarianceDeterminantInput === 0) {\n      throw new Error('Covariance Matrix of input modality is not invertible');\n    }\n\n    let euclideanDistance = 0;\n    if (this.covarianceMode === 'full') {\n      for (let l = 0; l < this.inputDimension; l += 1) {\n        let tmp = 0;\n        for (let k = 0; k < this.inputDimension; k += 1) {\n          tmp += this.inverseCovarianceInput[(l * this.inputDimension) + k] *\n            (inputObservation[k] - this.mean[k]);\n        }\n        euclideanDistance += (inputObservation[l] - this.mean[l]) * tmp;\n      }\n    } else {\n      for (let l = 0; l < this.inputDimension; l += 1) {\n        euclideanDistance += this.inverseCovariance[l] *\n          (inputObservation[l] - this.mean[l]) *\n          (inputObservation[l] - this.mean[l]);\n      }\n    }\n\n    let p = Math.exp(-0.5 * euclideanDistance) /\n               Math.sqrt(this.covarianceDeterminantInput *\n                    ((2 * Math.PI) ** this.inputDimension));\n\n    if (p < 1e-180 || Number.isNaN(p) || Math.abs(p) === +Infinity) p = 1e-180;\n\n    return p;\n  },\n\n  /**\n   * Estimate the output values associated with an input observation by\n   * regression, given the distribution parameters.\n   *\n   * @todo Clarify the maths here.\n   *\n   * @param  {Array} inputObservation observation (input modality only)\n   * @return {Array} Output values\n   */\n  regression(inputObservation) {\n    const outputDimension = this.dimension - this.inputDimension;\n    const prediction = Array(outputDimension).fill(0);\n\n    if (this.covarianceMode === 'full') {\n      for (let d = 0; d < outputDimension; d += 1) {\n        prediction[d] = this.mean[this.inputDimension + d];\n        for (let e = 0; e < this.inputDimension; e += 1) {\n          let tmp = 0;\n          for (let f = 0; f < this.inputDimension; f += 1) {\n            tmp += this.inverseCovarianceInput[(e * this.inputDimension) + f] *\n              (inputObservation[f] - this.mean[f]);\n          }\n          prediction[d] += tmp *\n            this.covariance[((d + this.inputDimension) * this.dimension) + e];\n        }\n      }\n    } else {\n      for (let d = 0; d < outputDimension; d += 1) {\n        prediction[d] = this.mean[this.inputDimension + d];\n      }\n    }\n    return prediction;\n  },\n\n  /**\n   * Update the inverse covariance\n   * @private\n   */\n  updateInverseCovarianceBimodal() {\n    if (this.covarianceMode === 'full') {\n      const covMatrixInput = Matrix(this.inputDimension, this.inputDimension);\n      for (let d1 = 0; d1 < this.inputDimension; d1 += 1) {\n        for (let d2 = 0; d2 < this.inputDimension; d2 += 1) {\n          covMatrixInput.data[(d1 * this.inputDimension) + d2] =\n            this.covariance[(d1 * this.dimension) + d2];\n        }\n      }\n      const invInput = covMatrixInput.pinv();\n      this.covarianceDeterminantInput = invInput.determinant;\n      this.inverseCovarianceInput = invInput.matrix.data;\n    } else { // DIAGONAL COVARIANCE\n      this.covarianceDeterminantInput = 1;\n      for (let d = 0; d < this.inputDimension; d += 1) {\n        if (this.covariance[d] <= 0) {\n          throw new Error('Non-invertible matrix');\n        }\n        this.inverseCovarianceInput[d] = 1 / this.covariance[d];\n        this.covarianceDeterminantInput *= this.covariance[d];\n      }\n    }\n    this.updateOutputCovariance();\n  },\n\n  /**\n   * Update the output covariance\n   * @private\n   */\n  updateOutputCovariance() {\n    if (this.covarianceMode === 'diagonal') {\n      this.outputCovariance = this.covariance.slice(0, this.inputDimension);\n      return;\n    }\n\n    // CASE: FULL COVARIANCE\n    const covMatrixInput = Matrix(this.inputDimension, this.inputDimension);\n    for (let d1 = 0; d1 < this.inputDimension; d1 += 1) {\n      for (let d2 = 0; d2 < this.inputDimension; d2 += 1) {\n        covMatrixInput.data[(d1 * this.inputDimension) + d2] =\n          this.covariance[(d1 * this.dimension) + d2];\n      }\n    }\n    const inv = covMatrixInput.pinv();\n    const covarianceGS = Matrix(this.inputDimension, this.outputDimension);\n    for (let d1 = 0; d1 < this.inputDimension; d1 += 1) {\n      for (let d2 = 0; d2 < this.outputDimension; d2 += 1) {\n        covarianceGS.data[(d1 * this.outputDimension) + d2] =\n          this.covariance[(d1 * this.dimension) + this.inputDimension + d2];\n      }\n    }\n    const covarianceSG = Matrix(this.outputDimension, this.inputDimension);\n    for (let d1 = 0; d1 < this.outputDimension; d1 += 1) {\n      for (let d2 = 0; d2 < this.inputDimension; d2 += 1) {\n        covarianceSG.data[(d1 * this.inputDimension) + d2] =\n          this.covariance[((this.inputDimension + d1) * this.dimension) + d2];\n      }\n    }\n    const tmptmptmp = inv.matrix.product(covarianceGS);\n    const covarianceMod = covarianceSG.product(tmptmptmp);\n    this.outputCovariance = Array(this.outputDimension ** 2).fill(0);\n    for (let d1 = 0; d1 < this.outputDimension; d1 += 1) {\n      for (let d2 = 0; d2 < this.outputDimension; d2 += 1) {\n        this.outputCovariance[(d1 * this.outputDimension) + d2] =\n          this.covariance[((this.inputDimension + d1) * this.dimension) +\n            this.inputDimension + d2] -\n            covarianceMod.data[(d1 * this.outputDimension) + d2];\n      }\n    }\n  },\n};\n\n/**\n * Multivariate Gaussian Distribution factory function.\n * Full covariance, optionally multimodal with support for regression.\n *\n * @function\n * @param {Number} [inputDimension=1]      Dimension of the input modality\n * @param {Number} [outputDimension=0]     Dimension of the output\n * modality (positive for regression, otherwise 0 for recognition).\n * @param {String} [covarianceMode='full'] covariance mode (full vs\n * diagonal)\n * @return {baseGaussianPrototype|bimodalGaussianPrototype}\n *\n * @property {boolean} bimodal           Specifies if the distribution is\n * bimodal (for regression use)\n * @property {number}  inputDimension    input dimension\n * @property {number}  outputDimension   output dimension\n * @property {number}  dimension         Total dimension\n * @property {Array}   mean              Distribution mean\n * @property {Array}   covariance        Distribution covariance\n * @property {Array}   inverseCovariance Inverse covariance\n */\nexport default function GaussianDistribution(\n  inputDimension = 1,\n  outputDimension = 0,\n  covarianceMode = 'full',\n) {\n  const bimodal = outputDimension > 0;\n  const dimension = inputDimension + outputDimension;\n  const proto = bimodal ?\n    Object.assign({}, baseGaussianPrototype, bimodalGaussianPrototype) :\n    baseGaussianPrototype;\n  const data = Object.assign(\n    {\n      bimodal,\n      dimension,\n      inputDimension,\n      outputDimension,\n      covarianceMode,\n      covarianceDeterminant: 0,\n    },\n    bimodal ? { covarianceDeterminantInput: 0 } : {},\n  );\n  const dist = Object.assign(\n    Object.create(proto),\n    data,\n  );\n  dist.allocate();\n  return dist;\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/common/gaussian_distribution.js","const trainerPrototype = /** @lends withEMTraining */ {\n  /**\n   * Train the model from the given training set, using the\n   * Expectation-Maximisation algorithm.\n   *\n   * @param  {TrainingSet} trainingSet Training Set\n   * @return {Object} Parameters of the trained model\n   */\n  train(trainingSet) {\n    if (!trainingSet || trainingSet.empty()) {\n      throw new Error('The training set is empty');\n    }\n\n    this.initTraining(trainingSet);\n\n    let logLikelihood = -Infinity;\n    let iterations = 0;\n    let previousLogLikelihood = logLikelihood;\n\n    while (!this.converged(iterations, logLikelihood, previousLogLikelihood)) {\n      previousLogLikelihood = logLikelihood;\n      logLikelihood = this.updateTraining(trainingSet);\n\n      const pctChg =\n        100 * Math.abs((logLikelihood - previousLogLikelihood) / previousLogLikelihood);\n      if (Number.isNaN(pctChg) && iterations > 1) {\n        throw new Error('An error occured during training');\n      }\n\n      iterations += 1;\n    }\n\n    this.terminateTraining();\n    return this.params;\n  },\n\n  /**\n   * Return `true` if the training has converged according to the criteria\n   * specified at the creation\n   *\n   * @param  {number} iteration       Current iteration\n   * @param  {number} logProb         Current log-likelihood of the training set\n   * @param  {number} previousLogProb Previous log-likelihood of the training\n   * set\n   * @return {boolean}\n   *\n   * @private\n   */\n  converged(iteration, logProb, previousLogProb) {\n    if (iteration >= this.convergenceCriteria.maxIterations) return true;\n    if (this.convergenceCriteria.maxIterations >= this.convergenceCriteria.minIterations) {\n      return iteration >= this.convergenceCriteria.maxIterations;\n    }\n    if (iteration < this.convergenceCriteria.minIterations) return false;\n    const percentChange = 100 * Math.abs((logProb - previousLogProb) / logProb);\n    return percentChange <= this.convergenceCriteria.percentChange;\n  },\n};\n\n/**\n * Add ABSTRACT training capabilities to a model for which the training process\n * use the Expectation-Maximisation (EM) algorithm. This is used in particular\n * for training GMMs and HMMs.\n *\n * The final instance needs to implement `initTraining`, `updateTraining` and\n * `terminateTraining` methods. `updateTraining` will be called until the\n * convergence criteria are met. Convergence depends on\n * - A minimum number of iterations\n * - A maximum number of iterations\n * - A threshold on the relative change of the log-likelihood of the training\n * data between successive iterations.\n *\n * @todo details\n *\n * @param  {Object} [o]                   Source object\n * @param  {Object} [convergenceCriteria] Set of convergence criteria\n * @param  {number} [convergenceCriteria.percentChange=1e-3] Threshold in % of\n * the relative change of the log-likelihood, under which the training stops.\n * @param  {number} [convergenceCriteria.minIterations=5]    minimum number of iterations\n * @param  {number} [convergenceCriteria.maxIterations=100]  maximum number of iterations\n * @return {Object}\n */\nexport default function withEMTraining(\n  o,\n  convergenceCriteria = {\n    percentChange: 1e-3,\n    minIterations: 5,\n    maxIterations: 100,\n  },\n) {\n  return Object.assign(o, trainerPrototype, { convergenceCriteria });\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/core/em_training_mixin.js","import { isBaseModel } from '../core/model_base_mixin';\nimport GaussianDistribution from '../common/gaussian_distribution';\n\n/**\n * GMM Base prototype\n * @type {Object}\n * @ignore\n */\nconst gmmBasePrototype = /** @lends withGMMBase */ {\n  /**\n   * Allocate the training variables\n   * @private\n   */\n  allocate() {\n    this.params.components = Array.from(\n      Array(this.params.gaussians),\n      () => new GaussianDistribution(\n        this.params.inputDimension,\n        this.params.outputDimension,\n        this.params.covarianceMode,\n      ),\n    );\n    this.params.mixtureCoeffs = Array(this.params.gaussians).fill(0);\n    this.beta = new Array(this.params.gaussians).fill(0);\n  },\n\n  /**\n   * Compute the likelihood of an observation given the GMM's parameters\n   * @param  {Array<Number>} observation Observation vector\n   * @return {Number}\n   */\n  likelihood(observation) {\n    let likelihood = 0;\n    for (let c = 0; c < this.params.gaussians; c += 1) {\n      this.beta[c] = this.componentLikelihood(observation, c);\n      likelihood += this.beta[c];\n    }\n    for (let c = 0; c < this.params.gaussians; c += 1) {\n      this.beta[c] /= likelihood;\n    }\n\n    return likelihood;\n  },\n\n  /**\n   * Compute the likelihood of an observation for a single component\n   * @param  {Array<Number>} observation Observation vector\n   * @param  {Number} mixtureComponent Component index\n   * @return {Number}\n   * @private\n   */\n  componentLikelihood(observation, mixtureComponent) {\n    if (mixtureComponent >= this.params.gaussians) {\n      throw new Error('The index of the Gaussian Mixture Component is out of bounds');\n    }\n    return this.params.mixtureCoeffs[mixtureComponent] *\n        this.params.components[mixtureComponent].likelihood(observation);\n  },\n\n  /**\n   * Update the inverse covariance of each Gaussian component\n   * @private\n   */\n  updateInverseCovariances() {\n    this.params.components.forEach((c) => {\n      c.updateInverseCovariance();\n    });\n    try {\n      this.params.components.forEach((c) => {\n        c.updateInverseCovariance();\n      });\n    } catch (e) {\n      throw new Error('Matrix inversion error: varianceoffset must be too small');\n    }\n  },\n\n  /**\n   * Normalize the mixing coefficients of the Gaussian mixture\n   * @private\n   */\n  normalizeMixtureCoeffs() {\n    let normConst = 0;\n    for (let c = 0; c < this.params.gaussians; c += 1) {\n      normConst += this.params.mixtureCoeffs[c];\n    }\n    if (normConst > 0) {\n      for (let c = 0; c < this.params.gaussians; c += 1) {\n        this.params.mixtureCoeffs[c] /= normConst;\n      }\n    } else {\n      for (let c = 0; c < this.params.gaussians; c += 1) {\n        this.params.mixtureCoeffs[c] = 1 / this.params.gaussians;\n      }\n    }\n  },\n\n  /**\n   * Regularize the covariances\n   * @private\n   */\n  regularize() {\n    this.params.components.forEach((c) => {\n      c.regularize(this.currentRegularization);\n    });\n  },\n};\n\n/**\n * Bimodal (regression) GMM Prototype\n * @type {Object}\n * @ignore\n */\nconst gmmBimodalPrototype = /** @lends withGMMBase */ {\n  /**\n   * Estimate the output values corresponding to the input observation, by\n   * regression given the GMM's parameters. This method is called Gaussian\n   * Mixture Regression (GMR).\n   *\n   * @param  {Array<Number>} inputObservation Observation on the input modality\n   * @return {Array<Number>} Output values (length = outputDimension)\n   */\n  regression(inputObservation) {\n    this.results.outputValues = Array(this.params.outputDimension).fill(0);\n    this.results.outputCovariance = Array(this.params.covarianceMode === 'full' ? this.params.outputDimension ** 2 : this.params.outputDimension).fill(0);\n    let tmpOutputValues;\n\n    for (let c = 0; c < this.params.gaussians; c += 1) {\n      tmpOutputValues = this.params.components[c].regression(inputObservation);\n      for (let d = 0; d < this.params.outputDimension; d += 1) {\n        this.results.outputValues[d] += this.beta[c] * tmpOutputValues[d];\n        if (this.params.covarianceMode === 'full') {\n          for (let d2 = 0; d2 < this.params.outputDimension; d2 += 1) {\n            this.results.outputCovariance[(d * this.params.outputDimension) + d2] +=\n              (this.beta[c] ** 2) *\n              this.params.components[c].outputCovariance[(d * this.params.outputDimension) + d2];\n          }\n        } else {\n          this.results.outputCovariance[d] +=\n            (this.beta[c] ** 2) * this.params.components[c].outputCovariance[d];\n        }\n      }\n    }\n    return this.results.outputValues;\n  },\n};\n\n/**\n * Add basic GMM capabilities to a single-class model. This enables the\n * computation of the likelihoods and regression operations common to\n * training and prediction\n *\n * @see withGMMTraining\n * @see withGMMPrediction\n *\n * @param  {ModelBase} o Source Model\n * @return {GMMBaseModel}\n *\n * @throws {Error} is o is not a ModelBase\n */\nexport default function withGMMBase(o) {\n  if (!isBaseModel(o)) {\n    throw new Error('The base object must include a standard set of parameters (`params` key), @see `ModelBase`.');\n  }\n  return Object.assign(\n    o,\n    gmmBasePrototype,\n    o.params.bimodal ? gmmBimodalPrototype : {},\n  );\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/gmm/gmm_base_mixin.js","import ModelBase from './model_base_mixin';\n\n/**\n * Multiclass Models Mixin\n * @type {Object}\n * @ignore\n */\nconst MulticlassBasePrototype = /** @lends MulticlassModelBase */{\n  /**\n   * Get the number of classes in the model\n   * @return {number} number of classes\n   */\n  size() {\n    return Object.keys(this.models).length;\n  },\n\n  /**\n   * Check if a class with the given label exists\n   * @param  {string} label Class label\n   * @return {boolean}\n   */\n  includes(label) {\n    return Object.keys(this.models).includes(label);\n  },\n\n  /**\n   * Remove a class by label\n   * @param  {string} label Class label\n   */\n  remove(label) {\n    if (this.includes(label)) {\n      delete this.models[label];\n    }\n  },\n};\n\n/**\n * Create an abstract Multiclass Model\n * @param       {number]} inputDimension  input dimension\n * @param       {number]} outputDimension output dimension\n * @param       {Object} parameters       additional parameters to copy\n * @function\n */\nexport default function MulticlassModelBase({\n  inputDimension,\n  outputDimension,\n  ...parameters\n}) {\n  return Object.assign(\n    ModelBase({ inputDimension, outputDimension, ...parameters }),\n    MulticlassBasePrototype,\n  );\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/core/multiclass_mixin.js","/**\n * Add multiclass training capabilities to a model. It takes as argument\n * the training function called to train each class of the training set.\n *\n * @param  {MulticlassModelBase} o Source model\n * @param  {Function}  trainingFunction Training function for a single class\n * @return {MulticlassModelBase}\n */\nexport default function withMulticlassTraining(\n  o,\n  trainingFunction,\n) {\n  return Object.assign(\n    o,\n    /** @lends withMulticlassTraining */ {\n      /**\n       * Train the model, optionally specifying a set of classes to train\n       *\n       * @param  {TrainingSet} trainingSet   Training data set\n       * @param  {undefined|Array<String>} [labels=undefined] Labels\n       * corresponding to the classes to be trained (all if unspecified)\n       * @return {Object} the parameters of the trained model\n       *\n       * @throws {Error} if the training set is empty\n       * @throws {Error} if one of the specified class does not exist\n       */\n      train(trainingSet, labels = undefined) {\n        if (!trainingSet || trainingSet.empty()) {\n          throw new Error('The training set is empty');\n        }\n        if (labels) {\n          labels.forEach((l) => {\n            if (!this.includes(l)) {\n              throw new Error(`Class labeled ${l} does not exist`);\n            }\n          });\n        }\n\n        this.params.classes = {};\n        const labs = labels || trainingSet.labels();\n        labs.forEach((label) => {\n          const ts = trainingSet.getPhrasesOfClass(label);\n          // console.log(ts);\n          this.params.classes[label] = trainingFunction(ts);\n        });\n        return this.params;\n      },\n    },\n  );\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/core/multiclass_training_mixin.js","import { isBaseModel } from './model_base_mixin';\nimport CircularBuffer from '../common/circular_buffer';\n\n/**\n * Prototype for models with prediction capabilities\n * @param  {Boolean} bimodal Specifies whether the model is bimodal\n * @return {Object}\n * @ignore\n */\nconst predictionBasePrototype = bimodal => (/** @lends withAbtractPrediction */{\n  /**\n   * Likelihood Buffer\n   * @type {CircularBuffer}\n   * @private\n   */\n  likelihoodBuffer: CircularBuffer(1),\n\n  /**\n   * Likelihood Window (used to smooth the log-likelihoods over several frames)\n   * @param {Number} [lw] Size (in frames) of the likelihood smoothing window\n   */\n  setLikelihoodWindow(lw) {\n    this.likelihoodWindow = lw;\n    this.likelihoodBuffer = CircularBuffer(lw);\n  },\n\n  /**\n   * Reset the prediction process\n   * @return {Modelbase} the model\n   */\n  reset() {\n    this.likelihoodBuffer.clear();\n    return this;\n  },\n\n  /**\n   * Update the predictions with a new observation\n   * @param  {Array<Number>} observation Observation vector\n   * @return {Object} Prediction results\n   *\n   * @todo document results data structure\n   */\n  predict(observation) {\n    const likelihood = this.likelihood(observation);\n    if (bimodal) {\n      this.regression(observation);\n    }\n    this.updateResults(likelihood);\n    return this.results;\n  },\n\n  /**\n   * Update the prediction results\n   * @param  {Number} instantLikelihood Instantaneous likelihood\n   * @private\n   */\n  updateResults(instantLikelihood) {\n    this.results.instantLikelihood = instantLikelihood;\n    this.likelihoodBuffer.push(Math.log(instantLikelihood));\n    this.results.logLikelihood = 0;\n    const bufSize = this.likelihoodBuffer.length;\n    for (let i = 0; i < bufSize; i += 1) {\n      this.results.logLikelihood += this.likelihoodBuffer.get(i);\n    }\n    this.results.logLikelihood /= bufSize;\n  },\n});\n\n/**\n * Add ABSTRACT prediction capabilities to an existing model\n * @param  {Modelbase} o                 Source model\n * @param  {Number} [likelihoodWindow=1] Size of the likelihood smoothing window\n * @return {Modelbase}\n */\nexport default function withAbtractPrediction(o, likelihoodWindow = 1) {\n  if (!isBaseModel(o)) {\n    throw new Error('The base object must include a standard set of parameters (`params` key), @see `ModelBase`.');\n  }\n  const results = Object.assign(\n    { instantLikelihood: 0, logLikelihood: 0 },\n    o.params.bimodal ? { outputValues: [], outputCovariance: [] } : {},\n  );\n  return Object.assign(\n    o,\n    predictionBasePrototype(o.params.bimodal),\n    { results, likelihoodBuffer: CircularBuffer(likelihoodWindow) },\n  );\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/core/prediction_mixin.js","/**\n * Check if the specification is respected for a given parameter and value,\n * and clip if relevant.\n *\n * @ignore\n *\n * @param  {String}        model      Stream Operator Name (for logging)\n * @param  {String}        parameter     Attribute name\n * @param  {Specification} specification Attribute specification\n * @param  {*}             value         Attribute value\n * @return {*}                           Type-checked parameter value\n */\nfunction checkSpec(model, parameter, specification, value) {\n  if (!specification) return;\n  if (specification.constructor === Array && !specification.includes(value)) {\n    throw new Error(`Attribute '${parameter}' (value: '${value}') is not allowed for model '${model}' (options: [${specification}]).`);\n  } else if (specification.constructor === Object) {\n    if (Object.keys(specification).includes('min') && value < specification.min) {\n      throw new Error(`Attribute '${parameter}' (value: ${value}) is inferior to the minimum required value of ${specification.min} for model '${model}'.`);\n    }\n    if (Object.keys(specification).includes('max') && value > specification.max) {\n      throw new Error(`Attribute '${parameter}' (value: ${value}) is superior to the maximum required value of ${specification.min} for model '${model}'.`);\n    }\n  } else if (typeof specification === 'function') {\n    if (!specification(value)) {\n      throw new Error(`Attribute '${parameter}' (value: ${value}) is incompatible with model '${model}'.`);\n    }\n  }\n}\n\n/**\n * Check the parameters of a model and return the parameters of the\n * output stream.\n *\n * The specification should be a structure of the form:\n * ```\n * const streamSpecification = {\n *   <parameter name>: {\n *     required: <boolean>,\n *     check: <null || Array || { min: <minimum value>, max: <maximum value>} || Function >,\n *     transform: Function,\n *   },\n * };\n * ```\n *\n * @param  {String} model      Name of the model for logging\n * @param  {Object} specification I/O Stream Specification\n * @param  {Object} values        Attributes of the input stream\n * @return {Object}               Attributes of the output stream\n *\n * @example\n * import setupStreamAttributes from 'stream';\n *\n * const specification = {\n *   type: {\n *     required: false,\n *     check: null,\n *     transform: x => x || null,\n *   },\n *   format: {\n *     required: true,\n *     check: ['scalar', 'vector'],\n *     transform: x => x,\n *   },\n *   size: {\n *     required: true,\n *     check: { min: 1 },\n *     transform: x => 2 * x,\n *   },\n *   stuff: {\n *     required: true,\n *     check: x => Math.log2(x) === Math.floor(Math.log2(x)),\n *     transform: x => Math.log2(x),\n *   },\n * };\n *\n * const values = {\n *   type: 'anything',\n *   format: 'vector',\n *   size: 3,\n *   stuff: 8,\n *   another: 'one',\n * };\n *\n * setupStreamAttributes('module name', specification, values);\n * // Returns:\n * // {\n * //   type: 'anything',\n * //   format: 'vector',\n * //   size: 6,\n * //   stuff: 3,\n * //   another: 'one',\n * // }\n */\nexport default function validateParameters(model, specification, values) {\n  const parameters = Object.assign({}, values);\n  Object.keys(specification).forEach((attr) => {\n    const spec = specification[attr];\n\n    // Check for required parameters\n    if (spec.required && !Object.keys(values).includes(attr)) {\n      throw new Error(`Stream parameter '${attr}' is required for model '${model}'.`);\n    }\n\n    // Check the validity of the input parameters\n    checkSpec(model, attr, spec.check, values[attr]);\n\n    parameters[attr] = spec.transform ?\n      spec.transform(values[attr]) :\n      values[attr];\n  });\n  return parameters;\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/common/validation.js","import { isBaseModel } from './model_base_mixin';\n\n/**\n * Multiclass prediction mixin\n * @type {Object}\n * @ignore\n */\nconst MulticlassPredictionBasePrototype = /** @lends withMulticlassPrediction */ {\n  /**\n   * Likelihood Window (used to smooth the log-likelihoods over several frames)\n   * @return {Number}\n   */\n  getLikelihoodWindow() {\n    return this.likelihoodWindow;\n  },\n\n  /**\n   * Likelihood Window (used to smooth the log-likelihoods over several frames)\n   * @param {Number} [lw] Size (in frames) of the likelihood smoothing window\n   */\n  setLikelihoodWindow(lw) {\n    this.likelihoodWindow = lw;\n    Object.keys(this.models).forEach((label) => {\n      this.models[label].setLikelihoodWindow(lw);\n    });\n  },\n\n  /**\n   * Reset the prediction process. This is particularly important for temporal\n   * models such as HMMs, that depends on previous observations.\n   */\n  reset() {\n    Object.values(this.models).forEach(m => m.reset());\n    this.results = {\n      labels: [],\n      instantLikelihoods: [],\n      smoothedLikelihoods: [],\n      smoothedLogLikelihoods: [],\n      smoothedNormalizedLikelihoods: [],\n      likeliest: null,\n      classes: {},\n    };\n    if (this.params.bimodal) {\n      this.resetBimodal();\n    }\n  },\n\n  /**\n   * Make a prediction from a new observation (updates the results member)\n   * @param  {Array<Number>} observation Observation vector\n   */\n  predict(observation) {\n    Object.values(this.models).forEach(m => m.predict(observation));\n    this.updateResults();\n  },\n\n  updateResults() {\n    const labs = Object.keys(this.models).sort();\n    this.results.labels = labs;\n    let normInstant = 0;\n    let normSmoothed = 0;\n    let maxLogLikelihood = -Infinity;\n    this.results.classes = labs\n      .map((lab, i) => {\n        this.results.instantLikelihoods[i] =\n          this.models[lab].results.instantLikelihood;\n        this.results.smoothedLogLikelihoods[i] =\n          this.models[lab].results.logLikelihood;\n        this.results.smoothedLikelihoods[i] =\n          Math.exp(this.results.smoothedLogLikelihoods[i]);\n        normInstant += this.results.instantLikelihoods[i];\n        normSmoothed += this.results.smoothedLikelihoods[i];\n        if (this.results.smoothedLogLikelihoods[i] > maxLogLikelihood) {\n          maxLogLikelihood = this.results.smoothedLogLikelihoods[i];\n          this.results.likeliest = lab;\n        }\n        return { [lab]: this.models[lab].results };\n      })\n      .reduce((o, x) => ({ ...o, ...x }), {});\n    this.results.smoothedNormalizedLikelihoods =\n      this.results.smoothedLikelihoods.map(x => x / normSmoothed);\n    this.results.instantNormalizedLikelihoods =\n      this.results.instantLikelihoods.map(x => x / normInstant);\n    if (this.params.bimodal) {\n      this.updateRegressionResults();\n    }\n  },\n};\n\nconst MulticlassPredictionBimodalPrototype = {\n  resetBimodal() {\n    this.results.outputValues = [];\n    this.results.outputCovariance = [];\n  },\n\n  updateRegressionResults() {\n    if (this.params.multiClassRegressionEstimator === 'likeliest') {\n      this.results.outputValues =\n        this.models[this.results.likeliest].results.outputValues;\n      this.results.outputCovariance =\n        this.models[this.results.likeliest].results.outputCovariance;\n    } else if (this.params.multiClassRegressionEstimator === 'mixture') {\n      this.results.outputValues = Array(this.outputDimension).fill(0);\n      this.results.outputCovariance = Array(this.outputDimension ** (this.configuration.covarianceMode === 'full' ? 2 : 1)).fill(0);\n      this.results.labels.forEach((lab) => {\n        this.results.outputValues.map((x, i) => x + (\n          this.results.smoothedNormalizedLikelihoods[i] *\n          this.models[lab].results.outputValues[i]\n        ));\n        this.results.outputCovariance.map((x, i) => x + (\n          this.results.smoothedNormalizedLikelihoods[i] *\n          this.models[lab].results.outputCovariance[i]\n        ));\n      });\n    } else {\n      throw new Error('Unknown regression estimator, use `likeliest` or `mixture`');\n    }\n  },\n};\n\n/**\n * Add multiclass prediction capabilities to a multiclass model\n * @param  {MulticlassModelBase} o Source model\n * @param  {String} [multiClassRegressionEstimator='likeliest'] Type of\n * regression estimator:\n * - `likeliest` selects the output values from the likeliest class\n * - `mixture` computes the output values as the weighted sum of the\n * contributions of each class, weighed by their normalized likelihood\n * @return {MulticlassPredictionBasePrototype}\n * @function\n */\nexport default function withMulticlassPrediction(o, multiClassRegressionEstimator = 'likeliest') {\n  if (!isBaseModel(o)) {\n    throw new Error('The base object must include a standard set of parameters (`params` key), @see `ModelBase`.');\n  }\n  const m = Object.assign(\n    o,\n    MulticlassPredictionBasePrototype,\n    o.params.bimodal ? MulticlassPredictionBimodalPrototype : {},\n  );\n  m.params.multiClassRegressionEstimator = multiClassRegressionEstimator;\n  return m;\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/core/multiclass_prediction_mixin.js","/**\n * Data Phrase Prototype\n * @ignore\n */\nconst phrasePrototype = /** @lends Phrase */ {\n  /**\n   * Get the value at a given index and dimension\n   * @param  {Number} index index\n   * @param  {Number} dim   dimension\n   * @return {Number}\n   */\n  get(index, dim) {\n    if (typeof index !== 'number' || Math.floor(index) !== index) {\n      throw new Error('The index must be an integer');\n    }\n    if (dim >= this.dimension) {\n      throw new Error('Phrase: dimension out of bounds');\n    }\n    if (this.bimodal) {\n      if (dim < this.inputDimension) {\n        if (index >= this.inputData.length) {\n          throw new Error('Phrase: index out of bounds');\n        }\n        return this.inputData[index][dim];\n      }\n      if (index >= this.outputData.length) {\n        throw new Error('Phrase: index out of bounds');\n      }\n      return this.outputData[index][dim - this.inputDimension];\n    }\n    if (index >= this.length) {\n      throw new Error('Phrase: index out of bounds');\n    }\n    if (!this.inputData[index]) {\n      throw new Error('WTF?');\n    }\n    return this.inputData[index][dim];\n  },\n\n  /**\n   * Get the data frame at a given index\n   * @param  {Number} index index\n   * @return {Array<number>}\n   * @throws {Error} if the index is out of bounds\n   */\n  getFrame(index) {\n    if (index >= this.length) {\n      throw new Error('Phrase: index out of bounds');\n    }\n    if (this.bimodal) {\n      return this.inputData[index].concat(this.outputData[index]);\n    }\n    return this.inputData[index];\n  },\n\n  /**\n   * Push an observation vector to the phrase\n   * @param  {Array<number>} observation observation data\n   * @throws {Error} if the observation's dimension does not match the\n   * dimension of the training set\n   */\n  push(observation) {\n    // console.log('push:', observation);\n    if (observation.length !== this.dimension) {\n      throw new Error('Observation has wrong dimension');\n    }\n\n    if (this.bimodal) {\n      this.inputData.push(observation.slice(0, this.inputDimension));\n      this.outputData.push(observation.slice(this.inputDimension, this.dimension));\n    } else {\n      this.inputData.push(observation);\n    }\n\n    this.length += 1;\n  },\n\n  /**\n   * Push an observation to the input modality only\n   * @param  {Array<number>} observation observation data\n   * @throws {Error} if the phrase is not bimodal\n   * @throws {Error} if the observation's dimension does not match the\n   * input dimension of the training set\n   */\n  pushInput(observation) {\n    if (!this.bimodal) {\n      throw new Error('this phrase is unimodal, use `push`');\n    }\n    if (observation.size() !== this.inputDimension) {\n      throw new Error('Observation has wrong dimension');\n    }\n\n    this.inputData.push(observation);\n    this.trim();\n  },\n\n  /**\n   * Push an observation to the output modality only\n   * @param  {Array<number>} observation observation data\n   * @throws {Error} if the phrase is not bimodal\n   * @throws {Error} if the observation's dimension does not match the\n   * output dimension of the training set\n   */\n  pushOutput(observation) {\n    if (!this.bimodal) {\n      throw new Error('this phrase is unimodal, use `push`');\n    }\n    if (observation.size() !== this.outputDimension) {\n      throw new Error('Observation has wrong dimension');\n    }\n\n    this.outputData.push(observation);\n    this.trim();\n  },\n\n  /**\n   * Clear the phrase's data\n   */\n  clear() {\n    this.length = 0;\n    this.inputData = [];\n    this.outputData = [];\n  },\n\n  /**\n   * Clear the phrase's input data\n   */\n  clearInput() {\n    this.inputData = [];\n    this.trim();\n  },\n\n  /**\n   * Clear the phrase's output data\n   */\n  clearOutput() {\n    this.outputData = [];\n    this.trim();\n  },\n\n  /**\n   * Compute the mean of the phrase (across time)\n   * @return {Array<number>} The mean vector (same dimension as the\n   * training set)\n   */\n  mean() {\n    const mean = Array(this.dimension).fill(0);\n    for (let d = 0; d < this.dimension; d += 1) {\n      for (let t = 0; t < this.length; t += 1) {\n        mean[d] += this.get(t, d);\n      }\n      mean[d] /= this.length;\n    }\n    return mean;\n  },\n\n  /**\n   * Compute the standard deviation of the phrase (across time)\n   * @return {Array<number>} The standard deviation vector (same dimension as\n   * the training set)\n   */\n  standardDeviation() {\n    const stddev = Array(this.dimension).fill(0);\n    const mean = this.mean();\n    for (let d = 0; d < this.dimension; d += 1) {\n      for (let t = 0; t < this.length; t += 1) {\n        stddev[d] += (this.get(t, d) - mean[d]) * (this.get(t, d) - mean[d]);\n      }\n      stddev[d] /= this.length;\n      stddev[d] = Math.sqrt(stddev[d]);\n    }\n    return stddev;\n  },\n\n  /**\n   * Compute the minimum and maximum of the phrase (across time)\n   * @return {Array<{ min: number, max: number }>} The min/max vector (same\n   * dimension as the training set)\n   */\n  minmax() {\n    const minmax = Array.from(\n      Array(this.dimension),\n      () => ({ min: +Infinity, max: -Infinity }),\n    );\n    for (let d = 0; d < this.dimension; d += 1) {\n      for (let t = 0; t < this.length; t += 1) {\n        minmax[d].min = Math.min(this.get(t, d), minmax[d].min);\n        minmax[d].max = Math.max(this.get(t, d), minmax[d].max);\n      }\n    }\n    return minmax;\n  },\n\n  /**\n   * Trim the phrase length to the minimum of the input and output lengths\n   * @private\n   */\n  trim() {\n    if (this.bimodal) {\n      this.length = Math.min(this.inputData.length, this.outputData.length);\n    }\n  },\n};\n\n/**\n * Create a data phrase, potentially bimodal. Phrases are data structures for\n * temporal data (e.g. gestures), used to constitute training sets.\n *\n * @param {Object} [params]                   Phrase parameters\n * @param {Number} [params.inputDimension=1]  Dimension of the input modality\n * @param {Number} [params.outputDimension=0] Dimension of the output modality\n * (optional)\n * @param {Array<String>} [params.columnNames=null] Data column names, e.g.\n * \\['accX', 'accY', 'accZ'\\] (optional)\n * @param {String} [params.label='']          Phrase label\n * @return {Phrase}\n * @function\n *\n * @property {Boolean} bimodal Specifies if the phrase is bimodal\n * @property {Number} inputDimension Dimension of the input modality\n * @property {Number} outputDimension Dimension of the output modality\n * @property {Number} dimension Total dimension\n * @property {Number} length Phrase length (number of frames)\n * @property {String} label Phrase label\n * @property {Array<String>} columnNames Columns names\n */\nexport default function Phrase({\n  inputDimension = 1,\n  outputDimension = 0,\n  columnNames = null,\n  label = '',\n} = {}) {\n  const dimension = inputDimension + outputDimension;\n  return Object.assign(\n    Object.create(phrasePrototype),\n    {\n      bimodal: outputDimension > 0,\n      inputDimension,\n      outputDimension,\n      dimension,\n      length: 0,\n      label,\n      inputData: [],\n      outputData: [],\n      columnNames: columnNames || Array(dimension).fill(''),\n    },\n  );\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/training_set/phrase.js","import ModelBase from '../core/model_base_mixin';\nimport withKMeansTraining from './kmeans_training_mixin';\n\n/**\n * Train a K-Means model.\n *\n * @todo K-Means details\n *\n * @param  {TrainingSet} trainingSet           training set\n * @param  {number} clusters                   Number of clusters\n * @param  {Object} [trainingConfig=undefined] Training configuration\n * @return {Object}                            K-Means parameters\n */\nexport default function trainKmeans(\n  trainingSet,\n  clusters,\n  trainingConfig = undefined,\n) {\n  const { inputDimension, outputDimension } = trainingSet;\n  const model = withKMeansTraining(\n    ModelBase({\n      inputDimension,\n      outputDimension,\n    }),\n    clusters,\n    trainingConfig,\n  );\n  return model.train(trainingSet);\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/kmeans/index.js","/**\n * Compute the euclidean distance between to vectors\n * @param  {Array} v1\n * @param  {Array} v2\n * @return {number}\n */\nexport default function euclidean(v1, v2) {\n  return Math.sqrt(v1\n    .map((x1, i) => (x1 - v2[i]) ** 2)\n    .reduce((a, x) => (a + x), 0));\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/common/euclidean.js","/* eslint-disable no-use-before-define */\nconst kEpsilonPseudoInverse = 1.0e-9;\n\n/**\n * Matrix Prototype\n * @type {Object}\n * @property {Array} data Matrix data\n * @property {Number} ncols Number of columns\n * @property {Number} nrows Number of rows\n *\n * @ignore\n */\nconst matrixPrototype = /** @lends Matrix */ {\n  /**\n   * Compute the Sum of the matrix\n   * @return {Number} Sum of all elements in the matrix\n   */\n  sum() {\n    return this.data.reduce((a, b) => a + b, 0);\n  },\n\n  /**\n   * Compute the transpose matrix\n   * @return {Matrix}\n   */\n  transpose() {\n    const out = Matrix(this.ncols, this.nrows);\n    for (let i = 0; i < this.ncols; i += 1) {\n      for (let j = 0; j < this.nrows; j += 1) {\n        out.data[(i * this.nrows) + j] = this.data[(j * this.ncols) + i];\n      }\n    }\n    return out;\n  },\n\n  /**\n   * Compute the product of matrices\n   * @param  {Matrix} mat Second matrix\n   * @return {Matrix}     Product of the current matrix by `mat`\n   */\n  product(mat) {\n    if (this.ncols !== mat.nrows) {\n      throw new Error('Wrong dimensions for matrix product');\n    }\n    const out = Matrix(this.nrows, mat.ncols);\n    for (let i = 0; i < this.nrows; i += 1) {\n      for (let j = 0; j < mat.ncols; j += 1) {\n        out.data[(i * mat.ncols) + j] = 0;\n        for (let k = 0; k < this.ncols; k += 1) {\n          out.data[(i * mat.ncols) + j] +=\n            this.data[(i * this.ncols) + k] * mat.data[(k * mat.ncols) + j];\n        }\n      }\n    }\n    return out;\n  },\n\n  /**\n   * Compute the Pseudo-Inverse of a Matrix\n   * @param  {Number} determinant Determinant (computed with the inversion)\n   * @return {Matrix}             Pseudo-inverse of the matrix\n   */\n  pinv() {\n    if (this.nrows === this.ncols) {\n      return this.gaussJordanInverse();\n    }\n\n    const transp = this.transpose();\n    if (this.nrows >= this.ncols) {\n      const prod = transp.product(this);\n      const { determinant, matrix: dst } = prod.gaussJordanInverse();\n      return { determinant, matrix: dst.product(transp) };\n    }\n    const prod = this.product(transp);\n    const { determinant, matrix: dst } = prod.gaussJordanInverse();\n    return { determinant, matrix: transp.product(dst) };\n  },\n\n  /**\n   * Compute the Gauss-Jordan Inverse of a Square Matrix\n   * !!! Determinant (computed with the inversion\n   * @private\n   */\n  gaussJordanInverse() {\n    if (this.nrows !== this.ncols) {\n      throw new Error('Gauss-Jordan inversion: Cannot invert Non-square matrix');\n    }\n    let determinant = 1;\n    const mat = Matrix(this.nrows, this.ncols * 2);\n    const newMat = Matrix(this.nrows, this.ncols * 2);\n    const n = this.nrows;\n\n    // Create matrix\n    for (let i = 0; i < n; i += 1) {\n      for (let j = 0; j < n; j += 1) {\n        mat.data[(i * 2 * n) + j] = this.data[(i * n) + j];\n      }\n      mat.data[(i * 2 * n) + n + i] = 1;\n    }\n\n    for (let k = 0; k < n; k += 1) {\n      let i = k;\n      while (Math.abs(mat.data[(i * 2 * n) + k]) < kEpsilonPseudoInverse) {\n        i += 1;\n        if (i === n) {\n          throw new Error('Non-invertible matrix');\n        }\n      }\n      determinant *= mat.data[(i * 2 * n) + k];\n\n      // if found > Exchange lines\n      if (i !== k) {\n        mat.swapLines(i, k);\n      }\n\n      newMat.data = mat.data.slice();\n\n      for (let j = 0; j < 2 * n; j += 1) {\n        newMat.data[(k * 2 * n) + j] /= mat.data[(k * 2 * n) + k];\n      }\n      for (let ii = 0; ii < n; ii += 1) {\n        if (ii !== k) {\n          for (let j = 0; j < 2 * n; j += 1) {\n            newMat.data[(ii * 2 * n) + j] -=\n                mat.data[(ii * 2 * n) + k] *\n                newMat.data[(k * 2 * n) + j];\n          }\n        }\n      }\n      mat.data = newMat.data.slice();\n    }\n\n    const dst = Matrix(this.nrows, this.ncols);\n    for (let i = 0; i < n; i += 1) {\n      for (let j = 0; j < n; j += 1) {\n        dst.data[(i * n) + j] = mat.data[(i * 2 * n) + n + j];\n      }\n    }\n    return { determinant, matrix: dst };\n  },\n\n  /**\n   * Swap 2 lines of the matrix\n   * @param  {[type]} i index of the first line\n   * @param  {[type]} j index of the second line\n   * @private\n   */\n  swapLines(i, j) {\n    for (let k = 0; k < this.ncols; k += 1) {\n      const tmp = this.data[(i * this.ncols) + k];\n      this.data[(i * this.ncols) + k] = this.data[(j * this.ncols) + k];\n      this.data[(j * this.ncols) + k] = tmp;\n    }\n  },\n\n  /**\n   * Swap 2 columns of the matrix\n   * @param  {[type]} i index of the first column\n   * @param  {[type]} j index of the second column\n   * @private\n   */\n  swapColumns(i, j) {\n    for (let k = 0; k < this.nrows; k += 1) {\n      const tmp = this.data[(k * this.ncols) + i];\n      this.data[(k * this.ncols) + i] = this.data[(k * this.ncols) + j];\n      this.data[(k * this.ncols) + j] = tmp;\n    }\n  },\n};\n\n/**\n * Create a matrix\n *\n * @function\n * @param       {Number} [nrows=0]  Number of rows\n * @param       {Number} [ncols=-1] Number of columns\n * @return {matrixPrototype}\n *\n * @property {Array} data Matrix data\n * @property {Number} ncols Number of columns\n * @property {Number} nrows Number of rows\n */\nexport default function Matrix(nrows = 0, ncols = -1) {\n  const nc = ncols < 0 ? nrows : ncols;\n  return Object.assign(\n    Object.create(matrixPrototype), //\n    {\n      nrows,\n      ncols: nc,\n      data: Array(nrows * nc).fill(0),\n    },\n  );\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/common/matrix.js","import ModelBase from '../core/model_base_mixin';\nimport withKMeansTraining from '../kmeans/kmeans_training_mixin';\n\n/**\n * GMM Training Prototype\n * @type {Object}\n * @ignore\n */\nconst gmmTrainerPrototype = /** @lends withGMMTraining */ {\n  /**\n   * Initialize the EM Training process\n   * @param  {TrainingSet} trainingSet Training set\n   */\n  initTraining(trainingSet) {\n    this.allocate();\n    this.initParametersToDefault(trainingSet.standardDeviation());\n    this.initMeansWithKMeans(trainingSet);\n    this.initCovariances(trainingSet);\n    this.regularize();\n    this.updateInverseCovariances();\n  },\n\n  /**\n   * Initialize the model parameters to their default values\n   * @param  {Array<Number>} dataStddev Standard deviation of the training data\n   * @private\n   */\n  initParametersToDefault(dataStddev) {\n    let normCoeffs = 0;\n    this.currentRegularization = dataStddev.map(std => Math.max(\n      this.params.regularization.absolute,\n      this.params.regularization.relative * std,\n    ));\n    for (let c = 0; c < this.params.gaussians; c += 1) {\n      if (this.params.covarianceMode === 'full') {\n        this.params.components[c].covariance = Array(this.params.dimension ** 2)\n          .fill(this.params.regularization.absolute / 2);\n      } else {\n        this.params.components[c].covariance = Array(this.params.dimension).fill(0);\n      }\n      this.params.components[c].regularize(this.currentRegularization);\n      this.params.mixtureCoeffs[c] = 1 / this.params.gaussians;\n      normCoeffs += this.params.mixtureCoeffs[c];\n    }\n    for (let c = 0; c < this.params.gaussians; c += 1) {\n      this.params.mixtureCoeffs[c] /= normCoeffs;\n    }\n  },\n\n  /**\n   * Initialize the means of the model using a K-Means algorithm\n   *\n   * @see withKMeansTraining\n   *\n   * @param  {TrainingSet} trainingSet training set\n   * @private\n   */\n  initMeansWithKMeans(trainingSet) {\n    if (!trainingSet || trainingSet.empty()) return;\n    const kmeans = withKMeansTraining(\n      ModelBase({\n        inputDimension: this.params.inputDimension,\n        outputDimension: this.params.outputDimension,\n      }),\n      this.params.gaussians,\n      { initialization: 'data' },\n    );\n    const kmeansParams = kmeans.train(trainingSet);\n    for (let c = 0; c < this.params.gaussians; c += 1) {\n      this.params.components[c].mean = kmeansParams.centers[c];\n    }\n  },\n\n  /**\n   * Initialize the covariances of the model from the training set\n   *\n   * @param  {TrainingSet} trainingSet training set\n   * @private\n   */\n  initCovariances(trainingSet) {\n    // TODO: simplify with covariance symmetricity\n    // TODO: If Kmeans, covariances from cluster members\n    if (!trainingSet || trainingSet.empty()) return;\n\n    for (let n = 0; n < this.params.gaussians; n += 1) {\n      this.params.components[n].covariance = Array((this.params.covarianceMode === 'full') ? this.params.dimension ** 2 : this.params.dimension).fill(0);\n    }\n\n    const gmeans = Array(this.params.gaussians * this.params.dimension).fill(0);\n    const factor = Array(this.params.gaussians).fill(0);\n    trainingSet.forEach((phrase) => {\n      const step = Math.floor(phrase.length / this.params.gaussians);\n      let offset = 0;\n      for (let n = 0; n < this.params.gaussians; n += 1) {\n        for (let t = 0; t < step; t += 1) {\n          for (let d1 = 0; d1 < this.params.dimension; d1 += 1) {\n            gmeans[(n * this.params.dimension) + d1] += phrase.get(offset + t, d1);\n            if (this.params.covarianceMode === 'full') {\n              for (let d2 = 0; d2 < this.params.dimension; d2 += 1) {\n                this.params.components[n]\n                  .covariance[(d1 * this.params.dimension) + d2] +=\n                  phrase.get(offset + t, d1) * phrase.get(offset + t, d2);\n              }\n            } else {\n              this.params.components[n].covariance[d1] +=\n                phrase.get(offset + t, d1) ** 2;\n            }\n          }\n        }\n        offset += step;\n        factor[n] += step;\n      }\n    });\n\n    for (let n = 0; n < this.params.gaussians; n += 1) {\n      for (let d1 = 0; d1 < this.params.dimension; d1 += 1) {\n        gmeans[(n * this.params.dimension) + d1] /= factor[n];\n        if (this.params.covarianceMode === 'full') {\n          for (let d2 = 0; d2 < this.params.dimension; d2 += 1) {\n            this.params.components[n].covariance[(d1 * this.params.dimension) + d2] /= factor[n];\n          }\n        } else {\n          this.params.components[n].covariance[d1] /= factor[n];\n        }\n      }\n    }\n\n    for (let n = 0; n < this.params.gaussians; n += 1) {\n      for (let d1 = 0; d1 < this.params.dimension; d1 += 1) {\n        if (this.params.covarianceMode === 'full') {\n          for (let d2 = 0; d2 < this.params.dimension; d2 += 1) {\n            this.params.components[n].covariance[(d1 * this.params.dimension) + d2] -=\n              gmeans[(n * this.params.dimension) + d1] *\n              gmeans[(n * this.params.dimension) + d2];\n          }\n        } else {\n          this.params.components[n].covariance[d1] -=\n            gmeans[(n * this.params.dimension) + d1] ** 2;\n        }\n      }\n    }\n  },\n\n  /**\n   * Update the EM Training process (1 EM iteration).\n   * @param  TrainingSet trainingSet training set\n   */\n  updateTraining(trainingSet) {\n    let logProb = 0;\n    let totalLength = 0;\n    trainingSet.forEach((phrase) => {\n      totalLength += phrase.length;\n    });\n    const phraseIndices = Object.keys(trainingSet.phrases);\n\n    const p = Array.from(\n      Array(this.params.gaussians),\n      () => new Array(totalLength).fill(0),\n    );\n    const E = Array(this.params.gaussians).fill(0);\n    let tbase = 0;\n\n    trainingSet.forEach((phrase) => {\n      for (let t = 0; t < phrase.length; t += 1) {\n        let normConst = 0;\n        for (let c = 0; c < this.params.gaussians; c += 1) {\n          p[c][tbase + t] = this.componentLikelihood(phrase.getFrame(t), c);\n\n          if (p[c][tbase + t] === 0 ||\n            Number.isNaN(p[c][tbase + t]) ||\n            p[c][tbase + t] === +Infinity) {\n            p[c][tbase + t] = 1e-100;\n          }\n          normConst += p[c][tbase + t];\n        }\n        for (let c = 0; c < this.params.gaussians; c += 1) {\n          p[c][tbase + t] /= normConst;\n          E[c] += p[c][tbase + t];\n        }\n        logProb += Math.log(normConst);\n      }\n      tbase += phrase.length;\n    });\n\n    // Estimate Mixture coefficients\n    for (let c = 0; c < this.params.gaussians; c += 1) {\n      this.params.mixtureCoeffs[c] = E[c] / totalLength;\n    }\n\n    // Estimate means\n    for (let c = 0; c < this.params.gaussians; c += 1) {\n      for (let d = 0; d < this.params.dimension; d += 1) {\n        this.params.components[c].mean[d] = 0;\n        tbase = 0;\n        for (let pix = 0; pix < phraseIndices.length; pix += 1) {\n          const phrase = trainingSet.phrases[phraseIndices[pix]];\n          for (let t = 0; t < phrase.length; t += 1) {\n            this.params.components[c].mean[d] +=\n              p[c][tbase + t] * phrase.get(t, d);\n          }\n          tbase += phrase.length;\n        }\n        this.params.components[c].mean[d] /= E[c];\n      }\n    }\n\n    // estimate covariances\n    if (this.params.covarianceMode === 'full') {\n      for (let c = 0; c < this.params.gaussians; c += 1) {\n        for (let d1 = 0; d1 < this.params.dimension; d1 += 1) {\n          for (let d2 = d1; d2 < this.params.dimension; d2 += 1) {\n            this.params.components[c].covariance[(d1 * this.params.dimension) + d2] = 0;\n            tbase = 0;\n            for (let pix = 0; pix < phraseIndices.length; pix += 1) {\n              const phrase = trainingSet.phrases[phraseIndices[pix]];\n              for (let t = 0; t < phrase.length; t += 1) {\n                this.params.components[c].covariance[(d1 * this.params.dimension) + d2] +=\n                  p[c][tbase + t] *\n                  (phrase.get(t, d1) - this.params.components[c].mean[d1]) *\n                  (phrase.get(t, d2) - this.params.components[c].mean[d2]);\n              }\n              tbase += phrase.length;\n            }\n            this.params.components[c].covariance[(d1 * this.params.dimension) + d2] /= E[c];\n            if (d1 !== d2) {\n              this.params.components[c].covariance[(d2 * this.params.dimension) + d1] =\n                this.params.components[c].covariance[(d1 * this.params.dimension) + d2];\n            }\n          }\n        }\n      }\n    } else {\n      for (let c = 0; c < this.params.gaussians; c += 1) {\n        for (let d1 = 0; d1 < this.params.dimension; d1 += 1) {\n          this.params.components[c].covariance[d1] = 0;\n          tbase = 0;\n          for (let pix = 0; pix < phraseIndices.length; pix += 1) {\n            const phrase = trainingSet.phrases[phraseIndices[pix]];\n            for (let t = 0; t < phrase.length; t += 1) {\n              const value = (phrase.get(t, d1) - this.params.components[c].mean[d1]);\n              this.params.components[c].covariance[d1] +=\n                    p[c][tbase + t] * value * value;\n            }\n            tbase += phrase.length;\n          }\n          this.params.components[c].covariance[d1] /= E[c];\n        }\n      }\n    }\n\n    this.regularize();\n    this.updateInverseCovariances();\n\n    return logProb;\n  },\n\n  /**\n   * Terminate the EM Training process\n   */\n  terminateTraining() {},\n};\n\n/**\n * Add GMM Training capabilities to a GMM Model\n * @param  {GMMBase} o               Source GMM Model\n * @param  {Number} [gaussians=1]    Number of Gaussian components\n * @param  {Object} [regularization] Regularization parameters\n * @param  {Number} [regularization.absolute=1e-3] Absolute regularization\n * @param  {Number} [regularization.relative=1e-2] Relative Regularization\n (relative to the training set's variance along each dimension)\n * @param  {String} [covarianceMode='full'] Covariance mode ('full' or diagonal)\n * @return {BMMBase}\n */\nexport default function withGMMTraining(\n  o,\n  gaussians = 1,\n  regularization = { absolute: 1e-3, relative: 1e-2 },\n  covarianceMode = 'full',\n) {\n  if (!Object.keys(o).includes('params')) {\n    throw new Error('The base object must include a standard set of parameters (`params` key), @see `ModelBase`.');\n  }\n  return Object.assign(\n    o,\n    gmmTrainerPrototype,\n    {\n      params: {\n        ...o.params,\n        gaussians,\n        regularization,\n        covarianceMode,\n      },\n    },\n  );\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/gmm/gmm_training_mixin.js","/**\n * Circular Buffer prototype\n *\n * @property {number}  capacity Buffer capacity\n * @property {number}  length Current buffer length\n * @property {boolean} full Specifies if the buffer is full\n *\n * @ignore\n */\nconst circularBufferPrototype = /** @lends CircularBuffer */ {\n  /**\n   * Clear the buffer contents\n   */\n  clear() {\n    this.length = 0;\n    this.index = 0;\n    this.full = false;\n    this.buffer = [];\n  },\n\n  /**\n   * Push a value to the buffer\n   * @param  {*} value data value (any type)\n   */\n  push(value) {\n    if (this.full) {\n      this.buffer[this.index] = value;\n      this.index = (this.index + 1) % this.capacity;\n    } else {\n      this.buffer.push(value);\n      this.length += 1;\n      this.full = (this.length === this.capacity);\n    }\n  },\n\n  /**\n   * Get the value at a given index\n   * @param  {number} idx data index\n   * @return {anything}   value at index\n   */\n  get(idx) {\n    return this.buffer[(idx + this.index) % this.capacity];\n  },\n\n  /**\n   * Fill the buffer with a constant value\n   * @param  {*} value data value (any type)\n   */\n  fill(value) {\n    this.length = this.capacity;\n    this.index = 0;\n    this.full = true;\n    this.buffer = Array(this.capacity).fill(value);\n  },\n\n  /**\n   * Iterate over the buffer's data\n   * @param  {Function} callback Callback function\n   * (@see Array.prototype.forEach).\n   */\n  forEach(callback) {\n    for (let i = 0; i < this.length; i += 1) {\n      callback(this.buffer[(i + this.index) % this.capacity], i);\n    }\n  },\n\n  /**\n   * Get an array of the buffer current values (ordered)\n   * @return {Array} Buffer contents\n   */\n  values() {\n    return this.buffer.slice(this.index)\n      .concat(this.buffer.slice(0, this.index));\n  },\n};\n\n/**\n * Circular Buffer Data Structure (any data type)\n * @param  {number} capacity Buffer capacity\n * @return {circularBufferPrototype}\n * @function\n *\n * @property {number}  capacity Buffer capacity\n * @property {number}  length Current buffer length\n * @property {boolean} full Specifies if the buffer is full\n */\nexport default function CircularBuffer(capacity) {\n  const buffer = Object.create(circularBufferPrototype);\n  buffer.capacity = capacity;\n  buffer.clear();\n  return buffer;\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/common/circular_buffer.js","import validateParameters from '../common/validation';\nimport { isBaseModel } from '../core/model_base_mixin';\n\nconst gmmParameterSpec = gaussians => ({\n  gaussians: {\n    required: true,\n    check: { min: 1 },\n  },\n  regularization: {\n    required: true,\n    check: ({ absolute, relative }) =>\n      (absolute && relative && absolute > 0 && relative > 0),\n  },\n  covarianceMode: {\n    required: true,\n    check: ['full', 'diagonal'],\n  },\n  mixtureCoeffs: {\n    required: true,\n    check: m => m.length === gaussians,\n  },\n  components: {\n    required: true,\n    check: c => c.length === gaussians,\n  },\n});\n\n/**\n * Add GMM prediction capabilities to a single-class model. Mostly, this checks\n * the validity of the model parameters\n *\n * @todo validate gaussian components\n *\n * @param  {GMMBaseModel} o Source Model\n * @return {GMMBaseModel}\n *\n * @throws {Error} is o is not a ModelBase\n */\nexport default function withGMMPrediction(o) {\n  if (!isBaseModel(o)) {\n    throw new Error('The base object must include a standard set of parameters (`params` key), @see `ModelBase`.');\n  }\n  validateParameters('GMM', gmmParameterSpec(o.params.gaussians), o.params);\n  return Object.assign(\n    o,\n    { beta: new Array(o.params.gaussians).fill(0) },\n  );\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/gmm/gmm_prediction_mixin.js","import ModelBase from '../core/model_base_mixin';\nimport withEMTraining from '../core/em_training_mixin';\nimport withHMMBase from './hmm_base_mixin';\nimport withHMMTraining from './hmm_training_mixin';\nimport MulticlassModelBase from '../core/multiclass_mixin';\nimport withMulticlassTraining from '../core/multiclass_training_mixin';\nimport withAbtractPrediction from '../core/prediction_mixin';\nimport withHMMPrediction from './hmm_prediction_mixin';\nimport withMulticlassPrediction from '../core/multiclass_prediction_mixin';\nimport withHierarchicalHMMPrediction from './hierarchical_hmm_prediction_mixin';\n\n/**\n * @typedef {Object} HMMParameters\n * @property {Boolean} bimodal Specifies if the model is bimodal\n * @property {Number} inputDimension Dimension of the input modality\n * @property {Number} outputDimension Dimension of the output modality\n * @property {Number} dimension Total dimension\n * @property {Number} states Number of hidden states in the Markov model\n * @property {Number} gaussians Number of components in the Gaussian mixture\n * observation distribution of each state\n * @property {String} transitionMode Transition matrix mode ('ergodic' or 'leftright')\n * @property {String} covarianceMode Covariance mode ('full' or 'diagonal')\n * @property {Array<Number>} mixtureCoeffs mixture coefficients ('weight' of\n * each gaussian component)\n * @property {Array<GaussianDistribution>} components Gaussian components\n */\n\n/**\n * Train a single-class HMM Model.\n *\n * @todo HMM details\n *\n * @param  {TrainingSet} trainingSet                training set\n * @param  {Object} configuration                   Training configuration\n * @param  {Object} [convergenceCriteria=undefined] Convergence criteria of the\n * EM algorithm\n * @return {HMMParameters} Parameters of the trained HMM\n */\nexport function trainHMM(\n  trainingSet,\n  configuration,\n  convergenceCriteria = undefined,\n) {\n  const { inputDimension, outputDimension } = trainingSet;\n  const {\n    states,\n    gaussians,\n    regularization,\n    transitionMode,\n    covarianceMode,\n  } = configuration;\n  const model = withHMMTraining(\n    withEMTraining(\n      withHMMBase(ModelBase({\n        inputDimension,\n        outputDimension,\n        ...configuration,\n      })),\n      convergenceCriteria,\n    ),\n    states,\n    gaussians,\n    regularization,\n    transitionMode,\n    covarianceMode,\n  );\n  return model.train(trainingSet);\n}\n\n/**\n * Train a multi-class HMM Model.\n *\n * @todo HMM details\n *\n * @param  {TrainingSet} trainingSet                training set\n * @param  {Object} configuration                   Training configuration\n * @param  {Object} [convergenceCriteria=undefined] Convergence criteria of the\n * EM algorithm\n * @return {Object} Parameters of the trained HMM\n */\nexport function trainMulticlassHMM(\n  trainingSet,\n  configuration,\n  convergenceCriteria = undefined,\n) {\n  const { inputDimension, outputDimension } = trainingSet;\n  const model = withMulticlassTraining(\n    MulticlassModelBase({ inputDimension, outputDimension, ...configuration }),\n    ts => trainHMM(ts, configuration, convergenceCriteria),\n  );\n  return model.train(trainingSet);\n}\n\n/**\n * Create a HMM Predictor from a full set of parameters (generated by trainHMM).\n * @param       {Object} params                       Model parameters\n * @param       {number} [likelihoodWindow=undefined] Likelihoow window size\n * @function\n */\nexport function HMMPredictor(\n  params,\n  likelihoodWindow = undefined,\n) {\n  const model = withHMMPrediction(withAbtractPrediction(\n    withHMMBase(ModelBase(params)),\n    likelihoodWindow,\n  ));\n  model.reset();\n  return model;\n}\n\n/**\n * Create a Multiclass HMM Predictor from a full set of parameters\n * (generated by trainMulticlassHMM).\n * @param       {Object} params                       Model parameters\n * @param       {number} [likelihoodWindow=undefined] Likelihoow window size\n * @function\n */\nexport function MulticlassHMMPredictor(\n  params,\n  likelihoodWindow = undefined,\n) {\n  const model = withMulticlassPrediction(MulticlassModelBase(params));\n  model.models = {};\n  Object.keys(params.classes).forEach((label) => {\n    model.models[label] = HMMPredictor(params.classes[label], likelihoodWindow);\n  });\n  model.reset();\n  return model;\n}\n\n/**\n * Create a Multiclass HMM Predictor from a full set of parameters\n * (generated by trainMulticlassHMM).\n * @param       {Object} params                       Model parameters\n * @param       {number} [likelihoodWindow=undefined] Likelihoow window size\n * @function\n */\nexport function HierarchicalHMMPredictor(\n  params,\n  likelihoodWindow = undefined,\n) {\n  let model = MulticlassModelBase(params);\n  model.models = {};\n  Object.keys(params.classes).forEach((label) => {\n    model.models[label] = HMMPredictor(params.classes[label], likelihoodWindow);\n  });\n  model = withHierarchicalHMMPrediction(withMulticlassPrediction(model));\n  model.reset();\n  return model;\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/hmm/index.js","import { isBaseModel } from '../core/model_base_mixin';\n\n//\n// TODO: hierarchical + exit probabilities methods.\n//\n\n/**\n * HMM Base prototype\n * @type {Object}\n * @ignore\n */\nconst hmmBasePrototype = /** @lends withHMMBase */ {\n  /**\n   * Specifies if the forward algorithm has been initialized\n   * @type {Boolean}\n   * @private\n   */\n  forwardInitialized: false,\n\n  /**\n   * Specifies if the containing multiclass model is isHierarchical\n   * @todo check that\n   * @type {Boolean}\n   * @private\n   */\n  isHierarchical: false,\n\n  /**\n   * Initialize the forward algorithm (See rabiner, 1989)\n   * @param  {Array<Number>} observation Observation vector\n   * @return {Number}                    `ct` (inverse likelihood)\n   */\n  initializeForwardAlgorithm(observation) {\n    let normConst = 0;\n    if (this.params.transitionMode === 'ergodic') {\n      for (let i = 0; i < this.params.states; i += 1) {\n        this.alpha[i] = this.params.prior[i] *\n          this.params.xStates[i].likelihood(observation);\n        normConst += this.alpha[i];\n      }\n    } else {\n      this.alpha = new Array(this.params.states).fill(0);\n      this.alpha[0] = this.params.xStates[0].likelihood(observation);\n      normConst += this.alpha[0];\n    }\n    this.forwardInitialized = true;\n    if (normConst > 0) {\n      for (let i = 0; i < this.params.states; i += 1) {\n        this.alpha[i] /= normConst;\n      }\n      return 1 / normConst;\n    }\n    for (let j = 0; j < this.params.states; j += 1) {\n      this.alpha[j] = 1 / this.params.states;\n    }\n    return 1;\n  },\n\n  /**\n   * Update the forward algorithm (See rabiner, 1989)\n   * @param  {Array<Number>} observation Observation vector\n   * @return {Number}                    `ct` (inverse likelihood)\n   */\n  updateForwardAlgorithm(observation) {\n    let normConst = 0;\n    this.previousAlpha = this.alpha.slice();\n    for (let j = 0; j < this.params.states; j += 1) {\n      this.alpha[j] = 0;\n      if (this.params.transitionMode === 'ergodic') {\n        for (let i = 0; i < this.params.states; i += 1) {\n          this.alpha[j] += this.previousAlpha[i] *\n            this.params.transition[i][j];\n        }\n      } else {\n        this.alpha[j] += this.previousAlpha[j] * this.params.transition[j * 2];\n        if (j > 0) {\n          this.alpha[j] += this.previousAlpha[j - 1] *\n            this.params.transition[((j - 1) * 2) + 1];\n        } else {\n          this.alpha[0] += this.previousAlpha[this.params.states - 1] *\n            this.params.transition[(this.params.states * 2) - 1];\n        }\n      }\n      this.alpha[j] *= this.params.xStates[j].likelihood(observation);\n      normConst += this.alpha[j];\n    }\n    if (normConst > 1e-300) {\n      for (let j = 0; j < this.params.states; j += 1) {\n        this.alpha[j] /= normConst;\n      }\n      return 1 / normConst;\n    }\n    return 0;\n  },\n};\n\n/**\n * Add basic HMM capabilities to a single-class model. This enables the\n * computation of the likelihoods and regression operations common to\n * training and prediction\n *\n * @see withHMMTraining\n * @see withHMMPrediction\n *\n * @param  {ModelBase} o Source Model\n * @return {HMMBaseModel}\n *\n * @throws {Error} is o is not a ModelBase\n */\nexport default function withHMMBase(o) {\n  if (!isBaseModel(o)) {\n    throw new Error('The base object must include a standard set of parameters (`params` key), @see `ModelBase`.');\n  }\n  return Object.assign(o, hmmBasePrototype);\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/hmm/hmm_base_mixin.js","import TrainingSet from '../training_set';\nimport ModelBase from '../core/model_base_mixin';\nimport withGMMBase from '../gmm/gmm_base_mixin';\nimport { trainGMM } from '../gmm';\n\nconst TRANSITION_REGULARIZATION = 1e-5;\n\n/**\n * HMM Training Prototype\n * @type {Object}\n * @ignore\n */\nconst hmmTrainerPrototype = /** @lends withHMMTraining */ {\n  /**\n   * Initialize the EM Training process\n   * @param  {TrainingSet} trainingSet Training set\n   */\n  initTraining(trainingSet) {\n    if (!trainingSet || trainingSet.empty()) return;\n\n    this.allocate(trainingSet);\n    this.initParametersToDefault(trainingSet.standardDeviation());\n    if (this.params.gaussians > 1) {\n      this.initMeansCovariancesWithGMMEM(trainingSet);\n    } else {\n      this.initMeansWithAllPhrases(trainingSet);\n      this.initCovariancesFullyObserved(trainingSet);\n    }\n  },\n\n  /**\n   * Allocate the model's parameters and training variables\n   * @param  {TrainingSet} trainingSet The training set\n   * @private\n   */\n  allocate(trainingSet) {\n    const {\n      inputDimension,\n      outputDimension,\n      gaussians,\n      regularization,\n      covarianceMode,\n    } = this.params;\n    this.params.xStates = Array.from(\n      new Array(this.params.states),\n      () => withGMMBase(ModelBase({\n        inputDimension,\n        outputDimension,\n        gaussians,\n        regularization,\n        covarianceMode,\n      })),\n    );\n    this.params.xStates.forEach(s => s.allocate());\n    this.alpha = new Array(this.params.states).fill(0);\n    this.previousAlpha = new Array(this.params.states).fill(0);\n    this.beta = new Array(this.params.states).fill(0);\n    this.previousBeta = new Array(this.params.states).fill(0);\n\n    // Initialize Algorithm variables\n    // ---------------------------------------\n    const nbPhrases = trainingSet.size();\n    this.gammaSequence = new Array(nbPhrases).fill(null);\n    this.epsilonSequence = new Array(nbPhrases).fill(null);\n    this.gammaSequenceperMixture = new Array(nbPhrases).fill(null);\n    let maxT = 0;\n    let i = 0;\n    trainingSet.forEach((phrase) => {\n      const T = phrase.length;\n      this.gammaSequence[i] = Array.from(\n        new Array(T),\n        () => new Array(this.params.states).fill(0),\n      );\n      if (this.params.transitionMode === 'ergodic') {\n        this.epsilonSequence[i] = Array.from(\n          new Array(T),\n          () => Array.from(\n            new Array(this.params.states),\n            () => new Array(this.params.states).fill(0),\n          ),\n        );\n      } else {\n        this.epsilonSequence[i] = Array.from(\n          new Array(T),\n          () => new Array(this.params.states * 2).fill(0),\n        );\n      }\n      this.gammaSequenceperMixture[i] =\n        new Array(this.params.gaussians).fill(0);\n      for (let c = 0; c < this.params.gaussians; c += 1) {\n        this.gammaSequenceperMixture[i][c] =\n          Array.from(\n            new Array(T),\n            () => new Array(this.params.states).fill(0),\n          );\n      }\n      if (T > maxT) {\n        maxT = T;\n      }\n      i += 1;\n    });\n\n    this.gammaSum = new Array(this.params.states).fill(0);\n    this.gammaSumPerMixture = new Array(this.params.states * this.params.gaussians).fill(0);\n  },\n\n  /**\n   * Update the EM Training process (1 EM iteration).\n   * @param  TrainingSet trainingSet training set\n   */\n  updateTraining(trainingSet) {\n    let logProb = 0;\n\n    // Forward-backward for each phrase\n    // =================================================\n    let phraseIndex = 0;\n    trainingSet.forEach((phrase) => {\n      if (phrase.length > 0) {\n        logProb += this.baumWelchForwardBackward(phrase, phraseIndex);\n      }\n      phraseIndex += 1;\n    });\n    this.baumWelchGammaSum(trainingSet);\n\n    // Re-estimate model parameters\n    // =================================================\n\n    // set covariance and mixture coefficients to zero for each state\n    for (let i = 0; i < this.params.states; i += 1) {\n      for (let c = 0; c < this.params.gaussians; c += 1) {\n        this.params.xStates[i].params.mixtureCoeffs[c] = 0;\n        if (this.params.covarianceMode === 'full') {\n          this.params.xStates[i].params.components[c].covariance =\n            new Array(this.params.dimension ** 2).fill(0);\n        } else {\n          this.params.xStates[i].params.components[c].covariance =\n            new Array(this.params.dimension).fill(0);\n        }\n      }\n    }\n\n    this.baumWelchEstimateMixtureCoefficients(trainingSet);\n    this.baumWelchEstimateMeans(trainingSet);\n    this.baumWelchEstimateCovariances(trainingSet);\n    if (this.params.transitionMode === 'ergodic') {\n      this.baumWelchEstimatePrior(trainingSet);\n    }\n    this.baumWelchEstimateTransitions(trainingSet);\n    return logProb;\n  },\n\n  /**\n   * terminate the EM Training process\n   * @param  TrainingSet trainingSet training set\n   */\n  terminateTraining() {\n    this.normalizeTransitions();\n    this.gammaSequence = null;\n    this.epsilonSequence = null;\n    this.gammaSequenceperMixture = null;\n    this.alphaSeq = null;\n    this.betaSeq = null;\n    this.gammaSum = null;\n    this.gammaSumPerMixture = null;\n    this.params.xStates = this.params.xStates.map(s => s.params);\n  },\n\n  /**\n   * Initialize the model parameters to their default values\n   * @param  {Array<Number>} dataStddev Standard deviation of the training data\n   * @private\n   */\n  initParametersToDefault(dataStddev) {\n    if (this.params.transitionMode === 'ergodic') {\n      this.setErgodic();\n    } else {\n      this.setLeftRight();\n    }\n    const currentRegularization = dataStddev.map(std => Math.max(\n      this.params.regularization.absolute,\n      this.params.regularization.relative * std,\n    ));\n    const initCovariance = (this.params.covarianceMode === 'full') ?\n      () => new Array(this.params.dimension ** 2)\n        .fill(this.params.regularization.absolute / 2) :\n      () => new Array(this.params.dimension)\n        .fill(0);\n    for (let i = 0; i < this.params.states; i += 1) {\n      // this.params.xStates[i].initParametersToDefault(dataStddev);\n      const s = this.params.xStates[i];\n      s.currentRegularization = currentRegularization;\n      for (let c = 0; c < this.params.gaussians; c += 1) {\n        s.params.components[c].covariance = initCovariance();\n        s.params.components[c].regularize(currentRegularization);\n        s.params.mixtureCoeffs[c] = 1 / this.params.gaussians;\n      }\n    }\n  },\n\n  /**\n   * Initialize the means of each state using all available phrases in the\n   * training set\n   * @param  {TrainingSet} trainingSet Training set\n   * @private\n   */\n  initMeansWithAllPhrases(trainingSet) {\n    if (!trainingSet || trainingSet.empty()) return;\n\n    for (let n = 0; n < this.params.states; n += 1) {\n      for (let d = 0; d < this.params.dimension; d += 1) {\n        this.params.xStates[n].params.components[0].mean[d] = 0.0;\n      }\n    }\n\n    const factor = new Array(this.params.states).fill(0);\n    trainingSet.forEach((phrase) => {\n      const step = Math.floor(phrase.length / this.params.states);\n      let offset = 0;\n      for (let n = 0; n < this.params.states; n += 1) {\n        for (let t = 0; t < step; t += 1) {\n          for (let d = 0; d < this.params.dimension; d += 1) {\n            this.params.xStates[n].params.components[0].mean[d] +=\n              phrase.get(offset + t, d);\n          }\n        }\n        offset += step;\n        factor[n] += step;\n      }\n    });\n    for (let n = 0; n < this.params.states; n += 1) {\n      for (let d = 0; d < this.params.dimension; d += 1) {\n        this.params.xStates[n].params.components[0].mean[d] /= factor[n];\n      }\n    }\n  },\n\n  /**\n   * Initialize the covariance by direct (fully-observed) estimation from the\n   * training data.\n   * @param  {[type]} trainingSet [description]\n   * @private\n   */\n  initCovariancesFullyObserved(trainingSet) {\n    if (!trainingSet || trainingSet.empty()) return;\n\n    for (let n = 0; n < this.params.states; n += 1) {\n      this.params.xStates[n].params.components[0].covariance =\n        new Array(this.params.dimension ** (this.params.covarianceMode === 'full' ? 2 : 1)).fill(0);\n    }\n\n    const factor = new Array(this.params.states).fill(0);\n    const othermeans = new Array(this.params.states * this.params.dimension)\n      .fill(0);\n    trainingSet.forEach((phrase) => {\n      const step = Math.floor(phrase.length / this.params.states);\n      let offset = 0;\n      for (let n = 0; n < this.params.states; n += 1) {\n        for (let t = 0; t < step; t += 1) {\n          for (let d1 = 0; d1 < this.params.dimension; d1 += 1) {\n            othermeans[((n * this.params.dimension)) + d1] +=\n                phrase.get(offset + t, d1);\n            if (this.params.covarianceMode === 'full') {\n              for (let d2 = 0; d2 < this.params.dimension; d2 += 1) {\n                this.params.xStates[n].params.components[0]\n                  .covariance[(d1 * this.params.dimension) + d2] +=\n                    phrase.get(offset + t, d1) *\n                    phrase.get(offset + t, d2);\n              }\n            } else {\n              this.params.xStates[n].params.components[0].covariance[d1] +=\n                phrase.get(offset + t, d1) ** 2;\n            }\n          }\n        }\n        offset += step;\n        factor[n] += step;\n      }\n    });\n\n    for (let n = 0; n < this.params.states; n += 1) {\n      for (let d1 = 0; d1 < this.params.dimension; d1 += 1) {\n        othermeans[(n * this.params.dimension) + d1] /= factor[n];\n        if (this.params.covarianceMode === 'full') {\n          for (let d2 = 0; d2 < this.params.dimension; d2 += 1) {\n            this.params.xStates[n].params.components[0]\n              .covariance[(d1 * this.params.dimension) + d2] /=\n                factor[n];\n          }\n        } else {\n          this.params.xStates[n].params.components[0].covariance[d1] /= factor[n];\n        }\n      }\n    }\n\n    for (let n = 0; n < this.params.states; n += 1) {\n      for (let d1 = 0; d1 < this.params.dimension; d1 += 1) {\n        if (this.params.covarianceMode === 'full') {\n          for (let d2 = 0; d2 < this.params.dimension; d2 += 1) {\n            this.params.xStates[n].params.components[0]\n              .covariance[(d1 * this.params.dimension) + d2] -=\n                othermeans[(n * this.params.dimension) + d1] *\n                othermeans[(n * this.params.dimension) + d2];\n          }\n        } else {\n          this.params.xStates[n].params.components[0].covariance[d1] -=\n            othermeans[(n * this.params.dimension) + d1] *\n            othermeans[(n * this.params.dimension) + d1];\n        }\n      }\n      this.params.xStates[n].regularize();\n      this.params.xStates[n].updateInverseCovariances();\n    }\n  },\n\n  /**\n   * Initialize the means and covariance of each state's observation probability\n   * distribution using the Expectation-Maximization algorithm for GMMs\n   * @param  {[type]} trainingSet [description]\n   * @private\n   */\n  initMeansCovariancesWithGMMEM(trainingSet) {\n    for (let n = 0; n < this.params.states; n += 1) {\n      const ts = TrainingSet(this.params);\n      // eslint-disable-next-line no-loop-func\n      trainingSet.forEach((phrase, phraseIndex) => {\n        const step = Math.floor(phrase.length / this.params.states);\n        if (step > 0) {\n          ts.push(phraseIndex, phrase.label);\n          for (let t = n * step; t < (n + 1) * step; t += 1) {\n            ts.getPhrase(phraseIndex).push(phrase.getFrame(t));\n          }\n        }\n      });\n      if (!ts.empty()) {\n        const gmmParams = trainGMM(ts, this.params);\n        for (let c = 0; c < this.params.gaussians; c += 1) {\n          this.params.xStates[n].params.components[c].mean =\n            gmmParams.components[c].mean;\n          this.params.xStates[n].params.components[c].covariance =\n            gmmParams.components[c].covariance;\n          this.params.xStates[n].updateInverseCovariances();\n        }\n      }\n    }\n  },\n\n  /**\n   * Initialize the transition matrix to an ergodic transition matrix\n   * @private\n   */\n  setErgodic() {\n    const p = 1 / this.params.states;\n    this.params.prior = new Array(this.params.states).fill(p);\n    this.params.transition = Array.from(\n      new Array(this.params.states),\n      () => new Array(this.params.states).fill(p),\n    );\n  },\n\n  /**\n   * Initialize the transition matrix to a left-right transition matrix\n   * @private\n   */\n  setLeftRight() {\n    this.params.prior = new Array(this.params.states).fill(0);\n    this.params.prior[0] = 1;\n    this.params.transition = new Array(this.params.states * 2).fill(0.5);\n    this.params.transition[(this.params.states - 1) * 2] = 1;\n    this.params.transition[((this.params.states - 1) * 2) + 1] = 0;\n  },\n\n  /**\n   * Normalize the hidden state transition parameters\n   * (prior + transition matrix)\n   * @private\n   */\n  normalizeTransitions() {\n    if (this.params.transitionMode === 'ergodic') {\n      const normPrior = this.params.prior.reduce((a, b) => a + b, 0);\n      for (let i = 0; i < this.params.states; i += 1) {\n        this.params.prior[i] /= normPrior;\n        let transitionNorm = 0;\n        for (let j = 0; j < this.params.states; j += 1) {\n          transitionNorm += this.params.transition[i][j];\n        }\n        for (let j = 0; j < this.params.states; j += 1) {\n          this.params.transition[i][j] /= transitionNorm;\n        }\n      }\n    } else {\n      for (let i = 0; i < this.params.states; i += 1) {\n        const transitionNorm = this.params.transition[i * 2] + this.params.transition[(i * 2) + 1];\n        this.params.transition[i * 2] /= transitionNorm;\n        this.params.transition[(i * 2) + 1] /= transitionNorm;\n      }\n    }\n  },\n\n  /**\n   * Initialize the backward algorithm (see rabiner, 1989)\n   * @param  {Number} ct Inverse probability at time T - 1 (last observation of\n   * the sequence)\n   * @private\n   */\n  initializeBackwardAlgorithm(ct) {\n    for (let i = 0; i < this.params.states; i += 1) {\n      this.beta[i] = ct;\n    }\n  },\n\n  /**\n   * Initialize the backward algorithm (see rabiner, 1989)\n   * @param  {Number} ct Inverse probability at time t\n   * @param  {Array<Number>} observation Observation vector\n   * @private\n   */\n  updateBackwardAlgorithm(ct, observation) {\n    this.previousBeta = this.beta.slice();\n    for (let i = 0; i < this.params.states; i += 1) {\n      this.beta[i] = 0;\n      if (this.params.transitionMode === 'ergodic') {\n        for (let j = 0; j < this.params.states; j += 1) {\n          this.beta[i] += this.params.transition[i][j] *\n            this.previousBeta[j] *\n            this.params.xStates[j].likelihood(observation);\n        }\n      } else {\n        this.beta[i] += this.params.transition[i * 2] *\n          this.previousBeta[i] *\n          this.params.xStates[i].likelihood(observation);\n        if (i < this.params.states - 1) {\n          this.beta[i] += this.params.transition[(i * 2) + 1] *\n            this.previousBeta[i + 1] *\n            this.params.xStates[i + 1].likelihood(observation);\n        }\n      }\n      this.beta[i] *= ct;\n      if (Number.isNaN(this.beta[i]) || Math.abs(this.beta[i]) === +Infinity) {\n        this.beta[i] = 1e100;\n      }\n    }\n  },\n\n  /**\n   * Forward algorithm update step for the Baum-Welch algorithms. It is similar\n   * to `updateForwardAlgorithm` except it takes precomputed observation\n   * likelihoods as argument.\n   * @param  {Array<Number>} observationLikelihoods observation likelihoods\n   * @private\n   */\n  baumWelchForwardUpdate(observationLikelihoods) {\n    let normConst = 0;\n    this.previousAlpha = this.alpha.slice();\n    for (let j = 0; j < this.params.states; j += 1) {\n      this.alpha[j] = 0;\n      if (this.params.transitionMode === 'ergodic') {\n        for (let i = 0; i < this.params.states; i += 1) {\n          this.alpha[j] += this.previousAlpha[i] *\n            this.params.transition[i][j];\n        }\n      } else {\n        this.alpha[j] += this.previousAlpha[j] * this.params.transition[j * 2];\n        if (j > 0) {\n          this.alpha[j] += this.previousAlpha[j - 1] *\n            this.params.transition[((j - 1) * 2) + 1];\n        } else {\n          this.alpha[0] += this.previousAlpha[this.params.states - 1] *\n            this.params.transition[(this.params.states * 2) - 1];\n        }\n      }\n      this.alpha[j] *= observationLikelihoods[j];\n      normConst += this.alpha[j];\n    }\n    if (Number.isNaN(normConst)) {\n      throw new Error('Holy molly');\n    }\n    if (normConst > 1e-300) {\n      for (let j = 0; j < this.params.states; j += 1) {\n        this.alpha[j] /= normConst;\n      }\n      return 1 / normConst;\n    }\n    return 0;\n  },\n\n  /**\n   * Backward algorithm update step for the Baum-Welch algorithms. It is similar\n   * to `updatebackwardAlgorithm` except it takes precomputed observation\n   * likelihoods as argument.\n   * @param  {Number} ct Inverse probability at time t\n   * @param  {Array<Number>} observationLikelihoods observation likelihoods\n   * @private\n   */\n  baumWelchBackwardUpdate(ct, observationLikelihoods) {\n    this.previousBeta = this.beta.slice();\n    for (let i = 0; i < this.params.states; i += 1) {\n      this.beta[i] = 0;\n      if (this.params.transitionMode === 'ergodic') {\n        for (let j = 0; j < this.params.states; j += 1) {\n          this.beta[i] +=\n            this.params.transition[i][j] *\n            this.previousBeta[j] *\n            observationLikelihoods[j];\n        }\n      } else {\n        this.beta[i] += this.params.transition[i * 2] *\n          this.previousBeta[i] *\n          observationLikelihoods[i];\n        if (i < this.params.states - 1) {\n          this.beta[i] += this.params.transition[(i * 2) + 1] *\n            this.previousBeta[i + 1] *\n            observationLikelihoods[i + 1];\n        }\n      }\n      this.beta[i] *= ct;\n      if (Number.isNaN(this.beta[i]) || Math.abs(this.beta[i]) === +Infinity) {\n        this.beta[i] = 1e100;\n      }\n    }\n  },\n\n  /**\n   * Forward-Backward algorithm for the Baum-Welch training algorithm\n   * @param  {Phrase} currentPhrase Current data phrase\n   * @param  {Number} phraseIndex   Current phrase index\n   * @return {Number} Log-likelihood\n   * @private\n   */\n  baumWelchForwardBackward(currentPhrase, phraseIndex) {\n    const T = currentPhrase.length;\n\n    const ct = new Array(T).fill(0);\n    let logProb;\n    this.alphaSeq = [];\n    this.betaSeq = [];\n\n    const observationProbabilities = Array.from(\n      new Array(T),\n      () => new Array(this.params.states).fill(0),\n    );\n    for (let t = 0; t < T; t += 1) {\n      for (let i = 0; i < this.params.states; i += 1) {\n        observationProbabilities[t][i] =\n          this.params.xStates[i].likelihood(currentPhrase.getFrame(t));\n      }\n    }\n\n    // Forward algorithm\n    ct[0] = this.initializeForwardAlgorithm(currentPhrase.getFrame(0));\n    logProb = -Math.log(ct[0]);\n    this.alphaSeq.push(this.alpha.slice());\n\n    for (let t = 1; t < T; t += 1) {\n      ct[t] = this.baumWelchForwardUpdate(observationProbabilities[t]);\n      logProb -= Math.log(ct[t]);\n      this.alphaSeq.push(this.alpha.slice());\n    }\n\n    // Backward algorithm\n    this.initializeBackwardAlgorithm(ct[T - 1]);\n    this.betaSeq.push(this.beta.slice());\n\n    for (let t = T - 2; t >= 0; t -= 1) {\n      this.baumWelchBackwardUpdate(ct[t], observationProbabilities[t + 1]);\n      this.betaSeq.push(this.beta.slice());\n    }\n    this.betaSeq.reverse();\n\n    // Compute Gamma Variable\n    for (let t = 0; t < T; t += 1) {\n      for (let i = 0; i < this.params.states; i += 1) {\n        this.gammaSequence[phraseIndex][t][i] =\n          (this.alphaSeq[t][i] * this.betaSeq[t][i]) / ct[t];\n      }\n    }\n\n    // Compute Gamma variable for each mixture component\n    let normConst;\n\n    for (let t = 0; t < T; t += 1) {\n      for (let i = 0; i < this.params.states; i += 1) {\n        normConst = 0;\n        if (this.params.gaussians === 1) {\n          const oo = observationProbabilities[t][i];\n          this.gammaSequenceperMixture[phraseIndex][0][t][i] =\n            this.gammaSequence[phraseIndex][t][i] * oo;\n          normConst += oo;\n        } else {\n          for (let c = 0; c < this.params.gaussians; c += 1) {\n            const oo = this.params.xStates[i]\n              .componentLikelihood(currentPhrase.getFrame(t), c);\n            this.gammaSequenceperMixture[phraseIndex][c][t][i] =\n              this.gammaSequence[phraseIndex][t][i] *\n              oo;\n            normConst += oo;\n          }\n        }\n        if (normConst > 0) {\n          for (let c = 0; c < this.params.gaussians; c += 1) {\n            this.gammaSequenceperMixture[phraseIndex][c][t][i] /= normConst;\n          }\n        }\n      }\n    }\n\n    // Compute Epsilon Variable\n    if (this.params.transitionMode === 'ergodic') {\n      for (let t = 0; t < T - 1; t += 1) {\n        for (let i = 0; i < this.params.states; i += 1) {\n          for (let j = 0; j < this.params.states; j += 1) {\n            this.epsilonSequence[phraseIndex][t][i][j] =\n              this.alphaSeq[t][i] *\n              this.params.transition[i][j] *\n              this.betaSeq[t + 1][j];\n            this.epsilonSequence[phraseIndex][t][i][j] *=\n              observationProbabilities[t + 1][j];\n          }\n        }\n      }\n    } else {\n      for (let t = 0; t < T - 1; t += 1) {\n        for (let i = 0; i < this.params.states; i += 1) {\n          this.epsilonSequence[phraseIndex][t][i * 2] =\n            this.alphaSeq[t][i] *\n            this.params.transition[i * 2] *\n            this.betaSeq[t + 1][i];\n          this.epsilonSequence[phraseIndex][t][i * 2] *=\n            observationProbabilities[t + 1][i];\n          if (i < this.params.states - 1) {\n            this.epsilonSequence[phraseIndex][t][(i * 2) + 1] =\n              this.alphaSeq[t][i] *\n              this.params.transition[(i * 2) + 1] *\n              this.betaSeq[t + 1][i + 1];\n            this.epsilonSequence[phraseIndex][t][(i * 2) + 1] *=\n              observationProbabilities[t + 1][i + 1];\n          }\n        }\n      }\n    }\n\n    return logProb;\n  },\n\n  /**\n   * Sums the Gamma variables used for parameter estimation during training\n   * @param  {TrainingSet} trainingSet Training Set\n   * @private\n   */\n  baumWelchGammaSum(trainingSet) {\n    for (let i = 0; i < this.params.states; i += 1) {\n      this.gammaSum[i] = 0;\n      for (let c = 0; c < this.params.gaussians; c += 1) {\n        this.gammaSumPerMixture[(i * this.params.gaussians) + c] = 0;\n      }\n    }\n\n    let phraseIndex = 0;\n    trainingSet.forEach((phrase) => {\n      for (let i = 0; i < this.params.states; i += 1) {\n        for (let t = 0; t < phrase.length; t += 1) {\n          this.gammaSum[i] +=\n            this.gammaSequence[phraseIndex][t][i];\n          for (let c = 0; c < this.params.gaussians; c += 1) {\n            this.gammaSumPerMixture[(i * this.params.gaussians) + c] +=\n              this.gammaSequenceperMixture[phraseIndex][c][t][i];\n          }\n        }\n      }\n      phraseIndex += 1;\n    });\n  },\n\n  /**\n   * Estimate the mixture coefficients of the GMM observation probability\n   * distribution at each state.\n   * @param  {TrainingSet} trainingSet Training Set\n   * @private\n   */\n  baumWelchEstimateMixtureCoefficients(trainingSet) {\n    let phraseIndex = 0;\n    trainingSet.forEach((phrase) => {\n      for (let i = 0; i < this.params.states; i += 1) {\n        for (let t = 0; t < phrase.length; t += 1) {\n          for (let c = 0; c < this.params.gaussians; c += 1) {\n            this.params.xStates[i].params.mixtureCoeffs[c] +=\n              this.gammaSequenceperMixture[phraseIndex][c][t][i];\n          }\n        }\n      }\n      phraseIndex += 1;\n    });\n\n    // Scale mixture coefficients\n    for (let i = 0; i < this.params.states; i += 1) {\n      this.params.xStates[i].normalizeMixtureCoeffs();\n    }\n  },\n\n  /**\n   * Estimate the means of the GMM observation probability\n   * distribution at each state.\n   * @param  {TrainingSet} trainingSet Training Set\n   * @private\n   */\n  baumWelchEstimateMeans(trainingSet) {\n    for (let i = 0; i < this.params.states; i += 1) {\n      for (let c = 0; c < this.params.gaussians; c += 1) {\n        this.params.xStates[i].params.components[c].mean.fill(0);\n      }\n    }\n\n    // Re-estimate Mean\n    let phraseIndex = 0;\n    trainingSet.forEach((phrase) => {\n      for (let i = 0; i < this.params.states; i += 1) {\n        for (let t = 0; t < phrase.length; t += 1) {\n          for (let c = 0; c < this.params.gaussians; c += 1) {\n            for (let d = 0; d < this.params.dimension; d += 1) {\n              this.params.xStates[i].params.components[c].mean[d] +=\n                this.gammaSequenceperMixture[phraseIndex][c][t][i] *\n                phrase.get(t, d);\n            }\n          }\n        }\n      }\n      phraseIndex += 1;\n    });\n\n    // Normalize mean\n    for (let i = 0; i < this.params.states; i += 1) {\n      for (let c = 0; c < this.params.gaussians; c += 1) {\n        for (let d = 0; d < this.params.dimension; d += 1) {\n          if (this.gammaSumPerMixture[(i * this.params.gaussians) + c] > 0) {\n            this.params.xStates[i].params.components[c].mean[d] /=\n              this.gammaSumPerMixture[(i * this.params.gaussians) + c];\n          }\n          if (Number.isNaN(this.params.xStates[i].params.components[c].mean[d])) {\n            throw new Error('Convergence Error');\n          }\n        }\n      }\n    }\n  },\n\n  /**\n   * Estimate the covariances of the GMM observation probability\n   * distribution at each state.\n   * @param  {TrainingSet} trainingSet Training Set\n   * @private\n   */\n  baumWelchEstimateCovariances(trainingSet) {\n    let phraseIndex = 0;\n    trainingSet.forEach((phrase) => {\n      for (let i = 0; i < this.params.states; i += 1) {\n        for (let t = 0; t < phrase.length; t += 1) {\n          for (let c = 0; c < this.params.gaussians; c += 1) {\n            for (let d1 = 0; d1 < this.params.dimension; d1 += 1) {\n              if (this.params.covarianceMode === 'full') {\n                for (let d2 = d1; d2 < this.params.dimension; d2 += 1) {\n                  this.params.xStates[i].params.components[c]\n                    .covariance[(d1 * this.params.dimension) + d2] +=\n                    this.gammaSequenceperMixture[phraseIndex][c][t][i] *\n                    (phrase.get(t, d1) -\n                      this.params.xStates[i].params.components[c].mean[d1]) *\n                    (phrase.get(t, d2) -\n                      this.params.xStates[i].params.components[c].mean[d2]);\n                }\n              } else {\n                const value = phrase.get(t, d1) -\n                  this.params.xStates[i].params.components[c].mean[d1];\n                this.params.xStates[i].params.components[c].covariance[d1] +=\n                  this.gammaSequenceperMixture[phraseIndex][c][t][i] *\n                  (value ** 2);\n              }\n            }\n          }\n        }\n      }\n      phraseIndex += 1;\n    });\n\n    // Scale covariance\n    for (let i = 0; i < this.params.states; i += 1) {\n      for (let c = 0; c < this.params.gaussians; c += 1) {\n        if (this.gammaSumPerMixture[(i * this.params.gaussians) + c] > 0) {\n          for (let d1 = 0; d1 < this.params.dimension; d1 += 1) {\n            if (this.params.covarianceMode === 'full') {\n              for (let d2 = d1; d2 < this.params.dimension; d2 += 1) {\n                this.params.xStates[i].params.components[c]\n                  .covariance[(d1 * this.params.dimension) + d2] /=\n                  this.gammaSumPerMixture[(i * this.params.gaussians) + c];\n                if (d1 !== d2) {\n                  this.params.xStates[i].params.components[c]\n                    .covariance[(d2 * this.params.dimension) + d1] =\n                    this.params.xStates[i].params.components[c]\n                      .covariance[(d1 * this.params.dimension) + d2];\n                }\n              }\n            } else {\n              this.params.xStates[i].params.components[c].covariance[d1] /=\n                this.gammaSumPerMixture[(i * this.params.gaussians) + c];\n            }\n          }\n        }\n      }\n      this.params.xStates[i].regularize();\n      this.params.xStates[i].updateInverseCovariances();\n    }\n  },\n\n  /**\n   * Estimate the prior probabilities of the model\n   * @param  {TrainingSet} trainingSet Training Set\n   * @private\n   */\n  baumWelchEstimatePrior(trainingSet) {\n    this.params.prior.fill(0);\n\n    // Re-estimate Prior probabilities\n    let sumprior = 0;\n    for (let phraseIndex = 0;\n      phraseIndex < trainingSet.size();\n      phraseIndex += 1) {\n      for (let i = 0; i < this.params.states; i += 1) {\n        this.params.prior[i] += this.gammaSequence[phraseIndex][0][i];\n        sumprior += this.params.prior[i];\n      }\n    }\n\n    // Scale Prior vector\n    if (sumprior > 0) {\n      for (let i = 0; i < this.params.states; i += 1) {\n        this.params.prior[i] /= sumprior;\n      }\n    } else {\n      throw new Error('The Prior is all ZERO.....');\n    }\n  },\n\n  /**\n   * Estimate the transition probabilities of the model\n   * @param  {TrainingSet} trainingSet Training Set\n   * @private\n   */\n  baumWelchEstimateTransitions(trainingSet) {\n    // Set transition matrix to 0\n    this.params.transition = this.params.transitionMode === 'ergodic' ?\n      Array.from(\n        new Array(this.params.states),\n        () => new Array(this.params.states).fill(0),\n      ) :\n      new Array(this.params.states * 2).fill(0);\n\n    // Re-estimate Transition probabilities\n    let phraseIndex = 0;\n    trainingSet.forEach((phrase) => {\n      if (phrase.length > 0) {\n        for (let i = 0; i < this.params.states; i += 1) {\n          // Experimental: A bit of regularization (sometimes avoids\n          // numerical errors)\n          if (this.params.transitionMode === 'leftright') {\n            this.params.transition[i * 2] += TRANSITION_REGULARIZATION;\n            if (i < this.params.states - 1) {\n              this.params.transition[(i * 2) + 1] += TRANSITION_REGULARIZATION;\n            } else {\n              this.params.transition[i * 2] += TRANSITION_REGULARIZATION;\n            }\n          }\n          // End Regularization\n          if (this.params.transitionMode === 'ergodic') {\n            for (let j = 0; j < this.params.states; j += 1) {\n              for (let t = 0; t < phrase.length - 1; t += 1) {\n                this.params.transition[i][j] +=\n                  this.epsilonSequence[phraseIndex][t][i][j];\n              }\n            }\n          } else {\n            for (let t = 0; t < phrase.length - 1; t += 1) {\n              this.params.transition[i * 2] +=\n                this.epsilonSequence[phraseIndex][t][i * 2];\n            }\n            if (i < this.params.states - 1) {\n              for (let t = 0; t < phrase.length - 1; t += 1) {\n                this.params.transition[(i * 2) + 1] +=\n                  this.epsilonSequence[phraseIndex][t][(i * 2) + 1];\n              }\n            }\n          }\n        }\n      }\n      phraseIndex += 1;\n    });\n\n    // Scale transition matrix\n    if (this.params.transitionMode === 'ergodic') {\n      for (let i = 0; i < this.params.states; i += 1) {\n        for (let j = 0; j < this.params.states; j += 1) {\n          this.params.transition[i][j] /=\n            (this.gammaSum[i] + (2 * TRANSITION_REGULARIZATION));\n          if (Number.isNaN(this.params.transition[i][j])) {\n            throw new Error('Convergence Error. Check your training data or increase the variance offset');\n          }\n        }\n      }\n    } else {\n      for (let i = 0; i < this.params.states; i += 1) {\n        this.params.transition[i * 2] /=\n          (this.gammaSum[i] + (2 * TRANSITION_REGULARIZATION));\n        if (Number.isNaN(this.params.transition[i * 2])) {\n          throw new Error('Convergence Error. Check your training data or increase the variance offset');\n        }\n        if (i < this.params.states - 1) {\n          this.params.transition[(i * 2) + 1] /=\n            (this.gammaSum[i] + (2 * TRANSITION_REGULARIZATION));\n          if (Number.isNaN(this.params.transition[(i * 2) + 1])) {\n            throw new Error('Convergence Error. Check your training data or increase the variance offset');\n          }\n        }\n      }\n    }\n  },\n};\n\n/**\n * Add HMM Training capabilities to a HMM Model\n * @param  {HMMBase} o               Source HMM Model\n * @param  {Number} [states=1]       Number of hidden states\n * @param  {Number} [gaussians=1]    Number of Gaussian components\n * @param  {Object} [regularization] Regularization parameters\n * @param  {Number} [regularization.absolute=1e-3] Absolute regularization\n * @param  {Number} [regularization.relative=1e-2] Relative Regularization\n (relative to the training set's variance along each dimension)\n * @param  {String} [transitionMode='ergodic'] Structure of the transition\n * matrix ('ergodic' or 'left-right').\n * @param  {String} [covarianceMode='full'] Covariance mode ('full' or diagonal)\n * @return {BMMBase}\n */\nexport default function withHMMTraining(\n  o,\n  states = 1,\n  gaussians = 1,\n  regularization = { absolute: 1e-3, relative: 1e-2 },\n  transitionMode = 'leftright',\n  covarianceMode = 'full',\n) {\n  if (!Object.keys(o).includes('params')) {\n    throw new Error('The base object must include a standard set of parameters (`params` key), @see `ModelBase`.');\n  }\n  return Object.assign(\n    o,\n    hmmTrainerPrototype,\n    {\n      params: {\n        ...o.params,\n        states,\n        gaussians,\n        regularization,\n        transitionMode,\n        covarianceMode,\n      },\n    },\n  );\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/hmm/hmm_training_mixin.js","import validateParameters from '../common/validation';\nimport { isBaseModel } from '../core/model_base_mixin';\nimport { GMMPredictor } from '../gmm';\n\nconst hmmParameterSpec = (states, transitionMode) => ({\n  states: {\n    required: true,\n    check: { min: 1 },\n  },\n  gaussians: {\n    required: true,\n    check: { min: 1 },\n  },\n  regularization: {\n    required: true,\n    check: ({ absolute, relative }) =>\n      (absolute && relative && absolute > 0 && relative > 0),\n  },\n  transitionMode: {\n    required: true,\n    check: ['ergodic', 'leftright'],\n  },\n  covarianceMode: {\n    required: true,\n    check: ['full', 'diagonal'],\n  },\n  prior: {\n    required: true,\n    check: m => transitionMode === 'leftright' || m.length === states,\n  },\n  transition: {\n    required: true,\n    check: m => (transitionMode === 'leftright' ?\n      m.length === 2 * states :\n      m.length === states),\n  },\n  xStates: {\n    required: true,\n    check: m => m.length === states,\n  },\n});\n\n\n/**\n * HMM Base prototype\n * @type {Object}\n * @ignore\n */\nconst hmmPredictionPrototype = /** @lends withHMMPrediction */ {\n  forwardInitialized: false,\n  isHierarchical: false,\n\n  /**\n   * Setup the Model by allocating GMM predictors to each of the hidden states\n   * @return {HMMBaseModel} the model\n   * @private\n   */\n  setup() {\n    this.params.xStates = this.params.xStates.map(s => GMMPredictor(s).reset());\n    return this;\n  },\n\n  /**\n   * Reset the prediction process\n   * @return {HMMBaseModel} the model\n   */\n  reset() {\n    this.likelihoodBuffer.clear();\n    this.params.xStates.forEach((s) => { s.reset(); });\n    return this;\n  },\n\n  /**\n   * Compute the likelihood of an observation given the HMM's parameters\n   * @param  {Array<Number>} observation Observation vector\n   * @return {Number}\n   */\n  likelihood(observation) {\n    const ct = (this.forwardInitialized) ?\n      this.updateForwardAlgorithm(observation) :\n      this.initializeForwardAlgorithm(observation);\n    this.updateAlphaWindow();\n    this.updateProgress();\n    return 1 / ct;\n  },\n\n  updateProgress() {\n    this.results.progress = 0.0;\n    for (let i = this.windowMinindex; i < this.windowMaxindex; i += 1) {\n      if (this.isHierarchical) {\n        this.results.progress += (this.alpha[i] + this.alpha1[i] + this.alpha2[i]) *\n          (i / this.windowNormalizationConstant);\n      } else {\n        this.results.progress += (this.alpha[i] * i) /\n          this.windowNormalizationConstant;\n      }\n    }\n    this.results.progress /= this.params.states - 1;\n  },\n\n  /**\n   * Update the state probabilities filtering window (for multiclass\n   * hierarchical HMM I think...)\n   * @private\n   */\n  updateAlphaWindow() {\n    this.results.likeliestState = 0;\n    // Get likeliest State\n    let bestAlpha = this.isHierarchical ?\n      (this.alpha[0] + this.alpha1[0]) :\n      this.alpha[0];\n    for (let i = 1; i < this.params.states; i += 1) {\n      if (this.isHierarchical) {\n        if ((this.alpha[i] + this.alpha1[i]) > bestAlpha) {\n          bestAlpha = this.alpha[i] + this.alpha1[i];\n          this.results.likeliestState = i;\n        }\n      } else if (this.alpha[i] > bestAlpha) {\n        bestAlpha = this.alpha[i];\n        this.results.likeliestState = i;\n      }\n    }\n\n    // Compute Window\n    this.windowMinindex = this.results.likeliestState - Math.floor(this.params.states / 2);\n    this.windowMaxindex = this.results.likeliestState + Math.floor(this.params.states / 2);\n    this.windowMinindex = (this.windowMinindex >= 0) ? this.windowMinindex : 0;\n    this.windowMaxindex = (this.windowMaxindex <= this.params.states) ?\n      this.windowMaxindex : this.params.states;\n    this.windowNormalizationConstant = 0.0;\n    for (let i = this.windowMinindex; i < this.windowMaxindex; i += 1) {\n      this.windowNormalizationConstant += this.isHierarchical ?\n        (this.alpha[i] + this.alpha1[i]) :\n        this.alpha[i];\n    }\n  },\n};\n\n/**\n * Bimodal (regression) HMM Prototype\n * @type {Object}\n * @ignore\n */\nconst hmmBimodalPredictionPrototype = /** @lends withHMMPrediction */ {\n  /**\n   * Estimate the output values corresponding to the input observation, by\n   * regression given the HMM's parameters. This method is called Hidden\n   * Mixture Regression (GMR).\n   *\n   * @param  {Array<Number>} inputObservation Observation on the input modality\n   * @return {Array<Number>} Output values (length = outputDimension)\n   */\n  regression(inputObservation) {\n    this.results.outputValues = Array(this.params.outputDimension).fill(0);\n    this.results.outputCovariance = Array(this.params.covarianceMode === 'full' ? this.params.outputDimension ** 2 : this.params.outputDimension).fill(0);\n\n    if (this.params.regressionEstimator === 'likeliest') {\n      this.params.xStates[this.results.likeliestState].predict(inputObservation);\n      this.results.outputValues =\n        this.params.xStates[this.results.likeliestState].results.outputValues;\n      return this.results.outputValues;\n    }\n\n    const clipMinState = (this.params.regressionEstimator === 'full') ?\n      0 : this.windowMinindex;\n    const clipMaxState = (this.params.regressionEstimator === 'full') ?\n      this.params.states : this.windowMaxindex;\n    let normalizationConstant = (this.params.regressionEstimator === 'full') ?\n      1 : this.windowNormalizationConstant;\n\n    if (normalizationConstant <= 0.0) normalizationConstant = 1;\n\n    // Compute Regression\n    for (let i = clipMinState; i < clipMaxState; i += 1) {\n      this.params.xStates[i].likelihood(inputObservation);\n      this.params.xStates[i].regression(inputObservation);\n      const tmpPredictedOutput = this.params.xStates[i].results.outputValues;\n      for (let d = 0; d < this.params.outputDimension; d += 1) {\n        if (this.isHierarchical) {\n          this.results.outputValues[d] +=\n            (this.alpha[i] + this.alpha1[i]) *\n            (tmpPredictedOutput[d] / normalizationConstant);\n          if (this.params.covarianceMode === 'full') {\n            for (let d2 = 0; d2 < this.params.outputDimension; d2 += 1) {\n              this.results.outputCovariance[(d * this.params.outputDimension) + d2] +=\n                (this.alpha[i] + this.alpha1[i]) *\n                (this.alpha[i] + this.alpha1[i]) *\n                (this.params.xStates[i].results\n                  .outputCovariance[(d * this.params.outputDimension) + d2] /\n                normalizationConstant);\n            }\n          } else {\n            this.results.outputCovariance[d] +=\n              (this.alpha[i] + this.alpha1[i]) *\n              (this.alpha[i] + this.alpha1[i]) *\n              (this.params.xStates[i].results.outputCovariance[d] /\n              normalizationConstant);\n          }\n        } else {\n          this.results.outputValues[d] += this.alpha[i] *\n            (tmpPredictedOutput[d] / normalizationConstant);\n          if (this.params.covarianceMode === 'full') {\n            for (let d2 = 0; d2 < this.params.outputDimension; d2 += 1) {\n              this.results.outputCovariance[(d * this.params.outputDimension) + d2] +=\n                (this.alpha[i] ** 2) *\n                (this.params.xStates[i].results\n                  .outputCovariance[(d * this.params.outputDimension) + d2] /\n                normalizationConstant);\n            }\n          } else {\n            this.results.outputCovariance[d] +=\n              ((this.alpha[i] ** 2) *\n              this.params.xStates[i].results.outputCovariance[d]) /\n              normalizationConstant;\n          }\n        }\n      }\n    }\n    return this.results.outputValues;\n  },\n};\n\n/**\n * Add HMM prediction capabilities to a single-class model. Mostly, this checks\n * the validity of the model parameters\n *\n * @todo validate gaussian components\n *\n * @param  {HMMBaseModel} o Source Model\n * @return {HMMBaseModel}\n *\n * @throws {Error} is o is not a ModelBase\n */\nexport default function withHMMPrediction(o) {\n  if (!isBaseModel(o)) {\n    throw new Error('The base object must include a standard set of parameters (`params` key), @see `ModelBase`.');\n  }\n  validateParameters('HMM', hmmParameterSpec(o.params.states, o.params.transitionMode), o.params);\n  return Object.assign(\n    o,\n    hmmPredictionPrototype,\n    o.params.bimodal ? hmmBimodalPredictionPrototype : {},\n    {\n      alpha: new Array(o.params.states).fill(0),\n      previous_alpha_: new Array(o.params.states).fill(0),\n    },\n  ).setup();\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/hmm/hmm_prediction_mixin.js","import { isBaseModel } from '../core/model_base_mixin';\n\nconst DEFAULT_EXITPROBABILITY_LAST_STATE = 0.1;\n\n/**\n * Hierarchical HMM Base prototype\n * @type {Object}\n * @ignore\n */\nconst hierarchicalHmmPredictionPrototype =\n/** @lends withHierarchicalHMMPrediction */\n{\n  /**\n   * Specificies if the forward algorithm has been initialized\n   * @type {Boolean}\n   * @private\n   */\n  forwardInitialized: false,\n\n  /**\n   * Setup the model (allocate transition parameters)\n   * @return {HierarchicalHMM} [description]\n   * @private\n   */\n  setup() {\n    const numClasses = this.size();\n    this.params.prior = new Array(numClasses).fill(1 / numClasses);\n    this.params.transition = Array.from(\n      new Array(numClasses),\n      () => new Array(numClasses).fill(1 / numClasses),\n    );\n    this.params.exitTransition = new Array(numClasses).fill(0.1);\n    Object.values(this.models).forEach((model) => {\n      const m = model;\n      m.isHierarchical = true;\n    });\n    this.updateExitProbabilities();\n    return this;\n  },\n\n  /**\n   * Update the exit probabilities of each sub-Markov model\n   * @param  {Array<Number>|undefined} [exitProbabilities=undefined] Vector of\n   * exit probabilities (optional)\n   * @private\n   */\n  updateExitProbabilities(exitProbabilities = undefined) {\n    const exitProb = (exitProbabilities !== undefined) ?\n      exitProbabilities :\n      new Array(this.params.states - 1).fill(0)\n        .concat([DEFAULT_EXITPROBABILITY_LAST_STATE]);\n    Object.keys(this.models).forEach((label) => {\n      this.models[label].params.exitProbabilities = exitProb.slice();\n    });\n  },\n\n  /**\n   * Reset the prediction process. This is particularly important for temporal\n   * models such as HMMs, that depends on previous observations.\n   */\n  reset() {\n    Object.values(this.models).forEach(m => m.reset());\n    this.results = {\n      labels: [],\n      instantLikelihoods: [],\n      smoothedLikelihoods: [],\n      smoothedLogLikelihoods: [],\n      smoothedNormalizedLikelihoods: [],\n      exitLikelihood: [],\n      likeliest: null,\n      classes: {},\n    };\n    if (this.params.bimodal) {\n      this.resetBimodal();\n    }\n    this.forwardInitialized = false;\n  },\n\n  /**\n   * Make a prediction from a new observation (updates the results member)\n   * @param  {Array<Number>} observation Observation vector\n   */\n  predict(observation) {\n    if (this.forwardInitialized) {\n      this.updateForwardAlgorithm(observation);\n    } else {\n      this.initializeForwardAlgorithm(observation);\n    }\n    Object.keys(this.models).sort().forEach((label) => {\n      const model = this.models[label];\n      model.updateAlphaWindow();\n      model.updateProgress();\n      model.updateResults(model.results.instantLikelihood);\n    });\n    this.updateResults();\n\n    if (this.params.bimodal) {\n      Object.values(this.models).forEach(m => m.regression(observation));\n\n      if (this.params.multiClassRegressionEstimator === 'likeliest') {\n        this.results.outputValues =\n          this.models[this.results.likeliest].results.outputValues;\n        this.results.outputCovariance =\n          this.models[this.results.likeliest].results.outputCovariance;\n      } else {\n        this.results.outputValues = new Array(this.outputDimension).fill(0);\n        this.results.outputCovariance =\n          new Array(this.params.covarianceMode === 'full' ?\n            this.outputDimension ** 2 :\n            this.outputDimension).fill(0);\n\n        let modelIndex = 0;\n        Object.values(this.models).forEach((model) => {\n          for (let d = 0; d < this.outputDimension; d += 1) {\n            this.results.outputValues[d] +=\n              this.results.smoothedNormalizedLikelihoods[modelIndex] *\n              model.second.results.outputValues[d];\n\n            if (this.params.covarianceMode === 'full') {\n              for (let d2 = 0; d2 < this.outputDimension; d2 += 1) {\n                this.results.outputCovariance[(d * this.outputDimension) + d2] +=\n                  this.results.smoothedNormalizedLikelihoods[modelIndex] *\n                  model.results.outputCovariance[(d * this.outputDimension) + d2];\n              }\n            } else {\n              this.results.outputCovariance[d] +=\n                this.results.smoothedNormalizedLikelihoods[modelIndex] *\n                model.second.results.outputCovariance[d];\n            }\n          }\n          modelIndex += 1;\n        });\n      }\n    }\n  },\n\n  /**\n   * Initialize the forward algorithm of the hierarchical HMM\n   * @param  {Array<Number>} observation Observation vector\n   * @private\n   */\n  initializeForwardAlgorithm(observation) {\n    let normConst = 0;\n    let modelIndex = 0;\n    const classes = Object.keys(this.models).sort();\n    classes.forEach((label) => {\n      const model = this.models[label];\n      const N = model.params.states;\n      model.alpha1 = new Array(N).fill(0);\n      model.alpha2 = new Array(N).fill(0);\n\n      // Compute Emission probability and initialize on the first state of\n      // the primitive\n      if (model.params.transitionMode === 'ergodic') {\n        model.results.instantLikelihood = 0;\n        for (let i = 0; i < N; i += 1) {\n          model.alpha[i] = this.params.prior[modelIndex] *\n            model.params.prior[i] *\n            model.params.xStates[i].likelihood(observation);\n          model.results.instantLikelihood += model.alpha[i];\n        }\n      } else {\n        model.alpha[0] = this.params.prior[modelIndex] *\n          model.params.xStates[0].likelihood(observation);\n        [model.results.instantLikelihood] = model.alpha;\n      }\n      normConst += model.results.instantLikelihood;\n      modelIndex += 1;\n    });\n\n    classes.forEach((label) => {\n      const model = this.models[label];\n      const N = model.params.states;\n      for (let i = 0; i < N; i += 1) {\n        model.alpha[i] /= normConst;\n      }\n    });\n\n\n    this.frontierV1 = new Array(this.size).fill(0);\n    this.frontierV2 = new Array(this.size).fill(0);\n    this.forwardInitialized = true;\n  },\n\n  /**\n   * Update the forward algorithm of the hierarchical HMM\n   * @param  {Array<Number>} observation Observation vector\n   * @private\n   */\n  updateForwardAlgorithm(observation) {\n    let normConst = 0;\n\n    // Frontier Algorithm: variables\n    let tmp = 0;\n\n    // Intermediate variables: compute the sum of probabilities of making a\n    // transition to a new primitive\n    this.frontierV1 = this.likelihoodAlpha(1);\n    this.frontierV2 = this.likelihoodAlpha(2);\n\n    // FORWARD UPDATE\n    // --------------------------------------\n    let dstModelIndex = 0;\n    const classes = Object.keys(this.models).sort();\n    classes.forEach((label) => {\n      const dstModel = this.models[label];\n      const N = dstModel.params.states;\n\n      // 1) COMPUTE FRONTIER VARIABLE\n      //    --------------------------------------\n      // frontier variable : intermediate computation variable\n      const front = new Array(N).fill(0);\n\n      if (dstModel.params.transitionMode === 'ergodic') {\n        for (let k = 0; k < N; k += 1) {\n          for (let j = 0; j < N; j += 1) {\n            front[k] += (dstModel.params.transition[j][k] /\n              (1 - dstModel.params.exitProbabilities[j]))\n              * dstModel.alpha[j];\n          }\n\n          for (\n            let srcModelIndex = 0;\n            srcModelIndex < this.size();\n            srcModelIndex += 1\n          ) {\n            front[k] += dstModel.params.prior[k] * (\n              (this.frontierV1[srcModelIndex] *\n              this.params.transition[srcModelIndex][dstModelIndex]) +\n              (this.params.prior[dstModelIndex] *\n              this.frontierV2[srcModelIndex])\n            );\n          }\n        }\n      } else {\n        // k=0: first state of the primitive\n        front[0] = dstModel.params.transition[0] * dstModel.alpha[0];\n\n        for (\n          let srcModelIndex = 0;\n          srcModelIndex < this.size();\n          srcModelIndex += 1\n        ) {\n          front[0] += (this.frontierV1[srcModelIndex] *\n            this.params.transition[srcModelIndex][dstModelIndex]) +\n            (this.params.prior[dstModelIndex] *\n              this.frontierV2[srcModelIndex]);\n        }\n\n        // k>0: rest of the primitive\n        for (let k = 1; k < N; k += 1) {\n          front[k] += (dstModel.params.transition[k * 2] /\n            (1 - dstModel.params.exitProbabilities[k])) *\n            dstModel.alpha[k];\n          front[k] += (dstModel.params.transition[((k - 1) * 2) + 1] /\n            (1 - dstModel.params.exitProbabilities[k - 1])) *\n            dstModel.alpha[k - 1];\n        }\n\n        for (let k = 0; k < N; k += 1) {\n          dstModel.alpha[k] = 0;\n          dstModel.alpha1[k] = 0;\n          dstModel.alpha2[k] = 0;\n        }\n      }\n\n      // 2) UPDATE FORWARD VARIABLE\n      //    --------------------------------------\n      dstModel.results.exitLikelihood = 0.0;\n      dstModel.results.instantLikelihood = 0.0;\n\n      // end of the primitive: handle exit states\n      for (let k = 0; k < N; k += 1) {\n        tmp = dstModel.params.xStates[k].likelihood(observation) * front[k];\n        dstModel.alpha2[k] = this.params.exitTransition[dstModelIndex] *\n          dstModel.params.exitProbabilities[k] * tmp;\n        dstModel.alpha1[k] = (1 - this.params.exitTransition[dstModelIndex]) *\n          dstModel.params.exitProbabilities[k] * tmp;\n        dstModel.alpha[k] = (1 - dstModel.params.exitProbabilities[k]) * tmp;\n\n        dstModel.results.exitLikelihood += dstModel.alpha1[k] + dstModel.alpha2[k];\n        dstModel.results.instantLikelihood += dstModel.alpha[k] +\n          dstModel.alpha1[k] + dstModel.alpha2[k];\n        normConst += tmp;\n      }\n\n      dstModel.results.exitRatio = dstModel.results.exitLikelihood /\n        dstModel.results.instantLikelihood;\n\n      dstModelIndex += 1;\n    });\n\n    classes.forEach((label) => {\n      const model = this.models[label];\n      const N = model.params.states;\n      for (let k = 0; k < N; k += 1) {\n        model.alpha[k] /= normConst;\n        model.alpha1[k] /= normConst;\n        model.alpha2[k] /= normConst;\n      }\n    });\n  },\n\n  /**\n   * Compute the likelihood of a given probability.\n   * @param  {Number} exitNum Exit level number\n   * @return {Array<Number>}\n   */\n  likelihoodAlpha(exitNum) {\n    const likelihoodVector = new Array(this.size()).fill(0);\n    if (exitNum < 0) {\n      // Likelihood over all exit states\n      let modelIndex = 0;\n      Object.keys(this.models).sort().forEach((label) => {\n        const model = this.models[label];\n        likelihoodVector[modelIndex] = 0.0;\n        for (let k = 0; k < model.params.states; k += 1) {\n          likelihoodVector[modelIndex] += model.second.alpha[k] +\n            model.second.alpha1[k] +\n            model.second.alpha2[k];\n        }\n        modelIndex += 1;\n      });\n    } else {\n      // Likelihood for exit state \"exitNum\"\n      let modelIndex = 0;\n      Object.keys(this.models).sort().forEach((label) => {\n        const model = this.models[label];\n        likelihoodVector[modelIndex] = 0;\n        let { alpha } = model;\n        if (exitNum === 1) {\n          alpha = model.alpha1;\n        }\n        if (exitNum === 2) {\n          alpha = model.alpha2;\n        }\n        for (let k = 0; k < model.params.states; k += 1) {\n          likelihoodVector[modelIndex] += alpha[k];\n        }\n        modelIndex += 1;\n      });\n    }\n    return likelihoodVector;\n  },\n};\n\n/**\n * Add Hierarchical HMM prediction capabilities to a multi-class model.\n *\n * @todo algorithmic details\n * @todo validate parameters\n * @todo validate gaussian components\n *\n * @param  {MulticlassBaseModel} o Source Model\n * @return {HierarchicalHMM}\n *\n * @extends withMulticlassPrediction\n *\n * @throws {Error} is o is not a ModelBase\n */\nexport default function withHierarchicalHMMPrediction(o) {\n  if (!isBaseModel(o)) {\n    throw new Error('The base object must include a standard set of parameters (`params` key), @see `ModelBase`.');\n  }\n  // validateParameters(\n  //   'Hierarchical HMM',\n  //   hierarchicalHmmParameterSpec(o.params.states, o.params.transitionMode),\n  //   o.params,\n  // );\n  return Object.assign(\n    o,\n    hierarchicalHmmPredictionPrototype,\n    {\n      // alpha: new Array(o.params.states).fill(0),\n      // previous_alpha_: new Array(o.params.states).fill(0),\n    },\n  ).setup();\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/hmm/hierarchical_hmm_prediction_mixin.js"],"sourceRoot":""}