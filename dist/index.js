!function(s,t){"object"==typeof exports&&"undefined"!=typeof module?t(exports):"function"==typeof define&&define.amd?define(["exports"],t):t(s.xmm={})}(this,function(s){"use strict";const t={get(s,t){if("number"!=typeof s||Math.floor(s)!==s)throw new Error("The index must be an integer");if(t>=this.dimension)throw new Error("Phrase: dimension out of bounds");if(this.bimodal){if(t<this.inputDimension){if(s>=this.inputData.length)throw new Error("Phrase: index out of bounds");return this.inputData[s][t]}if(s>=this.outputData.length)throw new Error("Phrase: index out of bounds");return this.outputData[s][t-this.inputDimension]}if(s>=this.length)throw new Error("Phrase: index out of bounds");if(!this.inputData[s])throw new Error("WTF?");return this.inputData[s][t]},getFrame(s){if(s>=this.length)throw new Error("Phrase: index out of bounds");return this.bimodal?this.inputData[s].concat(this.outputData[s]):this.inputData[s]},push(s){if(s.length!==this.dimension)throw new Error("Observation has wrong dimension");this.bimodal?(this.inputData.push(s.slice(0,this.inputDimension)),this.outputData.push(s.slice(this.inputDimension,this.dimension))):this.inputData.push(s),this.length+=1},pushInput(s){if(!this.bimodal)throw new Error("this phrase is unimodal, use `push`");if(s.length!==this.inputDimension)throw new Error("Observation has wrong dimension");this.inputData.push(s),this.trim()},pushOutput(s){if(!this.bimodal)throw new Error("this phrase is unimodal, use `push`");if(s.length!==this.outputDimension)throw new Error("Observation has wrong dimension");this.outputData.push(s),this.trim()},clear(){this.length=0,this.inputData=[],this.outputData=[]},clearInput(){this.inputData=[],this.trim()},clearOutput(){this.outputData=[],this.trim()},mean(){const s=Array(this.dimension).fill(0);for(let t=0;t<this.dimension;t+=1){for(let i=0;i<this.length;i+=1)s[t]+=this.get(i,t);s[t]/=this.length}return s},standardDeviation(){const s=Array(this.dimension).fill(0),t=this.mean();for(let i=0;i<this.dimension;i+=1){for(let a=0;a<this.length;a+=1)s[i]+=(this.get(a,i)-t[i])*(this.get(a,i)-t[i]);s[i]/=this.length,s[i]=Math.sqrt(s[i])}return s},minmax(){const s=Array.from(Array(this.dimension),()=>({min:1/0,max:-1/0}));for(let t=0;t<this.dimension;t+=1)for(let i=0;i<this.length;i+=1)s[t].min=Math.min(this.get(i,t),s[t].min),s[t].max=Math.max(this.get(i,t),s[t].max);return s},trim(){this.bimodal&&(this.length=Math.min(this.inputData.length,this.outputData.length))}};var i=Object.assign||function(s){for(var t=1;t<arguments.length;t++){var i=arguments[t];for(var a in i)Object.prototype.hasOwnProperty.call(i,a)&&(s[a]=i[a])}return s},a=function(s,t){var i={};for(var a in s)t.indexOf(a)>=0||Object.prototype.hasOwnProperty.call(s,a)&&(i[a]=s[a]);return i};const e={size(){return Object.keys(this.phrases).length},empty(){return 0===this.length},getPhrase(s){return Object.keys(this.phrases).includes(s.toString())?this.phrases[s.toString()]:null},forEach(s){Object.keys(this.phrases).forEach(t=>{s(this.phrases[t],t,this.phrases)})},push(s,i,a){const e=void 0!==a?a:function({inputDimension:s=1,outputDimension:i=0,columnNames:a=null,label:e=""}={}){const r=s+i;return Object.assign(Object.create(t),{bimodal:i>0,inputDimension:s,outputDimension:i,dimension:r,length:0,label:e,inputData:[],outputData:[],columnNames:a||Array(r).fill("")})}({inputDimension:this.inputDimension,outputDimension:this.outputDimension,columnNames:this.columnNames,label:void 0!==i?i:s.toString()});return this.phrases[s]=e,e},remove(s){delete this.phrases[s]},removeClass(s){this.phrases=Object.keys(this.phrases).filter(t=>this.phrases[t].label!==s).map(s=>({i:this.phrases[s]})).reduce((s,t)=>i({},s,t),{})},clear(){this.phrases={}},getPhrasesOfClass(s){const t=r(this);return t.phrases=Object.keys(this.phrases).filter(t=>this.phrases[t].label===s).map(s=>({[s]:this.phrases[s]})).reduce((s,t)=>i({},s,t),{}),t},labels(){return Object.keys(this.phrases).map(s=>this.phrases[s].label).reduce((s,t)=>s.includes(t)?s:s.concat([t]),[])},indices(){return Object.keys(this.phrases)},mean(){const s=Array(this.dimension).fill(0);let t=0;return Object.keys(this.phrases).forEach(i=>{for(let t=0;t<this.dimension;t+=1)for(let a=0;a<this.phrases[i].length;a+=1)s[t]+=this.phrases[i].get(a,t);t+=this.phrases[i].length}),s.map(s=>s/t)},standardDeviation(){const s=Array(this.dimension).fill(0),t=this.mean();let i=0;return Object.keys(this.phrases).forEach(a=>{for(let i=0;i<this.dimension;i+=1)for(let e=0;e<this.phrases[a].length;e+=1)s[i]+=(this.phrases[a].get(e,i)-t[i])**2;i+=this.phrases[a].length}),s.map(s=>Math.sqrt(s/i))},minmax(){const s=Array.from(Array(this.dimension),()=>({min:1/0,max:-1/0}));return Object.keys(this.phrases).forEach(t=>{for(let i=0;i<this.dimension;i+=1)for(let a=0;a<this.phrases[t].length;a+=1)s[i].min+=Math.min(s[i].min,this.phrases[t].get(a,i)),s[i].max+=Math.max(s[i].max,this.phrases[t].get(a,i))}),s}};function r({inputDimension:s=1,outputDimension:t=0,columnNames:i=null}={}){const a=s+t;return Object.assign(Object.create(e),{bimodal:t>0,inputDimension:s,outputDimension:t,dimension:a,columnNames:i||Array(a).fill(""),phrases:{}})}function n(s){let{inputDimension:t,outputDimension:e}=s;const r=a(s,["inputDimension","outputDimension"]);return delete r.bimodal,delete r.inputDimension,delete r.outputDimension,delete r.dimension,{params:i({},r,{get bimodal(){return e>0},get inputDimension(){return t},get outputDimension(){return e},get dimension(){return t+e}})}}function o(s){if(!Object.keys(s).includes("params"))return!1;return["bimodal","inputDimension","outputDimension","dimension"].map(t=>Object.keys(s.params).includes(t)).reduce((s,t)=>s&&t,!0)}function h(s,t){return Math.sqrt(s.map((s,i)=>(s-t[i])**2).reduce((s,t)=>s+t,0))}const l={train(s){if(!s||s.empty())throw new Error("The training set is empty");if(this.params.centers=Array.from(Array(this.params.clusters),()=>new Array(this.params.dimension).fill(0)),"random"===this.trainingConfig.initialization)this.initializeClustersRandom(s);else if("forgy"===this.trainingConfig.initialization)this.initializeClustersForgy(s);else{if("data"!==this.trainingConfig.initialization)throw new Error("Unknown K-Means initialization, must be `random`, `forgy` or `data`");this.initClustersWithFirstPhrase(s)}for(let t=0;t<this.trainingConfig.maxIterations;t+=1){const t=this.params.centers;this.updateCenters(t,s);let i=0,a=0;for(let s=0;s<this.params.clusters;s+=1){for(let t=0;t<this.params.clusters;t+=1)s!==t&&(i+=h(this.params.centers[s],this.params.centers[t]));a=Math.max(h(t[s],this.params.centers[s]),a)}if(i/=this.params.clusters*(this.params.clusters-1),a/=this.params.clusters,(a/=i)<this.trainingConfig.relativeDistanceThreshold)break}return this.params},initClustersWithFirstPhrase(s){const t=s.getPhrase(s.indices()[0]),i=Math.floor(t.length/this.params.clusters);let a=0;for(let s=0;s<this.params.clusters;s+=1){this.params.centers[s]=new Array(this.params.dimension).fill(0);for(let e=0;e<i;e+=1)for(let r=0;r<this.params.dimension;r+=1)this.params.centers[s][r]+=t.get(a+e,r)/i;a+=i}},initializeClustersRandom(s){const t=s.getPhrase(s.indices()[0]),i=Array.from(Array(t.length),()=>Math.floor(Math.random()*this.params.clusters)),a=i.reduce((s,t)=>{const i=s;return i[t]+=1,i},Array(this.params.clusters).fill(0));for(let s=0;s<i.length;s+=1){const a=i[s];for(let i=0;i<this.params.dimension;i+=1)this.params.centers[a][i]+=t.get(s,i)}this.params.centers.forEach((s,t)=>{this.params.centers[t]=this.params.centers[t].map(s=>s/a[t])})},initializeClustersForgy(s){const t=s.getPhrase(s.indices()[0]),i=Array.from(Array(this.params.clusters),()=>Math.floor(Math.random()*t.length));this.params.centers=i.map(s=>t.getFrame(s))},updateCenters(s,t){this.params.centers=Array.from(Array(this.params.clusters),()=>new Array(this.params.dimension).fill(0));const i=Array(this.params.clusters).fill(0);t.forEach(t=>{for(let a=0;a<t.length;a+=1){const e=t.getFrame(a);let r=h(e,s[0]),n=0;for(let t=1;t<this.params.clusters;t+=1){const i=h(e,s[t],this.params.dimension);i<r&&(n=t,r=i)}i[n]+=1;for(let s=0;s<this.params.dimension;s+=1)this.params.centers[n][s]+=t.get(a,s)}});for(let s=0;s<this.params.clusters;s+=1)if(i[s]>0)for(let t=0;t<this.params.dimension;t+=1)this.params.centers[s][t]/=i[s]}};function m(s,t,i={}){if(!o(s))throw new Error("The base object must include a standard set of parameters (`params` key), @see `ModelBase`.");const a=Object.assign({initialization:"random",relativeDistanceThreshold:.001,minIterations:5,maxIterations:100},i),e=Object.assign(s,l,{trainingConfig:a});return e.params.clusters=t,e}const p={sum(){return this.data.reduce((s,t)=>s+t,0)},transpose(){const s=u(this.ncols,this.nrows);for(let t=0;t<this.ncols;t+=1)for(let i=0;i<this.nrows;i+=1)s.data[t*this.nrows+i]=this.data[i*this.ncols+t];return s},product(s){if(this.ncols!==s.nrows)throw new Error("Wrong dimensions for matrix product");const t=u(this.nrows,s.ncols);for(let i=0;i<this.nrows;i+=1)for(let a=0;a<s.ncols;a+=1){t.data[i*s.ncols+a]=0;for(let e=0;e<this.ncols;e+=1)t.data[i*s.ncols+a]+=this.data[i*this.ncols+e]*s.data[e*s.ncols+a]}return t},pinv(){if(this.nrows===this.ncols)return this.gaussJordanInverse();const s=this.transpose();if(this.nrows>=this.ncols){const t=s.product(this),{determinant:i,matrix:a}=t.gaussJordanInverse();return{determinant:i,matrix:a.product(s)}}const t=this.product(s),{determinant:i,matrix:a}=t.gaussJordanInverse();return{determinant:i,matrix:s.product(a)}},gaussJordanInverse(){if(this.nrows!==this.ncols)throw new Error("Gauss-Jordan inversion: Cannot invert Non-square matrix");let s=1;const t=u(this.nrows,2*this.ncols),i=u(this.nrows,2*this.ncols),a=this.nrows;for(let s=0;s<a;s+=1){for(let i=0;i<a;i+=1)t.data[2*s*a+i]=this.data[s*a+i];t.data[2*s*a+a+s]=1}for(let e=0;e<a;e+=1){let r=e;for(;Math.abs(t.data[2*r*a+e])<1e-9;)if((r+=1)===a)throw new Error("Non-invertible matrix");s*=t.data[2*r*a+e],r!==e&&t.swapLines(r,e),i.data=t.data.slice();for(let s=0;s<2*a;s+=1)i.data[2*e*a+s]/=t.data[2*e*a+e];for(let s=0;s<a;s+=1)if(s!==e)for(let r=0;r<2*a;r+=1)i.data[2*s*a+r]-=t.data[2*s*a+e]*i.data[2*e*a+r];t.data=i.data.slice()}const e=u(this.nrows,this.ncols);for(let s=0;s<a;s+=1)for(let i=0;i<a;i+=1)e.data[s*a+i]=t.data[2*s*a+a+i];return{determinant:s,matrix:e}},swapLines(s,t){for(let i=0;i<this.ncols;i+=1){const a=this.data[s*this.ncols+i];this.data[s*this.ncols+i]=this.data[t*this.ncols+i],this.data[t*this.ncols+i]=a}},swapColumns(s,t){for(let i=0;i<this.nrows;i+=1){const a=this.data[i*this.ncols+s];this.data[i*this.ncols+s]=this.data[i*this.ncols+t],this.data[i*this.ncols+t]=a}}};function u(s=0,t=-1){const i=t<0?s:t;return Object.assign(Object.create(p),{nrows:s,ncols:i,data:Array(s*i).fill(0)})}const c={allocate(){this.mean=new Array(this.dimension).fill(0),"full"===this.covarianceMode?(this.covariance=new Array(this.dimension**2).fill(0),this.inverseCovariance=new Array(this.dimension**2).fill(0)):(this.covariance=new Array(this.dimension).fill(0),this.inverseCovariance=new Array(this.dimension).fill(0)),this.bimodal&&this.allocateBimodal()},likelihood(s){if(0===this.covarianceDeterminant)throw new Error("Covariance Matrix is not invertible");if(this.bimodal&&s.length===this.inputDimension)return this.inputLikelihood(s);if(s.length!==this.dimension)throw new Error(`GaussianDistribution: observation has wrong dimension. Expected \`${this.dimension}\`, got \`${s.length}\``);let t=0;if("full"===this.covarianceMode)for(let i=0;i<this.dimension;i+=1){let a=0;for(let t=0;t<this.dimension;t+=1)a+=this.inverseCovariance[i*this.dimension+t]*(s[t]-this.mean[t]);t+=(s[i]-this.mean[i])*a}else for(let i=0;i<this.dimension;i+=1)t+=this.inverseCovariance[i]*(s[i]-this.mean[i])*(s[i]-this.mean[i]);let i=Math.exp(-.5*t)/Math.sqrt(this.covarianceDeterminant*(2*Math.PI)**this.dimension);return(i<1e-180||Number.isNaN(i)||Math.abs(i)===1/0)&&(i=1e-180),i},regularize(s){if("full"===this.covarianceMode)for(let t=0;t<this.dimension;t+=1)this.covariance[t*this.dimension+t]+=s[t];else for(let t=0;t<this.dimension;t+=1)this.covariance[t]+=s[t]},updateInverseCovariance(){if("full"===this.covarianceMode){const s=u(this.dimension,this.dimension);s.data=this.covariance.slice();const t=s.pinv();this.covarianceDeterminant=t.determinant,this.inverseCovariance=t.matrix.data}else{this.covarianceDeterminant=1;for(let s=0;s<this.dimension;s+=1){if(this.covariance[s]<=0)throw new Error("Non-invertible matrix");this.inverseCovariance[s]=1/this.covariance[s],this.covarianceDeterminant*=this.covariance[s]}}this.bimodal&&this.updateInverseCovarianceBimodal()},toEllipse(s,t){if(s>=this.dimension||t>=this.dimension)throw new Error("dimensions out of range");const i={x:0,y:0,width:0,height:0,angle:0};let a,e,r;i.x=this.mean[s],i.y=this.mean[t],"full"===this.covarianceMode?(a=this.covariance[s*this.dimension+s],e=this.covariance[s*this.dimension+t],r=this.covariance[t*this.dimension+t]):(a=this.covariance[s],e=0,r=this.covariance[t]);const n=a+r,o=a*r-e*e,h=.5*(n+Math.sqrt(n**2-4*o)),l=.5*(n-Math.sqrt(n**2-4*o));return i.width=Math.sqrt(5.991*h),i.height=Math.sqrt(5.991*l),i.angle=Math.atan(e/(h-r)),Number.isNaN(i.angle)&&(i.angle=Math.PI/2),i},fromEllipse(s,t,i){if(t>=this.dimension||i>=this.dimension)throw new Error("dimensions out of range");this.mean[t]=s.x,this.mean[i]=s.y;const a=s.width*s.width/5.991,e=s.height*s.height/5.991,r=Math.tan(s.angle),n=(a-e)*r/(r**2+1),o=a-n/r,h=e+n/r;"full"===this.covarianceMode?(this.covariance[t*this.dimension+t]=h,this.covariance[t*this.dimension+i]=n,this.covariance[i*this.dimension+t]=n,this.covariance[i*this.dimension+i]=o):(this.covariance[t]=h,this.covariance[i]=o),this.updateInverseCovariance()}},d={allocateBimodal(){"full"===this.covarianceMode?this.inverseCovarianceInput=new Array(this.inputDimension**2).fill(0):this.inverseCovarianceInput=new Array(this.inputDimension).fill(0)},inputLikelihood(s){if(0===this.covarianceDeterminantInput)throw new Error("Covariance Matrix of input modality is not invertible");let t=0;if("full"===this.covarianceMode)for(let i=0;i<this.inputDimension;i+=1){let a=0;for(let t=0;t<this.inputDimension;t+=1)a+=this.inverseCovarianceInput[i*this.inputDimension+t]*(s[t]-this.mean[t]);t+=(s[i]-this.mean[i])*a}else for(let i=0;i<this.inputDimension;i+=1)t+=this.inverseCovariance[i]*(s[i]-this.mean[i])*(s[i]-this.mean[i]);let i=Math.exp(-.5*t)/Math.sqrt(this.covarianceDeterminantInput*(2*Math.PI)**this.inputDimension);return(i<1e-180||Number.isNaN(i)||Math.abs(i)===1/0)&&(i=1e-180),i},regression(s){const t=this.dimension-this.inputDimension,i=Array(t).fill(0);if("full"===this.covarianceMode)for(let a=0;a<t;a+=1){i[a]=this.mean[this.inputDimension+a];for(let t=0;t<this.inputDimension;t+=1){let e=0;for(let i=0;i<this.inputDimension;i+=1)e+=this.inverseCovarianceInput[t*this.inputDimension+i]*(s[i]-this.mean[i]);i[a]+=e*this.covariance[(a+this.inputDimension)*this.dimension+t]}}else for(let s=0;s<t;s+=1)i[s]=this.mean[this.inputDimension+s];return i},updateInverseCovarianceBimodal(){if("full"===this.covarianceMode){const s=u(this.inputDimension,this.inputDimension);for(let t=0;t<this.inputDimension;t+=1)for(let i=0;i<this.inputDimension;i+=1)s.data[t*this.inputDimension+i]=this.covariance[t*this.dimension+i];const t=s.pinv();this.covarianceDeterminantInput=t.determinant,this.inverseCovarianceInput=t.matrix.data}else{this.covarianceDeterminantInput=1;for(let s=0;s<this.inputDimension;s+=1){if(this.covariance[s]<=0)throw new Error("Non-invertible matrix");this.inverseCovarianceInput[s]=1/this.covariance[s],this.covarianceDeterminantInput*=this.covariance[s]}}this.updateOutputCovariance()},updateOutputCovariance(){if("diagonal"===this.covarianceMode)return void(this.outputCovariance=this.covariance.slice(0,this.inputDimension));const s=u(this.inputDimension,this.inputDimension);for(let t=0;t<this.inputDimension;t+=1)for(let i=0;i<this.inputDimension;i+=1)s.data[t*this.inputDimension+i]=this.covariance[t*this.dimension+i];const t=s.pinv(),i=u(this.inputDimension,this.outputDimension);for(let s=0;s<this.inputDimension;s+=1)for(let t=0;t<this.outputDimension;t+=1)i.data[s*this.outputDimension+t]=this.covariance[s*this.dimension+this.inputDimension+t];const a=u(this.outputDimension,this.inputDimension);for(let s=0;s<this.outputDimension;s+=1)for(let t=0;t<this.inputDimension;t+=1)a.data[s*this.inputDimension+t]=this.covariance[(this.inputDimension+s)*this.dimension+t];const e=t.matrix.product(i),r=a.product(e);this.outputCovariance=Array(this.outputDimension**2).fill(0);for(let s=0;s<this.outputDimension;s+=1)for(let t=0;t<this.outputDimension;t+=1)this.outputCovariance[s*this.outputDimension+t]=this.covariance[(this.inputDimension+s)*this.dimension+this.inputDimension+t]-r.data[s*this.outputDimension+t]}};function f(s=1,t=0,i="full"){const a=t>0,e=s+t,r=a?Object.assign({},c,d):c,n=Object.assign({bimodal:a,dimension:e,inputDimension:s,outputDimension:t,covarianceMode:i,covarianceDeterminant:0},a?{covarianceDeterminantInput:0}:{}),o=Object.assign(Object.create(r),n);return o.allocate(),o}const g={train(s){if(!s||s.empty())throw new Error("The training set is empty");this.initTraining(s);let t=-1/0,i=0,a=t;for(;!this.converged(i,t,a);){a=t,t=this.updateTraining(s);const e=100*Math.abs((t-a)/a);if(Number.isNaN(e)&&i>1)throw new Error("An error occured during training");i+=1}return this.terminateTraining(),this.params},converged(s,t,i){if(s>=this.convergenceCriteria.maxIterations)return!0;if(this.convergenceCriteria.maxIterations>=this.convergenceCriteria.minIterations)return s>=this.convergenceCriteria.maxIterations;if(s<this.convergenceCriteria.minIterations)return!1;return 100*Math.abs((t-i)/t)<=this.convergenceCriteria.percentChange}};function v(s,t={percentChange:.001,minIterations:5,maxIterations:100}){return Object.assign(s,g,{convergenceCriteria:t})}const w={allocate(){this.params.components=Array.from(Array(this.params.gaussians),()=>new f(this.params.inputDimension,this.params.outputDimension,this.params.covarianceMode)),this.params.mixtureCoeffs=Array(this.params.gaussians).fill(0),this.beta=new Array(this.params.gaussians).fill(0)},likelihood(s){let t=0;for(let i=0;i<this.params.gaussians;i+=1)this.beta[i]=this.componentLikelihood(s,i),t+=this.beta[i];for(let s=0;s<this.params.gaussians;s+=1)this.beta[s]/=t;return t},componentLikelihood(s,t){if(t>=this.params.gaussians)throw new Error("The index of the Gaussian Mixture Component is out of bounds");return this.params.mixtureCoeffs[t]*this.params.components[t].likelihood(s)},updateInverseCovariances(){this.params.components.forEach(s=>{s.updateInverseCovariance()});try{this.params.components.forEach(s=>{s.updateInverseCovariance()})}catch(s){throw new Error("Matrix inversion error: varianceoffset must be too small")}},normalizeMixtureCoeffs(){let s=0;for(let t=0;t<this.params.gaussians;t+=1)s+=this.params.mixtureCoeffs[t];if(s>0)for(let t=0;t<this.params.gaussians;t+=1)this.params.mixtureCoeffs[t]/=s;else for(let s=0;s<this.params.gaussians;s+=1)this.params.mixtureCoeffs[s]=1/this.params.gaussians},regularize(){this.params.components.forEach(s=>{s.regularize(this.currentRegularization)})}},b={regression(s){let t;this.results.outputValues=Array(this.params.outputDimension).fill(0),this.results.outputCovariance=Array("full"===this.params.covarianceMode?this.params.outputDimension**2:this.params.outputDimension).fill(0);for(let i=0;i<this.params.gaussians;i+=1){t=this.params.components[i].regression(s);for(let s=0;s<this.params.outputDimension;s+=1)if(this.results.outputValues[s]+=this.beta[i]*t[s],"full"===this.params.covarianceMode)for(let t=0;t<this.params.outputDimension;t+=1)this.results.outputCovariance[s*this.params.outputDimension+t]+=this.beta[i]**2*this.params.components[i].outputCovariance[s*this.params.outputDimension+t];else this.results.outputCovariance[s]+=this.beta[i]**2*this.params.components[i].outputCovariance[s]}return this.results.outputValues}};function x(s){if(!o(s))throw new Error("The base object must include a standard set of parameters (`params` key), @see `ModelBase`.");return Object.assign(s,w,s.params.bimodal?b:{})}const M={initTraining(s){this.allocate(),this.initParametersToDefault(s.standardDeviation()),this.initMeansWithKMeans(s),this.initCovariances(s),this.regularize(),this.updateInverseCovariances()},initParametersToDefault(s){let t=0;this.currentRegularization=s.map(s=>Math.max(this.params.regularization.absolute,this.params.regularization.relative*s));for(let s=0;s<this.params.gaussians;s+=1)"full"===this.params.covarianceMode?this.params.components[s].covariance=Array(this.params.dimension**2).fill(this.params.regularization.absolute/2):this.params.components[s].covariance=Array(this.params.dimension).fill(0),this.params.components[s].regularize(this.currentRegularization),this.params.mixtureCoeffs[s]=1/this.params.gaussians,t+=this.params.mixtureCoeffs[s];for(let s=0;s<this.params.gaussians;s+=1)this.params.mixtureCoeffs[s]/=t},initMeansWithKMeans(s){if(!s||s.empty())return;const t=m(n({inputDimension:this.params.inputDimension,outputDimension:this.params.outputDimension}),this.params.gaussians,{initialization:"data"}).train(s);for(let s=0;s<this.params.gaussians;s+=1)this.params.components[s].mean=t.centers[s]},initCovariances(s){if(!s||s.empty())return;for(let s=0;s<this.params.gaussians;s+=1)this.params.components[s].covariance=Array("full"===this.params.covarianceMode?this.params.dimension**2:this.params.dimension).fill(0);const t=Array(this.params.gaussians*this.params.dimension).fill(0),i=Array(this.params.gaussians).fill(0);s.forEach(s=>{const a=Math.floor(s.length/this.params.gaussians);let e=0;for(let r=0;r<this.params.gaussians;r+=1){for(let i=0;i<a;i+=1)for(let a=0;a<this.params.dimension;a+=1)if(t[r*this.params.dimension+a]+=s.get(e+i,a),"full"===this.params.covarianceMode)for(let t=0;t<this.params.dimension;t+=1)this.params.components[r].covariance[a*this.params.dimension+t]+=s.get(e+i,a)*s.get(e+i,t);else this.params.components[r].covariance[a]+=s.get(e+i,a)**2;e+=a,i[r]+=a}});for(let s=0;s<this.params.gaussians;s+=1)for(let a=0;a<this.params.dimension;a+=1)if(t[s*this.params.dimension+a]/=i[s],"full"===this.params.covarianceMode)for(let t=0;t<this.params.dimension;t+=1)this.params.components[s].covariance[a*this.params.dimension+t]/=i[s];else this.params.components[s].covariance[a]/=i[s];for(let s=0;s<this.params.gaussians;s+=1)for(let i=0;i<this.params.dimension;i+=1)if("full"===this.params.covarianceMode)for(let a=0;a<this.params.dimension;a+=1)this.params.components[s].covariance[i*this.params.dimension+a]-=t[s*this.params.dimension+i]*t[s*this.params.dimension+a];else this.params.components[s].covariance[i]-=t[s*this.params.dimension+i]**2},updateTraining(s){let t=0,i=0;s.forEach(s=>{i+=s.length});const a=Object.keys(s.phrases),e=Array.from(Array(this.params.gaussians),()=>new Array(i).fill(0)),r=Array(this.params.gaussians).fill(0);let n=0;s.forEach(s=>{for(let i=0;i<s.length;i+=1){let a=0;for(let t=0;t<this.params.gaussians;t+=1)e[t][n+i]=this.componentLikelihood(s.getFrame(i),t),(0===e[t][n+i]||Number.isNaN(e[t][n+i])||e[t][n+i]===1/0)&&(e[t][n+i]=1e-100),a+=e[t][n+i];for(let s=0;s<this.params.gaussians;s+=1)e[s][n+i]/=a,r[s]+=e[s][n+i];t+=Math.log(a)}n+=s.length});for(let s=0;s<this.params.gaussians;s+=1)this.params.mixtureCoeffs[s]=r[s]/i;for(let t=0;t<this.params.gaussians;t+=1)for(let i=0;i<this.params.dimension;i+=1){this.params.components[t].mean[i]=0,n=0;for(let r=0;r<a.length;r+=1){const o=s.phrases[a[r]];for(let s=0;s<o.length;s+=1)this.params.components[t].mean[i]+=e[t][n+s]*o.get(s,i);n+=o.length}this.params.components[t].mean[i]/=r[t]}if("full"===this.params.covarianceMode)for(let t=0;t<this.params.gaussians;t+=1)for(let i=0;i<this.params.dimension;i+=1)for(let o=i;o<this.params.dimension;o+=1){this.params.components[t].covariance[i*this.params.dimension+o]=0,n=0;for(let r=0;r<a.length;r+=1){const h=s.phrases[a[r]];for(let s=0;s<h.length;s+=1)this.params.components[t].covariance[i*this.params.dimension+o]+=e[t][n+s]*(h.get(s,i)-this.params.components[t].mean[i])*(h.get(s,o)-this.params.components[t].mean[o]);n+=h.length}this.params.components[t].covariance[i*this.params.dimension+o]/=r[t],i!==o&&(this.params.components[t].covariance[o*this.params.dimension+i]=this.params.components[t].covariance[i*this.params.dimension+o])}else for(let t=0;t<this.params.gaussians;t+=1)for(let i=0;i<this.params.dimension;i+=1){this.params.components[t].covariance[i]=0,n=0;for(let r=0;r<a.length;r+=1){const o=s.phrases[a[r]];for(let s=0;s<o.length;s+=1){const a=o.get(s,i)-this.params.components[t].mean[i];this.params.components[t].covariance[i]+=e[t][n+s]*a*a}n+=o.length}this.params.components[t].covariance[i]/=r[t]}return this.regularize(),this.updateInverseCovariances(),t},terminateTraining(){}};const y={size(){return Object.keys(this.models).length},includes(s){return Object.keys(this.models).includes(s)},remove(s){this.includes(s)&&delete this.models[s]}};function D(s){let{inputDimension:t,outputDimension:e}=s,r=a(s,["inputDimension","outputDimension"]);return Object.assign(n(i({inputDimension:t,outputDimension:e},r)),y)}function k(s,t){return Object.assign(s,{train(s,i){if(!s||s.empty())throw new Error("The training set is empty");return i&&i.forEach(s=>{if(!this.includes(s))throw new Error(`Class labeled ${s} does not exist`)}),this.params.classes={},(i||s.labels()).forEach(i=>{const a=s.getPhrasesOfClass(i);this.params.classes[i]=t(a)}),this.params}})}const A={clear(){this.length=0,this.index=0,this.full=!1,this.buffer=[]},push(s){this.full?(this.buffer[this.index]=s,this.index=(this.index+1)%this.capacity):(this.buffer.push(s),this.length+=1,this.full=this.length===this.capacity)},get(s){return this.buffer[(s+this.index)%this.capacity]},fill(s){this.length=this.capacity,this.index=0,this.full=!0,this.buffer=Array(this.capacity).fill(s)},forEach(s){for(let t=0;t<this.length;t+=1)s(this.buffer[(t+this.index)%this.capacity],t)},values(){return this.buffer.slice(this.index).concat(this.buffer.slice(0,this.index))}};function S(s){const t=Object.create(A);return t.capacity=s,t.clear(),t}const E=s=>({likelihoodBuffer:S(1),setLikelihoodWindow(s){this.likelihoodWindow=s,this.likelihoodBuffer=S(s)},reset(){return this.likelihoodBuffer.clear(),this},predict(t){const i=this.likelihood(t);return s&&this.regression(t),this.updateResults(i),this.results},updateResults(s){this.results.instantLikelihood=s,this.likelihoodBuffer.push(Math.log(s)),this.results.logLikelihood=0;const t=this.likelihoodBuffer.length;for(let s=0;s<t;s+=1)this.results.logLikelihood+=this.likelihoodBuffer.get(s);this.results.logLikelihood/=t}});function C(s,t=1){if(!o(s))throw new Error("The base object must include a standard set of parameters (`params` key), @see `ModelBase`.");const i=Object.assign({instantLikelihood:0,logLikelihood:0},s.params.bimodal?{outputValues:[],outputCovariance:[]}:{});return Object.assign(s,E(s.params.bimodal),{results:i,likelihoodBuffer:S(t)})}function O(s,t,i){const a=Object.assign({},i);return Object.keys(t).forEach(e=>{const r=t[e];if(r.required&&!Object.keys(i).includes(e))throw new Error(`Stream parameter '${e}' is required for model '${s}'.`);!function(s,t,i,a){if(i){if(i.constructor===Array&&!i.includes(a))throw new Error(`Attribute '${t}' (value: '${a}') is not allowed for model '${s}' (options: [${i}]).`);if(i.constructor===Object){if(Object.keys(i).includes("min")&&a<i.min)throw new Error(`Attribute '${t}' (value: ${a}) is inferior to the minimum required value of ${i.min} for model '${s}'.`);if(Object.keys(i).includes("max")&&a>i.max)throw new Error(`Attribute '${t}' (value: ${a}) is superior to the maximum required value of ${i.min} for model '${s}'.`)}else if("function"==typeof i&&!i(a))throw new Error(`Attribute '${t}' (value: ${a}) is incompatible with model '${s}'.`)}}(s,e,r.check,i[e]),a[e]=r.transform?r.transform(i[e]):i[e]}),a}const j=s=>({gaussians:{required:!0,check:{min:1}},regularization:{required:!0,check:({absolute:s,relative:t})=>s&&t&&s>0&&t>0},covarianceMode:{required:!0,check:["full","diagonal"]},mixtureCoeffs:{required:!0,check:t=>t.length===s},components:{required:!0,check:t=>t.length===s}});const z={getLikelihoodWindow(){return this.likelihoodWindow},setLikelihoodWindow(s){this.likelihoodWindow=s,Object.keys(this.models).forEach(t=>{this.models[t].setLikelihoodWindow(s)})},reset(){Object.values(this.models).forEach(s=>s.reset()),this.results={labels:[],instantLikelihoods:[],smoothedLikelihoods:[],smoothedLogLikelihoods:[],smoothedNormalizedLikelihoods:[],likeliest:null,classes:{}},this.params.bimodal&&this.resetBimodal()},predict(s){Object.values(this.models).forEach(t=>t.predict(s)),this.updateResults()},updateResults(){const s=Object.keys(this.models).sort();this.results.labels=s;let t=0,a=0,e=-1/0;this.results.classes=s.map((s,i)=>(this.results.instantLikelihoods[i]=this.models[s].results.instantLikelihood,this.results.smoothedLogLikelihoods[i]=this.models[s].results.logLikelihood,this.results.smoothedLikelihoods[i]=Math.exp(this.results.smoothedLogLikelihoods[i]),t+=this.results.instantLikelihoods[i],a+=this.results.smoothedLikelihoods[i],this.results.smoothedLogLikelihoods[i]>e&&(e=this.results.smoothedLogLikelihoods[i],this.results.likeliest=s),{[s]:this.models[s].results})).reduce((s,t)=>i({},s,t),{}),this.results.smoothedNormalizedLikelihoods=this.results.smoothedLikelihoods.map(s=>s/a),this.results.instantNormalizedLikelihoods=this.results.instantLikelihoods.map(s=>s/t),this.params.bimodal&&this.updateRegressionResults()}},q={resetBimodal(){this.results.outputValues=[],this.results.outputCovariance=[]},updateRegressionResults(){if("likeliest"===this.params.multiClassRegressionEstimator)this.results.outputValues=this.models[this.results.likeliest].results.outputValues,this.results.outputCovariance=this.models[this.results.likeliest].results.outputCovariance;else{if("mixture"!==this.params.multiClassRegressionEstimator)throw new Error("Unknown regression estimator, use `likeliest` or `mixture`");this.results.outputValues=Array(this.outputDimension).fill(0),this.results.outputCovariance=Array(this.outputDimension**("full"===this.configuration.covarianceMode?2:1)).fill(0),this.results.labels.forEach(s=>{this.results.outputValues.map((t,i)=>t+this.results.smoothedNormalizedLikelihoods[i]*this.models[s].results.outputValues[i]),this.results.outputCovariance.map((t,i)=>t+this.results.smoothedNormalizedLikelihoods[i]*this.models[s].results.outputCovariance[i])})}}};function L(s,t="likeliest"){if(!o(s))throw new Error("The base object must include a standard set of parameters (`params` key), @see `ModelBase`.");const i=Object.assign(s,z,s.params.bimodal?q:{});return i.params.multiClassRegressionEstimator=t,i}function N(s,t,a){const{inputDimension:e,outputDimension:r}=s,{gaussians:o,regularization:h,covarianceMode:l}=t;return function(s,t=1,a={absolute:.001,relative:.01},e="full"){if(!Object.keys(s).includes("params"))throw new Error("The base object must include a standard set of parameters (`params` key), @see `ModelBase`.");return Object.assign(s,M,{params:i({},s.params,{gaussians:t,regularization:a,covarianceMode:e})})}(v(x(n(i({inputDimension:e,outputDimension:r},t))),a),o,h,l).train(s)}function P(s,t){const i=function(s){if(!o(s))throw new Error("The base object must include a standard set of parameters (`params` key), @see `ModelBase`.");return O("GMM",j(s.params.gaussians),s.params),Object.assign(s,{beta:new Array(s.params.gaussians).fill(0)})}(C(x(n(s)),t));return s.components.forEach((t,a)=>{i.params.components[a]=Object.assign(f(s.inputDimension,s.outputDimension,s.covarianceMode),t)}),i.reset(),i}const I={forwardInitialized:!1,isHierarchical:!1,initializeForwardAlgorithm(s){let t=0;if("ergodic"===this.params.transitionMode)for(let i=0;i<this.params.states;i+=1)this.alpha[i]=this.params.prior[i]*this.params.xStates[i].likelihood(s),t+=this.alpha[i];else this.alpha=new Array(this.params.states).fill(0),this.alpha[0]=this.params.xStates[0].likelihood(s),t+=this.alpha[0];if(this.forwardInitialized=!0,t>0){for(let s=0;s<this.params.states;s+=1)this.alpha[s]/=t;return 1/t}for(let s=0;s<this.params.states;s+=1)this.alpha[s]=1/this.params.states;return 1},updateForwardAlgorithm(s){let t=0;this.previousAlpha=this.alpha.slice();for(let i=0;i<this.params.states;i+=1){if(this.alpha[i]=0,"ergodic"===this.params.transitionMode)for(let s=0;s<this.params.states;s+=1)this.alpha[i]+=this.previousAlpha[s]*this.params.transition[s][i];else this.alpha[i]+=this.previousAlpha[i]*this.params.transition[2*i],i>0?this.alpha[i]+=this.previousAlpha[i-1]*this.params.transition[2*(i-1)+1]:this.alpha[0]+=this.previousAlpha[this.params.states-1]*this.params.transition[2*this.params.states-1];this.alpha[i]*=this.params.xStates[i].likelihood(s),t+=this.alpha[i]}if(t>1e-300){for(let s=0;s<this.params.states;s+=1)this.alpha[s]/=t;return 1/t}return 0}};function B(s){if(!o(s))throw new Error("The base object must include a standard set of parameters (`params` key), @see `ModelBase`.");return Object.assign(s,I)}const T={initTraining(s){s&&!s.empty()&&(this.allocate(s),this.initParametersToDefault(s.standardDeviation()),this.params.gaussians>1?this.initMeansCovariancesWithGMMEM(s):(this.initMeansWithAllPhrases(s),this.initCovariancesFullyObserved(s)))},allocate(s){const{inputDimension:t,outputDimension:i,gaussians:a,regularization:e,covarianceMode:r}=this.params;this.params.xStates=Array.from(new Array(this.params.states),()=>x(n({inputDimension:t,outputDimension:i,gaussians:a,regularization:e,covarianceMode:r}))),this.params.xStates.forEach(s=>s.allocate()),this.alpha=new Array(this.params.states).fill(0),this.previousAlpha=new Array(this.params.states).fill(0),this.beta=new Array(this.params.states).fill(0),this.previousBeta=new Array(this.params.states).fill(0);const o=s.size();this.gammaSequence=new Array(o).fill(null),this.epsilonSequence=new Array(o).fill(null),this.gammaSequenceperMixture=new Array(o).fill(null);let h=0;s.forEach(s=>{const t=s.length;this.gammaSequence[h]=Array.from(new Array(t),()=>new Array(this.params.states).fill(0)),"ergodic"===this.params.transitionMode?this.epsilonSequence[h]=Array.from(new Array(t),()=>Array.from(new Array(this.params.states),()=>new Array(this.params.states).fill(0))):this.epsilonSequence[h]=Array.from(new Array(t),()=>new Array(2*this.params.states).fill(0)),this.gammaSequenceperMixture[h]=new Array(this.params.gaussians).fill(0);for(let s=0;s<this.params.gaussians;s+=1)this.gammaSequenceperMixture[h][s]=Array.from(new Array(t),()=>new Array(this.params.states).fill(0));h+=1}),this.gammaSum=new Array(this.params.states).fill(0),this.gammaSumPerMixture=new Array(this.params.states*this.params.gaussians).fill(0)},updateTraining(s){let t=0,i=0;s.forEach(s=>{s.length>0&&(t+=this.baumWelchForwardBackward(s,i)),i+=1}),this.baumWelchGammaSum(s);for(let s=0;s<this.params.states;s+=1)for(let t=0;t<this.params.gaussians;t+=1)this.params.xStates[s].params.mixtureCoeffs[t]=0,"full"===this.params.covarianceMode?this.params.xStates[s].params.components[t].covariance=new Array(this.params.dimension**2).fill(0):this.params.xStates[s].params.components[t].covariance=new Array(this.params.dimension).fill(0);return this.baumWelchEstimateMixtureCoefficients(s),this.baumWelchEstimateMeans(s),this.baumWelchEstimateCovariances(s),"ergodic"===this.params.transitionMode&&this.baumWelchEstimatePrior(s),this.baumWelchEstimateTransitions(s),t},terminateTraining(){this.normalizeTransitions(),this.gammaSequence=null,this.epsilonSequence=null,this.gammaSequenceperMixture=null,this.alphaSeq=null,this.betaSeq=null,this.gammaSum=null,this.gammaSumPerMixture=null,this.params.xStates=this.params.xStates.map(s=>s.params)},initParametersToDefault(s){"ergodic"===this.params.transitionMode?this.setErgodic():this.setLeftRight();const t=s.map(s=>Math.max(this.params.regularization.absolute,this.params.regularization.relative*s)),i="full"===this.params.covarianceMode?()=>new Array(this.params.dimension**2).fill(this.params.regularization.absolute/2):()=>new Array(this.params.dimension).fill(0);for(let s=0;s<this.params.states;s+=1){const a=this.params.xStates[s];a.currentRegularization=t;for(let s=0;s<this.params.gaussians;s+=1)a.params.components[s].covariance=i(),a.params.components[s].regularize(t),a.params.mixtureCoeffs[s]=1/this.params.gaussians}},initMeansWithAllPhrases(s){if(!s||s.empty())return;for(let s=0;s<this.params.states;s+=1)for(let t=0;t<this.params.dimension;t+=1)this.params.xStates[s].params.components[0].mean[t]=0;const t=new Array(this.params.states).fill(0);s.forEach(s=>{const i=Math.floor(s.length/this.params.states);let a=0;for(let e=0;e<this.params.states;e+=1){for(let t=0;t<i;t+=1)for(let i=0;i<this.params.dimension;i+=1)this.params.xStates[e].params.components[0].mean[i]+=s.get(a+t,i);a+=i,t[e]+=i}});for(let s=0;s<this.params.states;s+=1)for(let i=0;i<this.params.dimension;i+=1)this.params.xStates[s].params.components[0].mean[i]/=t[s]},initCovariancesFullyObserved(s){if(!s||s.empty())return;for(let s=0;s<this.params.states;s+=1)this.params.xStates[s].params.components[0].covariance=new Array(this.params.dimension**("full"===this.params.covarianceMode?2:1)).fill(0);const t=new Array(this.params.states).fill(0),i=new Array(this.params.states*this.params.dimension).fill(0);s.forEach(s=>{const a=Math.floor(s.length/this.params.states);let e=0;for(let r=0;r<this.params.states;r+=1){for(let t=0;t<a;t+=1)for(let a=0;a<this.params.dimension;a+=1)if(i[r*this.params.dimension+a]+=s.get(e+t,a),"full"===this.params.covarianceMode)for(let i=0;i<this.params.dimension;i+=1)this.params.xStates[r].params.components[0].covariance[a*this.params.dimension+i]+=s.get(e+t,a)*s.get(e+t,i);else this.params.xStates[r].params.components[0].covariance[a]+=s.get(e+t,a)**2;e+=a,t[r]+=a}});for(let s=0;s<this.params.states;s+=1)for(let a=0;a<this.params.dimension;a+=1)if(i[s*this.params.dimension+a]/=t[s],"full"===this.params.covarianceMode)for(let i=0;i<this.params.dimension;i+=1)this.params.xStates[s].params.components[0].covariance[a*this.params.dimension+i]/=t[s];else this.params.xStates[s].params.components[0].covariance[a]/=t[s];for(let s=0;s<this.params.states;s+=1){for(let t=0;t<this.params.dimension;t+=1)if("full"===this.params.covarianceMode)for(let a=0;a<this.params.dimension;a+=1)this.params.xStates[s].params.components[0].covariance[t*this.params.dimension+a]-=i[s*this.params.dimension+t]*i[s*this.params.dimension+a];else this.params.xStates[s].params.components[0].covariance[t]-=i[s*this.params.dimension+t]*i[s*this.params.dimension+t];this.params.xStates[s].regularize(),this.params.xStates[s].updateInverseCovariances()}},initMeansCovariancesWithGMMEM(s){for(let t=0;t<this.params.states;t+=1){const i=r(this.params);if(s.forEach((s,a)=>{const e=Math.floor(s.length/this.params.states);if(e>0){i.push(a,s.label);for(let r=t*e;r<(t+1)*e;r+=1)i.getPhrase(a).push(s.getFrame(r))}}),!i.empty()){const s=N(i,this.params);for(let i=0;i<this.params.gaussians;i+=1)this.params.xStates[t].params.components[i].mean=s.components[i].mean,this.params.xStates[t].params.components[i].covariance=s.components[i].covariance,this.params.xStates[t].updateInverseCovariances()}}},setErgodic(){const s=1/this.params.states;this.params.prior=new Array(this.params.states).fill(s),this.params.transition=Array.from(new Array(this.params.states),()=>new Array(this.params.states).fill(s))},setLeftRight(){this.params.prior=new Array(this.params.states).fill(0),this.params.prior[0]=1,this.params.transition=new Array(2*this.params.states).fill(.5),this.params.transition[2*(this.params.states-1)]=1,this.params.transition[2*(this.params.states-1)+1]=0},normalizeTransitions(){if("ergodic"===this.params.transitionMode){const s=this.params.prior.reduce((s,t)=>s+t,0);for(let t=0;t<this.params.states;t+=1){this.params.prior[t]/=s;let i=0;for(let s=0;s<this.params.states;s+=1)i+=this.params.transition[t][s];for(let s=0;s<this.params.states;s+=1)this.params.transition[t][s]/=i}}else for(let s=0;s<this.params.states;s+=1){const t=this.params.transition[2*s]+this.params.transition[2*s+1];this.params.transition[2*s]/=t,this.params.transition[2*s+1]/=t}},initializeBackwardAlgorithm(s){for(let t=0;t<this.params.states;t+=1)this.beta[t]=s},updateBackwardAlgorithm(s,t){this.previousBeta=this.beta.slice();for(let i=0;i<this.params.states;i+=1){if(this.beta[i]=0,"ergodic"===this.params.transitionMode)for(let s=0;s<this.params.states;s+=1)this.beta[i]+=this.params.transition[i][s]*this.previousBeta[s]*this.params.xStates[s].likelihood(t);else this.beta[i]+=this.params.transition[2*i]*this.previousBeta[i]*this.params.xStates[i].likelihood(t),i<this.params.states-1&&(this.beta[i]+=this.params.transition[2*i+1]*this.previousBeta[i+1]*this.params.xStates[i+1].likelihood(t));this.beta[i]*=s,(Number.isNaN(this.beta[i])||Math.abs(this.beta[i])===1/0)&&(this.beta[i]=1e100)}},baumWelchForwardUpdate(s){let t=0;this.previousAlpha=this.alpha.slice();for(let i=0;i<this.params.states;i+=1){if(this.alpha[i]=0,"ergodic"===this.params.transitionMode)for(let s=0;s<this.params.states;s+=1)this.alpha[i]+=this.previousAlpha[s]*this.params.transition[s][i];else this.alpha[i]+=this.previousAlpha[i]*this.params.transition[2*i],i>0?this.alpha[i]+=this.previousAlpha[i-1]*this.params.transition[2*(i-1)+1]:this.alpha[0]+=this.previousAlpha[this.params.states-1]*this.params.transition[2*this.params.states-1];this.alpha[i]*=s[i],t+=this.alpha[i]}if(Number.isNaN(t))throw new Error("Holy molly");if(t>1e-300){for(let s=0;s<this.params.states;s+=1)this.alpha[s]/=t;return 1/t}return 0},baumWelchBackwardUpdate(s,t){this.previousBeta=this.beta.slice();for(let i=0;i<this.params.states;i+=1){if(this.beta[i]=0,"ergodic"===this.params.transitionMode)for(let s=0;s<this.params.states;s+=1)this.beta[i]+=this.params.transition[i][s]*this.previousBeta[s]*t[s];else this.beta[i]+=this.params.transition[2*i]*this.previousBeta[i]*t[i],i<this.params.states-1&&(this.beta[i]+=this.params.transition[2*i+1]*this.previousBeta[i+1]*t[i+1]);this.beta[i]*=s,(Number.isNaN(this.beta[i])||Math.abs(this.beta[i])===1/0)&&(this.beta[i]=1e100)}},baumWelchForwardBackward(s,t){const i=s.length,a=new Array(i).fill(0);let e;this.alphaSeq=[],this.betaSeq=[];const r=Array.from(new Array(i),()=>new Array(this.params.states).fill(0));for(let t=0;t<i;t+=1)for(let i=0;i<this.params.states;i+=1)r[t][i]=this.params.xStates[i].likelihood(s.getFrame(t));a[0]=this.initializeForwardAlgorithm(s.getFrame(0)),e=-Math.log(a[0]),this.alphaSeq.push(this.alpha.slice());for(let s=1;s<i;s+=1)a[s]=this.baumWelchForwardUpdate(r[s]),e-=Math.log(a[s]),this.alphaSeq.push(this.alpha.slice());this.initializeBackwardAlgorithm(a[i-1]),this.betaSeq.push(this.beta.slice());for(let s=i-2;s>=0;s-=1)this.baumWelchBackwardUpdate(a[s],r[s+1]),this.betaSeq.push(this.beta.slice());this.betaSeq.reverse();for(let s=0;s<i;s+=1)for(let i=0;i<this.params.states;i+=1)this.gammaSequence[t][s][i]=this.alphaSeq[s][i]*this.betaSeq[s][i]/a[s];let n;for(let a=0;a<i;a+=1)for(let i=0;i<this.params.states;i+=1){if(n=0,1===this.params.gaussians){const s=r[a][i];this.gammaSequenceperMixture[t][0][a][i]=this.gammaSequence[t][a][i]*s,n+=s}else for(let e=0;e<this.params.gaussians;e+=1){const r=this.params.xStates[i].componentLikelihood(s.getFrame(a),e);this.gammaSequenceperMixture[t][e][a][i]=this.gammaSequence[t][a][i]*r,n+=r}if(n>0)for(let s=0;s<this.params.gaussians;s+=1)this.gammaSequenceperMixture[t][s][a][i]/=n}if("ergodic"===this.params.transitionMode)for(let s=0;s<i-1;s+=1)for(let i=0;i<this.params.states;i+=1)for(let a=0;a<this.params.states;a+=1)this.epsilonSequence[t][s][i][a]=this.alphaSeq[s][i]*this.params.transition[i][a]*this.betaSeq[s+1][a],this.epsilonSequence[t][s][i][a]*=r[s+1][a];else for(let s=0;s<i-1;s+=1)for(let i=0;i<this.params.states;i+=1)this.epsilonSequence[t][s][2*i]=this.alphaSeq[s][i]*this.params.transition[2*i]*this.betaSeq[s+1][i],this.epsilonSequence[t][s][2*i]*=r[s+1][i],i<this.params.states-1&&(this.epsilonSequence[t][s][2*i+1]=this.alphaSeq[s][i]*this.params.transition[2*i+1]*this.betaSeq[s+1][i+1],this.epsilonSequence[t][s][2*i+1]*=r[s+1][i+1]);return e},baumWelchGammaSum(s){for(let s=0;s<this.params.states;s+=1){this.gammaSum[s]=0;for(let t=0;t<this.params.gaussians;t+=1)this.gammaSumPerMixture[s*this.params.gaussians+t]=0}let t=0;s.forEach(s=>{for(let i=0;i<this.params.states;i+=1)for(let a=0;a<s.length;a+=1){this.gammaSum[i]+=this.gammaSequence[t][a][i];for(let s=0;s<this.params.gaussians;s+=1)this.gammaSumPerMixture[i*this.params.gaussians+s]+=this.gammaSequenceperMixture[t][s][a][i]}t+=1})},baumWelchEstimateMixtureCoefficients(s){let t=0;s.forEach(s=>{for(let i=0;i<this.params.states;i+=1)for(let a=0;a<s.length;a+=1)for(let s=0;s<this.params.gaussians;s+=1)this.params.xStates[i].params.mixtureCoeffs[s]+=this.gammaSequenceperMixture[t][s][a][i];t+=1});for(let s=0;s<this.params.states;s+=1)this.params.xStates[s].normalizeMixtureCoeffs()},baumWelchEstimateMeans(s){for(let s=0;s<this.params.states;s+=1)for(let t=0;t<this.params.gaussians;t+=1)this.params.xStates[s].params.components[t].mean.fill(0);let t=0;s.forEach(s=>{for(let i=0;i<this.params.states;i+=1)for(let a=0;a<s.length;a+=1)for(let e=0;e<this.params.gaussians;e+=1)for(let r=0;r<this.params.dimension;r+=1)this.params.xStates[i].params.components[e].mean[r]+=this.gammaSequenceperMixture[t][e][a][i]*s.get(a,r);t+=1});for(let s=0;s<this.params.states;s+=1)for(let t=0;t<this.params.gaussians;t+=1)for(let i=0;i<this.params.dimension;i+=1)if(this.gammaSumPerMixture[s*this.params.gaussians+t]>0&&(this.params.xStates[s].params.components[t].mean[i]/=this.gammaSumPerMixture[s*this.params.gaussians+t]),Number.isNaN(this.params.xStates[s].params.components[t].mean[i]))throw new Error("Convergence Error")},baumWelchEstimateCovariances(s){let t=0;s.forEach(s=>{for(let i=0;i<this.params.states;i+=1)for(let a=0;a<s.length;a+=1)for(let e=0;e<this.params.gaussians;e+=1)for(let r=0;r<this.params.dimension;r+=1)if("full"===this.params.covarianceMode)for(let n=r;n<this.params.dimension;n+=1)this.params.xStates[i].params.components[e].covariance[r*this.params.dimension+n]+=this.gammaSequenceperMixture[t][e][a][i]*(s.get(a,r)-this.params.xStates[i].params.components[e].mean[r])*(s.get(a,n)-this.params.xStates[i].params.components[e].mean[n]);else{const n=s.get(a,r)-this.params.xStates[i].params.components[e].mean[r];this.params.xStates[i].params.components[e].covariance[r]+=this.gammaSequenceperMixture[t][e][a][i]*n**2}t+=1});for(let s=0;s<this.params.states;s+=1){for(let t=0;t<this.params.gaussians;t+=1)if(this.gammaSumPerMixture[s*this.params.gaussians+t]>0)for(let i=0;i<this.params.dimension;i+=1)if("full"===this.params.covarianceMode)for(let a=i;a<this.params.dimension;a+=1)this.params.xStates[s].params.components[t].covariance[i*this.params.dimension+a]/=this.gammaSumPerMixture[s*this.params.gaussians+t],i!==a&&(this.params.xStates[s].params.components[t].covariance[a*this.params.dimension+i]=this.params.xStates[s].params.components[t].covariance[i*this.params.dimension+a]);else this.params.xStates[s].params.components[t].covariance[i]/=this.gammaSumPerMixture[s*this.params.gaussians+t];this.params.xStates[s].regularize(),this.params.xStates[s].updateInverseCovariances()}},baumWelchEstimatePrior(s){this.params.prior.fill(0);let t=0;for(let i=0;i<s.size();i+=1)for(let s=0;s<this.params.states;s+=1)this.params.prior[s]+=this.gammaSequence[i][0][s],t+=this.params.prior[s];if(!(t>0))throw new Error("The Prior is all ZERO.....");for(let s=0;s<this.params.states;s+=1)this.params.prior[s]/=t},baumWelchEstimateTransitions(s){this.params.transition="ergodic"===this.params.transitionMode?Array.from(new Array(this.params.states),()=>new Array(this.params.states).fill(0)):new Array(2*this.params.states).fill(0);let t=0;if(s.forEach(s=>{if(s.length>0)for(let i=0;i<this.params.states;i+=1)if("leftright"===this.params.transitionMode&&(this.params.transition[2*i]+=1e-5,i<this.params.states-1?this.params.transition[2*i+1]+=1e-5:this.params.transition[2*i]+=1e-5),"ergodic"===this.params.transitionMode)for(let a=0;a<this.params.states;a+=1)for(let e=0;e<s.length-1;e+=1)this.params.transition[i][a]+=this.epsilonSequence[t][e][i][a];else{for(let a=0;a<s.length-1;a+=1)this.params.transition[2*i]+=this.epsilonSequence[t][a][2*i];if(i<this.params.states-1)for(let a=0;a<s.length-1;a+=1)this.params.transition[2*i+1]+=this.epsilonSequence[t][a][2*i+1]}t+=1}),"ergodic"===this.params.transitionMode){for(let s=0;s<this.params.states;s+=1)for(let t=0;t<this.params.states;t+=1)if(this.params.transition[s][t]/=this.gammaSum[s]+2e-5,Number.isNaN(this.params.transition[s][t]))throw new Error("Convergence Error. Check your training data or increase the variance offset")}else for(let s=0;s<this.params.states;s+=1){if(this.params.transition[2*s]/=this.gammaSum[s]+2e-5,Number.isNaN(this.params.transition[2*s]))throw new Error("Convergence Error. Check your training data or increase the variance offset");if(s<this.params.states-1&&(this.params.transition[2*s+1]/=this.gammaSum[s]+2e-5,Number.isNaN(this.params.transition[2*s+1])))throw new Error("Convergence Error. Check your training data or increase the variance offset")}}};const W=(s,t)=>({states:{required:!0,check:{min:1}},gaussians:{required:!0,check:{min:1}},regularization:{required:!0,check:({absolute:s,relative:t})=>s&&t&&s>0&&t>0},transitionMode:{required:!0,check:["ergodic","leftright"]},covarianceMode:{required:!0,check:["full","diagonal"]},prior:{required:!0,check:i=>"leftright"===t||i.length===s},transition:{required:!0,check:i=>"leftright"===t?i.length===2*s:i.length===s},xStates:{required:!0,check:t=>t.length===s}}),V={forwardInitialized:!1,isHierarchical:!1,setup(){return this.params.xStates=this.params.xStates.map(s=>P(s).reset()),this},reset(){return this.likelihoodBuffer.clear(),this.params.xStates.forEach(s=>{s.reset()}),this},likelihood(s){const t=this.forwardInitialized?this.updateForwardAlgorithm(s):this.initializeForwardAlgorithm(s);return this.updateAlphaWindow(),this.updateProgress(),1/t},updateProgress(){this.results.progress=0;for(let s=this.windowMinindex;s<this.windowMaxindex;s+=1)this.isHierarchical?this.results.progress+=(this.alpha[s]+this.alpha1[s]+this.alpha2[s])*(s/this.windowNormalizationConstant):this.results.progress+=this.alpha[s]*s/this.windowNormalizationConstant;this.results.progress/=this.params.states-1},updateAlphaWindow(){this.results.likeliestState=0;let s=this.isHierarchical?this.alpha[0]+this.alpha1[0]:this.alpha[0];for(let t=1;t<this.params.states;t+=1)this.isHierarchical?this.alpha[t]+this.alpha1[t]>s&&(s=this.alpha[t]+this.alpha1[t],this.results.likeliestState=t):this.alpha[t]>s&&(s=this.alpha[t],this.results.likeliestState=t);this.windowMinindex=this.results.likeliestState-Math.floor(this.params.states/2),this.windowMaxindex=this.results.likeliestState+Math.floor(this.params.states/2),this.windowMinindex=this.windowMinindex>=0?this.windowMinindex:0,this.windowMaxindex=this.windowMaxindex<=this.params.states?this.windowMaxindex:this.params.states,this.windowNormalizationConstant=0;for(let s=this.windowMinindex;s<this.windowMaxindex;s+=1)this.windowNormalizationConstant+=this.isHierarchical?this.alpha[s]+this.alpha1[s]:this.alpha[s]}},F={regression(s){if(this.results.outputValues=Array(this.params.outputDimension).fill(0),this.results.outputCovariance=Array("full"===this.params.covarianceMode?this.params.outputDimension**2:this.params.outputDimension).fill(0),"likeliest"===this.params.regressionEstimator)return this.params.xStates[this.results.likeliestState].predict(s),this.results.outputValues=this.params.xStates[this.results.likeliestState].results.outputValues,this.results.outputValues;const t="full"===this.params.regressionEstimator?0:this.windowMinindex,i="full"===this.params.regressionEstimator?this.params.states:this.windowMaxindex;let a="full"===this.params.regressionEstimator?1:this.windowNormalizationConstant;a<=0&&(a=1);for(let e=t;e<i;e+=1){this.params.xStates[e].likelihood(s),this.params.xStates[e].regression(s);const t=this.params.xStates[e].results.outputValues;for(let s=0;s<this.params.outputDimension;s+=1)if(this.isHierarchical)if(this.results.outputValues[s]+=(this.alpha[e]+this.alpha1[e])*(t[s]/a),"full"===this.params.covarianceMode)for(let t=0;t<this.params.outputDimension;t+=1)this.results.outputCovariance[s*this.params.outputDimension+t]+=(this.alpha[e]+this.alpha1[e])*(this.alpha[e]+this.alpha1[e])*(this.params.xStates[e].results.outputCovariance[s*this.params.outputDimension+t]/a);else this.results.outputCovariance[s]+=(this.alpha[e]+this.alpha1[e])*(this.alpha[e]+this.alpha1[e])*(this.params.xStates[e].results.outputCovariance[s]/a);else if(this.results.outputValues[s]+=this.alpha[e]*(t[s]/a),"full"===this.params.covarianceMode)for(let t=0;t<this.params.outputDimension;t+=1)this.results.outputCovariance[s*this.params.outputDimension+t]+=this.alpha[e]**2*(this.params.xStates[e].results.outputCovariance[s*this.params.outputDimension+t]/a);else this.results.outputCovariance[s]+=this.alpha[e]**2*this.params.xStates[e].results.outputCovariance[s]/a}return this.results.outputValues}};const R={forwardInitialized:!1,setup(){const s=this.size();return this.params.prior=new Array(s).fill(1/s),this.params.transition=Array.from(new Array(s),()=>new Array(s).fill(1/s)),this.params.exitTransition=new Array(s).fill(.1),Object.values(this.models).forEach(s=>{s.isHierarchical=!0}),this.updateExitProbabilities(),this},updateExitProbabilities(s){const t=void 0!==s?s:new Array(this.params.states-1).fill(0).concat([.1]);Object.keys(this.models).forEach(s=>{this.models[s].params.exitProbabilities=t.slice()})},reset(){Object.values(this.models).forEach(s=>s.reset()),this.results={labels:[],instantLikelihoods:[],smoothedLikelihoods:[],smoothedLogLikelihoods:[],smoothedNormalizedLikelihoods:[],exitLikelihood:[],likeliest:null,classes:{}},this.params.bimodal&&this.resetBimodal(),this.forwardInitialized=!1},predict(s){if(this.forwardInitialized?this.updateForwardAlgorithm(s):this.initializeForwardAlgorithm(s),Object.keys(this.models).sort().forEach(s=>{const t=this.models[s];t.updateAlphaWindow(),t.updateProgress(),t.updateResults(t.results.instantLikelihood)}),this.updateResults(),this.params.bimodal)if(Object.values(this.models).forEach(t=>t.regression(s)),"likeliest"===this.params.multiClassRegressionEstimator)this.results.outputValues=this.models[this.results.likeliest].results.outputValues,this.results.outputCovariance=this.models[this.results.likeliest].results.outputCovariance;else{this.results.outputValues=new Array(this.outputDimension).fill(0),this.results.outputCovariance=new Array("full"===this.params.covarianceMode?this.outputDimension**2:this.outputDimension).fill(0);let s=0;Object.values(this.models).forEach(t=>{for(let i=0;i<this.outputDimension;i+=1)if(this.results.outputValues[i]+=this.results.smoothedNormalizedLikelihoods[s]*t.second.results.outputValues[i],"full"===this.params.covarianceMode)for(let a=0;a<this.outputDimension;a+=1)this.results.outputCovariance[i*this.outputDimension+a]+=this.results.smoothedNormalizedLikelihoods[s]*t.results.outputCovariance[i*this.outputDimension+a];else this.results.outputCovariance[i]+=this.results.smoothedNormalizedLikelihoods[s]*t.second.results.outputCovariance[i];s+=1})}},initializeForwardAlgorithm(s){let t=0,i=0;const a=Object.keys(this.models).sort();a.forEach(a=>{const e=this.models[a],r=e.params.states;if(e.alpha1=new Array(r).fill(0),e.alpha2=new Array(r).fill(0),"ergodic"===e.params.transitionMode){e.results.instantLikelihood=0;for(let t=0;t<r;t+=1)e.alpha[t]=this.params.prior[i]*e.params.prior[t]*e.params.xStates[t].likelihood(s),e.results.instantLikelihood+=e.alpha[t]}else e.alpha[0]=this.params.prior[i]*e.params.xStates[0].likelihood(s),[e.results.instantLikelihood]=e.alpha;t+=e.results.instantLikelihood,i+=1}),a.forEach(s=>{const i=this.models[s],a=i.params.states;for(let s=0;s<a;s+=1)i.alpha[s]/=t}),this.frontierV1=new Array(this.size).fill(0),this.frontierV2=new Array(this.size).fill(0),this.forwardInitialized=!0},updateForwardAlgorithm(s){let t=0,i=0;this.frontierV1=this.likelihoodAlpha(1),this.frontierV2=this.likelihoodAlpha(2);let a=0;const e=Object.keys(this.models).sort();e.forEach(e=>{const r=this.models[e],n=r.params.states,o=new Array(n).fill(0);if("ergodic"===r.params.transitionMode)for(let s=0;s<n;s+=1){for(let t=0;t<n;t+=1)o[s]+=r.params.transition[t][s]/(1-r.params.exitProbabilities[t])*r.alpha[t];for(let t=0;t<this.size();t+=1)o[s]+=r.params.prior[s]*(this.frontierV1[t]*this.params.transition[t][a]+this.params.prior[a]*this.frontierV2[t])}else{o[0]=r.params.transition[0]*r.alpha[0];for(let s=0;s<this.size();s+=1)o[0]+=this.frontierV1[s]*this.params.transition[s][a]+this.params.prior[a]*this.frontierV2[s];for(let s=1;s<n;s+=1)o[s]+=r.params.transition[2*s]/(1-r.params.exitProbabilities[s])*r.alpha[s],o[s]+=r.params.transition[2*(s-1)+1]/(1-r.params.exitProbabilities[s-1])*r.alpha[s-1];for(let s=0;s<n;s+=1)r.alpha[s]=0,r.alpha1[s]=0,r.alpha2[s]=0}r.results.exitLikelihood=0,r.results.instantLikelihood=0;for(let e=0;e<n;e+=1)i=r.params.xStates[e].likelihood(s)*o[e],r.alpha2[e]=this.params.exitTransition[a]*r.params.exitProbabilities[e]*i,r.alpha1[e]=(1-this.params.exitTransition[a])*r.params.exitProbabilities[e]*i,r.alpha[e]=(1-r.params.exitProbabilities[e])*i,r.results.exitLikelihood+=r.alpha1[e]+r.alpha2[e],r.results.instantLikelihood+=r.alpha[e]+r.alpha1[e]+r.alpha2[e],t+=i;r.results.exitRatio=r.results.exitLikelihood/r.results.instantLikelihood,a+=1}),e.forEach(s=>{const i=this.models[s],a=i.params.states;for(let s=0;s<a;s+=1)i.alpha[s]/=t,i.alpha1[s]/=t,i.alpha2[s]/=t})},likelihoodAlpha(s){const t=new Array(this.size()).fill(0);if(s<0){let s=0;Object.keys(this.models).sort().forEach(i=>{const a=this.models[i];t[s]=0;for(let i=0;i<a.params.states;i+=1)t[s]+=a.second.alpha[i]+a.second.alpha1[i]+a.second.alpha2[i];s+=1})}else{let i=0;Object.keys(this.models).sort().forEach(a=>{const e=this.models[a];t[i]=0;let{alpha:r}=e;1===s&&(r=e.alpha1),2===s&&(r=e.alpha2);for(let s=0;s<e.params.states;s+=1)t[i]+=r[s];i+=1})}return t}};function $(s,t,a){const{inputDimension:e,outputDimension:r}=s,{states:o,gaussians:h,regularization:l,transitionMode:m,covarianceMode:p}=t;return function(s,t=1,a=1,e={absolute:.001,relative:.01},r="leftright",n="full"){if(!Object.keys(s).includes("params"))throw new Error("The base object must include a standard set of parameters (`params` key), @see `ModelBase`.");return Object.assign(s,T,{params:i({},s.params,{states:t,gaussians:a,regularization:e,transitionMode:r,covarianceMode:n})})}(v(B(n(i({inputDimension:e,outputDimension:r},t))),a),o,h,l,m,p).train(s)}function H(s,t){const i=function(s){if(!o(s))throw new Error("The base object must include a standard set of parameters (`params` key), @see `ModelBase`.");return O("HMM",W(s.params.states,s.params.transitionMode),s.params),Object.assign(s,V,s.params.bimodal?F:{},{alpha:new Array(s.params.states).fill(0),previous_alpha_:new Array(s.params.states).fill(0)}).setup()}(C(B(n(s)),t));return i.reset(),i}s.TrainingSet=r,s.trainKmeans=function(s,t,i){const{inputDimension:a,outputDimension:e}=s;return m(n({inputDimension:a,outputDimension:e}),t,i).train(s)},s.trainGMM=N,s.trainMulticlassGMM=function(s,t,a){const{inputDimension:e,outputDimension:r}=s;return k(D(i({inputDimension:e,outputDimension:r},t)),s=>N(s,t,a)).train(s)},s.GMMPredictor=P,s.MulticlassGMMPredictor=function(s,t){const i=L(D(s));return i.models={},Object.keys(s.classes).forEach(a=>{i.models[a]=P(s.classes[a],t)}),i.reset(),i},s.trainHMM=$,s.trainMulticlassHMM=function(s,t,a){const{inputDimension:e,outputDimension:r}=s;return k(D(i({inputDimension:e,outputDimension:r},t)),s=>$(s,t,a)).train(s)},s.HMMPredictor=H,s.MulticlassHMMPredictor=function(s,t){const i=L(D(s));return i.models={},Object.keys(s.classes).forEach(a=>{i.models[a]=H(s.classes[a],t)}),i.reset(),i},s.HierarchicalHMMPredictor=function(s,t){let i=D(s);return i.models={},Object.keys(s.classes).forEach(a=>{i.models[a]=H(s.classes[a],t)}),(i=function(s){if(!o(s))throw new Error("The base object must include a standard set of parameters (`params` key), @see `ModelBase`.");return Object.assign(s,R,{}).setup()}(L(i))).reset(),i},Object.defineProperty(s,"__esModule",{value:!0})});
//# sourceMappingURL=index.js.map
